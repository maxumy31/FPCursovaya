"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/gameWindow/page",{

/***/ "(app-pages-browser)/./node_modules/fp-ts/es6/function.js":
/*!********************************************!*\
  !*** ./node_modules/fp-ts/es6/function.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SK: () => (/* binding */ SK),\n/* harmony export */   absurd: () => (/* binding */ absurd),\n/* harmony export */   apply: () => (/* binding */ apply),\n/* harmony export */   constFalse: () => (/* binding */ constFalse),\n/* harmony export */   constNull: () => (/* binding */ constNull),\n/* harmony export */   constTrue: () => (/* binding */ constTrue),\n/* harmony export */   constUndefined: () => (/* binding */ constUndefined),\n/* harmony export */   constVoid: () => (/* binding */ constVoid),\n/* harmony export */   constant: () => (/* binding */ constant),\n/* harmony export */   decrement: () => (/* binding */ decrement),\n/* harmony export */   dual: () => (/* binding */ dual),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   flow: () => (/* binding */ flow),\n/* harmony export */   getBooleanAlgebra: () => (/* binding */ getBooleanAlgebra),\n/* harmony export */   getEndomorphismMonoid: () => (/* binding */ getEndomorphismMonoid),\n/* harmony export */   getMonoid: () => (/* binding */ getMonoid),\n/* harmony export */   getRing: () => (/* binding */ getRing),\n/* harmony export */   getSemigroup: () => (/* binding */ getSemigroup),\n/* harmony export */   getSemiring: () => (/* binding */ getSemiring),\n/* harmony export */   hole: () => (/* binding */ hole),\n/* harmony export */   identity: () => (/* binding */ identity),\n/* harmony export */   increment: () => (/* binding */ increment),\n/* harmony export */   not: () => (/* binding */ not),\n/* harmony export */   pipe: () => (/* binding */ pipe),\n/* harmony export */   tuple: () => (/* binding */ tuple),\n/* harmony export */   tupled: () => (/* binding */ tupled),\n/* harmony export */   unsafeCoerce: () => (/* binding */ unsafeCoerce),\n/* harmony export */   untupled: () => (/* binding */ untupled)\n/* harmony export */ });\nvar __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.10.0\n */\nvar getBooleanAlgebra = function (B) {\n    return function () { return ({\n        meet: function (x, y) { return function (a) { return B.meet(x(a), y(a)); }; },\n        join: function (x, y) { return function (a) { return B.join(x(a), y(a)); }; },\n        zero: function () { return B.zero; },\n        one: function () { return B.one; },\n        implies: function (x, y) { return function (a) { return B.implies(x(a), y(a)); }; },\n        not: function (x) { return function (a) { return B.not(x(a)); }; }\n    }); };\n};\n/**\n * Unary functions form a semigroup as long as you can provide a semigroup for the codomain.\n *\n * @example\n * import { Predicate, getSemigroup } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const S1 = getSemigroup(B.SemigroupAll)<number>()\n *\n * assert.deepStrictEqual(S1.concat(f, g)(1), true)\n * assert.deepStrictEqual(S1.concat(f, g)(3), false)\n *\n * const S2 = getSemigroup(B.SemigroupAny)<number>()\n *\n * assert.deepStrictEqual(S2.concat(f, g)(1), true)\n * assert.deepStrictEqual(S2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nvar getSemigroup = function (S) {\n    return function () { return ({\n        concat: function (f, g) { return function (a) { return S.concat(f(a), g(a)); }; }\n    }); };\n};\n/**\n * Unary functions form a monoid as long as you can provide a monoid for the codomain.\n *\n * @example\n * import { Predicate } from 'fp-ts/Predicate'\n * import { getMonoid } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const M1 = getMonoid(B.MonoidAll)<number>()\n *\n * assert.deepStrictEqual(M1.concat(f, g)(1), true)\n * assert.deepStrictEqual(M1.concat(f, g)(3), false)\n *\n * const M2 = getMonoid(B.MonoidAny)<number>()\n *\n * assert.deepStrictEqual(M2.concat(f, g)(1), true)\n * assert.deepStrictEqual(M2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nvar getMonoid = function (M) {\n    var getSemigroupM = getSemigroup(M);\n    return function () { return ({\n        concat: getSemigroupM().concat,\n        empty: function () { return M.empty; }\n    }); };\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nvar getSemiring = function (S) { return ({\n    add: function (f, g) { return function (x) { return S.add(f(x), g(x)); }; },\n    zero: function () { return S.zero; },\n    mul: function (f, g) { return function (x) { return S.mul(f(x), g(x)); }; },\n    one: function () { return S.one; }\n}); };\n/**\n * @category instances\n * @since 2.10.0\n */\nvar getRing = function (R) {\n    var S = getSemiring(R);\n    return {\n        add: S.add,\n        mul: S.mul,\n        one: S.one,\n        zero: S.zero,\n        sub: function (f, g) { return function (x) { return R.sub(f(x), g(x)); }; }\n    };\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nvar apply = function (a) {\n    return function (f) {\n        return f(a);\n    };\n};\n/**\n * @since 2.0.0\n */\nfunction identity(a) {\n    return a;\n}\n/**\n * @since 2.0.0\n */\nvar unsafeCoerce = identity;\n/**\n * @since 2.0.0\n */\nfunction constant(a) {\n    return function () { return a; };\n}\n/**\n * A thunk that returns always `true`.\n *\n * @since 2.0.0\n */\nvar constTrue = /*#__PURE__*/ constant(true);\n/**\n * A thunk that returns always `false`.\n *\n * @since 2.0.0\n */\nvar constFalse = /*#__PURE__*/ constant(false);\n/**\n * A thunk that returns always `null`.\n *\n * @since 2.0.0\n */\nvar constNull = /*#__PURE__*/ constant(null);\n/**\n * A thunk that returns always `undefined`.\n *\n * @since 2.0.0\n */\nvar constUndefined = /*#__PURE__*/ constant(undefined);\n/**\n * A thunk that returns always `void`.\n *\n * @since 2.0.0\n */\nvar constVoid = constUndefined;\nfunction flip(f) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (args.length > 1) {\n            return f(args[1], args[0]);\n        }\n        return function (a) { return f(a)(args[0]); };\n    };\n}\nfunction flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n    switch (arguments.length) {\n        case 1:\n            return ab;\n        case 2:\n            return function () {\n                return bc(ab.apply(this, arguments));\n            };\n        case 3:\n            return function () {\n                return cd(bc(ab.apply(this, arguments)));\n            };\n        case 4:\n            return function () {\n                return de(cd(bc(ab.apply(this, arguments))));\n            };\n        case 5:\n            return function () {\n                return ef(de(cd(bc(ab.apply(this, arguments)))));\n            };\n        case 6:\n            return function () {\n                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n            };\n        case 7:\n            return function () {\n                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n            };\n        case 8:\n            return function () {\n                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n            };\n        case 9:\n            return function () {\n                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n            };\n    }\n    return;\n}\n/**\n * @since 2.0.0\n */\nfunction tuple() {\n    var t = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        t[_i] = arguments[_i];\n    }\n    return t;\n}\n/**\n * @since 2.0.0\n */\nfunction increment(n) {\n    return n + 1;\n}\n/**\n * @since 2.0.0\n */\nfunction decrement(n) {\n    return n - 1;\n}\n/**\n * @since 2.0.0\n */\nfunction absurd(_) {\n    throw new Error('Called `absurd` function which should be uncallable');\n}\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from 'fp-ts/function'\n *\n * const add = tupled((x: number, y: number): number => x + y)\n *\n * assert.strictEqual(add([1, 2]), 3)\n *\n * @since 2.4.0\n */\nfunction tupled(f) {\n    return function (a) { return f.apply(void 0, a); };\n}\n/**\n * Inverse function of `tupled`\n *\n * @since 2.4.0\n */\nfunction untupled(f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return f(a);\n    };\n}\nfunction pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {\n    switch (arguments.length) {\n        case 1:\n            return a;\n        case 2:\n            return ab(a);\n        case 3:\n            return bc(ab(a));\n        case 4:\n            return cd(bc(ab(a)));\n        case 5:\n            return de(cd(bc(ab(a))));\n        case 6:\n            return ef(de(cd(bc(ab(a)))));\n        case 7:\n            return fg(ef(de(cd(bc(ab(a))))));\n        case 8:\n            return gh(fg(ef(de(cd(bc(ab(a)))))));\n        case 9:\n            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n        default: {\n            var ret = arguments[0];\n            for (var i = 1; i < arguments.length; i++) {\n                ret = arguments[i](ret);\n            }\n            return ret;\n        }\n    }\n}\n/**\n * Type hole simulation\n *\n * @since 2.7.0\n */\nvar hole = absurd;\n/**\n * @since 2.11.0\n */\nvar SK = function (_, b) { return b; };\n/**\n * Use `Predicate` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nfunction not(predicate) {\n    return function (a) { return !predicate(a); };\n}\n/**\n * Use `Endomorphism` module instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nvar getEndomorphismMonoid = function () { return ({\n    concat: function (first, second) { return flow(first, second); },\n    empty: identity\n}); };\n/** @internal */\nvar dual = function (arity, body) {\n    var isDataFirst = typeof arity === 'number' ? function (args) { return args.length >= arity; } : arity;\n    return function () {\n        var args = Array.from(arguments);\n        if (isDataFirst(arguments)) {\n            return body.apply(this, args);\n        }\n        return function (self) { return body.apply(void 0, __spreadArray([self], args, false)); };\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcC10cy9lczYvZnVuY3Rpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHFCQUFxQixTQUFJLElBQUksU0FBSTtBQUNqQyw2RUFBNkUsT0FBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCx5QkFBeUI7QUFDekIsZ0NBQWdDLHNCQUFzQiwrQkFBK0I7QUFDckYsZ0NBQWdDLHNCQUFzQiwrQkFBK0I7QUFDckYsNEJBQTRCLGdCQUFnQjtBQUM1QywyQkFBMkIsZUFBZTtBQUMxQyxtQ0FBbUMsc0JBQXNCLGtDQUFrQztBQUMzRiw0QkFBNEIsc0JBQXNCO0FBQ2xELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCx5QkFBeUI7QUFDekIsa0NBQWtDLHNCQUFzQjtBQUN4RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QixZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLDZCQUE2QjtBQUM3QixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGlDQUFpQztBQUN4QywyQkFBMkIsc0JBQXNCLDhCQUE4QjtBQUMvRSx3QkFBd0IsZ0JBQWdCO0FBQ3hDLDJCQUEyQixzQkFBc0IsOEJBQThCO0FBQy9FLHVCQUF1QjtBQUN2QixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzQkFBc0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1AseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPLDJCQUEyQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywwQ0FBMEM7QUFDakQsdUNBQXVDLDZCQUE2QjtBQUNwRTtBQUNBLENBQUM7QUFDRDtBQUNPO0FBQ1Asb0VBQW9FLCtCQUErQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EiLCJzb3VyY2VzIjpbIkk6XFxTY2FsYUN1cnNvdmF5YVxcQnVua2VyV2ViXFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxmcC10c1xcZXM2XFxmdW5jdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBpbnN0YW5jZXNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogQGNhdGVnb3J5IGluc3RhbmNlc1xuICogQHNpbmNlIDIuMTAuMFxuICovXG5leHBvcnQgdmFyIGdldEJvb2xlYW5BbGdlYnJhID0gZnVuY3Rpb24gKEIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgbWVldDogZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIGZ1bmN0aW9uIChhKSB7IHJldHVybiBCLm1lZXQoeChhKSwgeShhKSk7IH07IH0sXG4gICAgICAgIGpvaW46IGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gQi5qb2luKHgoYSksIHkoYSkpOyB9OyB9LFxuICAgICAgICB6ZXJvOiBmdW5jdGlvbiAoKSB7IHJldHVybiBCLnplcm87IH0sXG4gICAgICAgIG9uZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gQi5vbmU7IH0sXG4gICAgICAgIGltcGxpZXM6IGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gQi5pbXBsaWVzKHgoYSksIHkoYSkpOyB9OyB9LFxuICAgICAgICBub3Q6IGZ1bmN0aW9uICh4KSB7IHJldHVybiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gQi5ub3QoeChhKSk7IH07IH1cbiAgICB9KTsgfTtcbn07XG4vKipcbiAqIFVuYXJ5IGZ1bmN0aW9ucyBmb3JtIGEgc2VtaWdyb3VwIGFzIGxvbmcgYXMgeW91IGNhbiBwcm92aWRlIGEgc2VtaWdyb3VwIGZvciB0aGUgY29kb21haW4uXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IFByZWRpY2F0ZSwgZ2V0U2VtaWdyb3VwIH0gZnJvbSAnZnAtdHMvZnVuY3Rpb24nXG4gKiBpbXBvcnQgKiBhcyBCIGZyb20gJ2ZwLXRzL2Jvb2xlYW4nXG4gKlxuICogY29uc3QgZjogUHJlZGljYXRlPG51bWJlcj4gPSAobikgPT4gbiA8PSAyXG4gKiBjb25zdCBnOiBQcmVkaWNhdGU8bnVtYmVyPiA9IChuKSA9PiBuID49IDBcbiAqXG4gKiBjb25zdCBTMSA9IGdldFNlbWlncm91cChCLlNlbWlncm91cEFsbCk8bnVtYmVyPigpXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChTMS5jb25jYXQoZiwgZykoMSksIHRydWUpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFMxLmNvbmNhdChmLCBnKSgzKSwgZmFsc2UpXG4gKlxuICogY29uc3QgUzIgPSBnZXRTZW1pZ3JvdXAoQi5TZW1pZ3JvdXBBbnkpPG51bWJlcj4oKVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoUzIuY29uY2F0KGYsIGcpKDEpLCB0cnVlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChTMi5jb25jYXQoZiwgZykoMyksIHRydWUpXG4gKlxuICogQGNhdGVnb3J5IGluc3RhbmNlc1xuICogQHNpbmNlIDIuMTAuMFxuICovXG5leHBvcnQgdmFyIGdldFNlbWlncm91cCA9IGZ1bmN0aW9uIChTKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgIGNvbmNhdDogZnVuY3Rpb24gKGYsIGcpIHsgcmV0dXJuIGZ1bmN0aW9uIChhKSB7IHJldHVybiBTLmNvbmNhdChmKGEpLCBnKGEpKTsgfTsgfVxuICAgIH0pOyB9O1xufTtcbi8qKlxuICogVW5hcnkgZnVuY3Rpb25zIGZvcm0gYSBtb25vaWQgYXMgbG9uZyBhcyB5b3UgY2FuIHByb3ZpZGUgYSBtb25vaWQgZm9yIHRoZSBjb2RvbWFpbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgUHJlZGljYXRlIH0gZnJvbSAnZnAtdHMvUHJlZGljYXRlJ1xuICogaW1wb3J0IHsgZ2V0TW9ub2lkIH0gZnJvbSAnZnAtdHMvZnVuY3Rpb24nXG4gKiBpbXBvcnQgKiBhcyBCIGZyb20gJ2ZwLXRzL2Jvb2xlYW4nXG4gKlxuICogY29uc3QgZjogUHJlZGljYXRlPG51bWJlcj4gPSAobikgPT4gbiA8PSAyXG4gKiBjb25zdCBnOiBQcmVkaWNhdGU8bnVtYmVyPiA9IChuKSA9PiBuID49IDBcbiAqXG4gKiBjb25zdCBNMSA9IGdldE1vbm9pZChCLk1vbm9pZEFsbCk8bnVtYmVyPigpXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChNMS5jb25jYXQoZiwgZykoMSksIHRydWUpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE0xLmNvbmNhdChmLCBnKSgzKSwgZmFsc2UpXG4gKlxuICogY29uc3QgTTIgPSBnZXRNb25vaWQoQi5Nb25vaWRBbnkpPG51bWJlcj4oKVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoTTIuY29uY2F0KGYsIGcpKDEpLCB0cnVlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChNMi5jb25jYXQoZiwgZykoMyksIHRydWUpXG4gKlxuICogQGNhdGVnb3J5IGluc3RhbmNlc1xuICogQHNpbmNlIDIuMTAuMFxuICovXG5leHBvcnQgdmFyIGdldE1vbm9pZCA9IGZ1bmN0aW9uIChNKSB7XG4gICAgdmFyIGdldFNlbWlncm91cE0gPSBnZXRTZW1pZ3JvdXAoTSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgIGNvbmNhdDogZ2V0U2VtaWdyb3VwTSgpLmNvbmNhdCxcbiAgICAgICAgZW1wdHk6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE0uZW1wdHk7IH1cbiAgICB9KTsgfTtcbn07XG4vKipcbiAqIEBjYXRlZ29yeSBpbnN0YW5jZXNcbiAqIEBzaW5jZSAyLjEwLjBcbiAqL1xuZXhwb3J0IHZhciBnZXRTZW1pcmluZyA9IGZ1bmN0aW9uIChTKSB7IHJldHVybiAoe1xuICAgIGFkZDogZnVuY3Rpb24gKGYsIGcpIHsgcmV0dXJuIGZ1bmN0aW9uICh4KSB7IHJldHVybiBTLmFkZChmKHgpLCBnKHgpKTsgfTsgfSxcbiAgICB6ZXJvOiBmdW5jdGlvbiAoKSB7IHJldHVybiBTLnplcm87IH0sXG4gICAgbXVsOiBmdW5jdGlvbiAoZiwgZykgeyByZXR1cm4gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIFMubXVsKGYoeCksIGcoeCkpOyB9OyB9LFxuICAgIG9uZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gUy5vbmU7IH1cbn0pOyB9O1xuLyoqXG4gKiBAY2F0ZWdvcnkgaW5zdGFuY2VzXG4gKiBAc2luY2UgMi4xMC4wXG4gKi9cbmV4cG9ydCB2YXIgZ2V0UmluZyA9IGZ1bmN0aW9uIChSKSB7XG4gICAgdmFyIFMgPSBnZXRTZW1pcmluZyhSKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGQ6IFMuYWRkLFxuICAgICAgICBtdWw6IFMubXVsLFxuICAgICAgICBvbmU6IFMub25lLFxuICAgICAgICB6ZXJvOiBTLnplcm8sXG4gICAgICAgIHN1YjogZnVuY3Rpb24gKGYsIGcpIHsgcmV0dXJuIGZ1bmN0aW9uICh4KSB7IHJldHVybiBSLnN1YihmKHgpLCBnKHgpKTsgfTsgfVxuICAgIH07XG59O1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdXRpbHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogQHNpbmNlIDIuMTEuMFxuICovXG5leHBvcnQgdmFyIGFwcGx5ID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGYoYSk7XG4gICAgfTtcbn07XG4vKipcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkoYSkge1xuICAgIHJldHVybiBhO1xufVxuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IHZhciB1bnNhZmVDb2VyY2UgPSBpZGVudGl0eTtcbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25zdGFudChhKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGE7IH07XG59XG4vKipcbiAqIEEgdGh1bmsgdGhhdCByZXR1cm5zIGFsd2F5cyBgdHJ1ZWAuXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCB2YXIgY29uc3RUcnVlID0gLyojX19QVVJFX18qLyBjb25zdGFudCh0cnVlKTtcbi8qKlxuICogQSB0aHVuayB0aGF0IHJldHVybnMgYWx3YXlzIGBmYWxzZWAuXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCB2YXIgY29uc3RGYWxzZSA9IC8qI19fUFVSRV9fKi8gY29uc3RhbnQoZmFsc2UpO1xuLyoqXG4gKiBBIHRodW5rIHRoYXQgcmV0dXJucyBhbHdheXMgYG51bGxgLlxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnQgdmFyIGNvbnN0TnVsbCA9IC8qI19fUFVSRV9fKi8gY29uc3RhbnQobnVsbCk7XG4vKipcbiAqIEEgdGh1bmsgdGhhdCByZXR1cm5zIGFsd2F5cyBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IHZhciBjb25zdFVuZGVmaW5lZCA9IC8qI19fUFVSRV9fKi8gY29uc3RhbnQodW5kZWZpbmVkKTtcbi8qKlxuICogQSB0aHVuayB0aGF0IHJldHVybnMgYWx3YXlzIGB2b2lkYC5cbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IHZhciBjb25zdFZvaWQgPSBjb25zdFVuZGVmaW5lZDtcbmV4cG9ydCBmdW5jdGlvbiBmbGlwKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmKGFyZ3NbMV0sIGFyZ3NbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gZihhKShhcmdzWzBdKTsgfTtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZsb3coYWIsIGJjLCBjZCwgZGUsIGVmLCBmZywgZ2gsIGhpLCBpaikge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gYWI7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJjKGFiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2QoYmMoYWIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGUoY2QoYmMoYWIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVmKGRlKGNkKGJjKGFiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpKSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmcoZWYoZGUoY2QoYmMoYWIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkpKSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2goZmcoZWYoZGUoY2QoYmMoYWIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkpKSkpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhpKGdoKGZnKGVmKGRlKGNkKGJjKGFiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpKSkpKSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWooaGkoZ2goZmcoZWYoZGUoY2QoYmMoYWIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkpKSkpKSkpO1xuICAgICAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuO1xufVxuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlKCkge1xuICAgIHZhciB0ID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdFtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbn1cbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmNyZW1lbnQobikge1xuICAgIHJldHVybiBuICsgMTtcbn1cbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNyZW1lbnQobikge1xuICAgIHJldHVybiBuIC0gMTtcbn1cbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhYnN1cmQoXykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FsbGVkIGBhYnN1cmRgIGZ1bmN0aW9uIHdoaWNoIHNob3VsZCBiZSB1bmNhbGxhYmxlJyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSB0dXBsZWQgdmVyc2lvbiBvZiB0aGlzIGZ1bmN0aW9uOiBpbnN0ZWFkIG9mIGBuYCBhcmd1bWVudHMsIGl0IGFjY2VwdHMgYSBzaW5nbGUgdHVwbGUgYXJndW1lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IHR1cGxlZCB9IGZyb20gJ2ZwLXRzL2Z1bmN0aW9uJ1xuICpcbiAqIGNvbnN0IGFkZCA9IHR1cGxlZCgoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBudW1iZXIgPT4geCArIHkpXG4gKlxuICogYXNzZXJ0LnN0cmljdEVxdWFsKGFkZChbMSwgMl0pLCAzKVxuICpcbiAqIEBzaW5jZSAyLjQuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHVwbGVkKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGYuYXBwbHkodm9pZCAwLCBhKTsgfTtcbn1cbi8qKlxuICogSW52ZXJzZSBmdW5jdGlvbiBvZiBgdHVwbGVkYFxuICpcbiAqIEBzaW5jZSAyLjQuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gdW50dXBsZWQoZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGYoYSk7XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwaXBlKGEsIGFiLCBiYywgY2QsIGRlLCBlZiwgZmcsIGdoLCBoaSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIGFiKGEpO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gYmMoYWIoYSkpO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4gY2QoYmMoYWIoYSkpKTtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmV0dXJuIGRlKGNkKGJjKGFiKGEpKSkpO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXR1cm4gZWYoZGUoY2QoYmMoYWIoYSkpKSkpO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gZmcoZWYoZGUoY2QoYmMoYWIoYSkpKSkpKTtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcmV0dXJuIGdoKGZnKGVmKGRlKGNkKGJjKGFiKGEpKSkpKSkpO1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4gaGkoZ2goZmcoZWYoZGUoY2QoYmMoYWIoYSkpKSkpKSkpO1xuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXQgPSBhcmd1bWVudHNbaV0ocmV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFR5cGUgaG9sZSBzaW11bGF0aW9uXG4gKlxuICogQHNpbmNlIDIuNy4wXG4gKi9cbmV4cG9ydCB2YXIgaG9sZSA9IGFic3VyZDtcbi8qKlxuICogQHNpbmNlIDIuMTEuMFxuICovXG5leHBvcnQgdmFyIFNLID0gZnVuY3Rpb24gKF8sIGIpIHsgcmV0dXJuIGI7IH07XG4vKipcbiAqIFVzZSBgUHJlZGljYXRlYCBtb2R1bGUgaW5zdGVhZC5cbiAqXG4gKiBAY2F0ZWdvcnkgem9uZSBvZiBkZWF0aFxuICogQHNpbmNlIDIuMC4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gbm90KHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gIXByZWRpY2F0ZShhKTsgfTtcbn1cbi8qKlxuICogVXNlIGBFbmRvbW9ycGhpc21gIG1vZHVsZSBpbnN0ZWFkLlxuICpcbiAqIEBjYXRlZ29yeSB6b25lIG9mIGRlYXRoXG4gKiBAc2luY2UgMi4xMC4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnQgdmFyIGdldEVuZG9tb3JwaGlzbU1vbm9pZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgY29uY2F0OiBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkgeyByZXR1cm4gZmxvdyhmaXJzdCwgc2Vjb25kKTsgfSxcbiAgICBlbXB0eTogaWRlbnRpdHlcbn0pOyB9O1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IHZhciBkdWFsID0gZnVuY3Rpb24gKGFyaXR5LCBib2R5KSB7XG4gICAgdmFyIGlzRGF0YUZpcnN0ID0gdHlwZW9mIGFyaXR5ID09PSAnbnVtYmVyJyA/IGZ1bmN0aW9uIChhcmdzKSB7IHJldHVybiBhcmdzLmxlbmd0aCA+PSBhcml0eTsgfSA6IGFyaXR5O1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkuZnJvbShhcmd1bWVudHMpO1xuICAgICAgICBpZiAoaXNEYXRhRmlyc3QoYXJndW1lbnRzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGJvZHkuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzZWxmKSB7IHJldHVybiBib2R5LmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbc2VsZl0sIGFyZ3MsIGZhbHNlKSk7IH07XG4gICAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fp-ts/es6/function.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fp-ts/lib/Applicative.js":
/*!***********************************************!*\
  !*** ./node_modules/fp-ts/lib/Applicative.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getApplicativeMonoid = getApplicativeMonoid;\nexports.getApplicativeComposition = getApplicativeComposition;\n/**\n * The `Applicative` type class extends the `Apply` type class with a `of` function, which can be used to create values\n * of type `f a` from values of type `a`.\n *\n * Where `Apply` provides the ability to lift functions of two or more arguments to functions whose arguments are\n * wrapped using `f`, and `Functor` provides the ability to lift functions of one argument, `pure` can be seen as the\n * function which lifts functions of _zero_ arguments. That is, `Applicative` functors support a lifting operation for\n * any number of function arguments.\n *\n * Instances must satisfy the following laws in addition to the `Apply` laws:\n *\n * 1. Identity: `A.ap(A.of(a => a), fa) <-> fa`\n * 2. Homomorphism: `A.ap(A.of(ab), A.of(a)) <-> A.of(ab(a))`\n * 3. Interchange: `A.ap(fab, A.of(a)) <-> A.ap(A.of(ab => ab(a)), fab)`\n *\n * Note. `Functor`'s `map` can be derived: `A.map(x, f) = A.ap(A.of(f), x)`\n *\n * @since 2.0.0\n */\nvar Apply_1 = __webpack_require__(/*! ./Apply */ \"(app-pages-browser)/./node_modules/fp-ts/lib/Apply.js\");\nvar function_1 = __webpack_require__(/*! ./function */ \"(app-pages-browser)/./node_modules/fp-ts/lib/function.js\");\nvar Functor_1 = __webpack_require__(/*! ./Functor */ \"(app-pages-browser)/./node_modules/fp-ts/lib/Functor.js\");\nfunction getApplicativeMonoid(F) {\n    var f = (0, Apply_1.getApplySemigroup)(F);\n    return function (M) { return ({\n        concat: f(M).concat,\n        empty: F.of(M.empty)\n    }); };\n}\n/** @deprecated */\nfunction getApplicativeComposition(F, G) {\n    var map = (0, Functor_1.getFunctorComposition)(F, G).map;\n    var _ap = (0, Apply_1.ap)(F, G);\n    return {\n        map: map,\n        of: function (a) { return F.of(G.of(a)); },\n        ap: function (fgab, fga) { return (0, function_1.pipe)(fgab, _ap(fga)); }\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcC10cy9saWIvQXBwbGljYXRpdmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCO0FBQzVCLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxzRUFBUztBQUMvQixpQkFBaUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBVztBQUNuQztBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xELG1DQUFtQztBQUNuQztBQUNBIiwic291cmNlcyI6WyJJOlxcU2NhbGFDdXJzb3ZheWFcXEJ1bmtlcldlYlxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcZnAtdHNcXGxpYlxcQXBwbGljYXRpdmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEFwcGxpY2F0aXZlTW9ub2lkID0gZ2V0QXBwbGljYXRpdmVNb25vaWQ7XG5leHBvcnRzLmdldEFwcGxpY2F0aXZlQ29tcG9zaXRpb24gPSBnZXRBcHBsaWNhdGl2ZUNvbXBvc2l0aW9uO1xuLyoqXG4gKiBUaGUgYEFwcGxpY2F0aXZlYCB0eXBlIGNsYXNzIGV4dGVuZHMgdGhlIGBBcHBseWAgdHlwZSBjbGFzcyB3aXRoIGEgYG9mYCBmdW5jdGlvbiwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gY3JlYXRlIHZhbHVlc1xuICogb2YgdHlwZSBgZiBhYCBmcm9tIHZhbHVlcyBvZiB0eXBlIGBhYC5cbiAqXG4gKiBXaGVyZSBgQXBwbHlgIHByb3ZpZGVzIHRoZSBhYmlsaXR5IHRvIGxpZnQgZnVuY3Rpb25zIG9mIHR3byBvciBtb3JlIGFyZ3VtZW50cyB0byBmdW5jdGlvbnMgd2hvc2UgYXJndW1lbnRzIGFyZVxuICogd3JhcHBlZCB1c2luZyBgZmAsIGFuZCBgRnVuY3RvcmAgcHJvdmlkZXMgdGhlIGFiaWxpdHkgdG8gbGlmdCBmdW5jdGlvbnMgb2Ygb25lIGFyZ3VtZW50LCBgcHVyZWAgY2FuIGJlIHNlZW4gYXMgdGhlXG4gKiBmdW5jdGlvbiB3aGljaCBsaWZ0cyBmdW5jdGlvbnMgb2YgX3plcm9fIGFyZ3VtZW50cy4gVGhhdCBpcywgYEFwcGxpY2F0aXZlYCBmdW5jdG9ycyBzdXBwb3J0IGEgbGlmdGluZyBvcGVyYXRpb24gZm9yXG4gKiBhbnkgbnVtYmVyIG9mIGZ1bmN0aW9uIGFyZ3VtZW50cy5cbiAqXG4gKiBJbnN0YW5jZXMgbXVzdCBzYXRpc2Z5IHRoZSBmb2xsb3dpbmcgbGF3cyBpbiBhZGRpdGlvbiB0byB0aGUgYEFwcGx5YCBsYXdzOlxuICpcbiAqIDEuIElkZW50aXR5OiBgQS5hcChBLm9mKGEgPT4gYSksIGZhKSA8LT4gZmFgXG4gKiAyLiBIb21vbW9ycGhpc206IGBBLmFwKEEub2YoYWIpLCBBLm9mKGEpKSA8LT4gQS5vZihhYihhKSlgXG4gKiAzLiBJbnRlcmNoYW5nZTogYEEuYXAoZmFiLCBBLm9mKGEpKSA8LT4gQS5hcChBLm9mKGFiID0+IGFiKGEpKSwgZmFiKWBcbiAqXG4gKiBOb3RlLiBgRnVuY3RvcmAncyBgbWFwYCBjYW4gYmUgZGVyaXZlZDogYEEubWFwKHgsIGYpID0gQS5hcChBLm9mKGYpLCB4KWBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xudmFyIEFwcGx5XzEgPSByZXF1aXJlKFwiLi9BcHBseVwiKTtcbnZhciBmdW5jdGlvbl8xID0gcmVxdWlyZShcIi4vZnVuY3Rpb25cIik7XG52YXIgRnVuY3Rvcl8xID0gcmVxdWlyZShcIi4vRnVuY3RvclwiKTtcbmZ1bmN0aW9uIGdldEFwcGxpY2F0aXZlTW9ub2lkKEYpIHtcbiAgICB2YXIgZiA9ICgwLCBBcHBseV8xLmdldEFwcGx5U2VtaWdyb3VwKShGKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKE0pIHsgcmV0dXJuICh7XG4gICAgICAgIGNvbmNhdDogZihNKS5jb25jYXQsXG4gICAgICAgIGVtcHR5OiBGLm9mKE0uZW1wdHkpXG4gICAgfSk7IH07XG59XG4vKiogQGRlcHJlY2F0ZWQgKi9cbmZ1bmN0aW9uIGdldEFwcGxpY2F0aXZlQ29tcG9zaXRpb24oRiwgRykge1xuICAgIHZhciBtYXAgPSAoMCwgRnVuY3Rvcl8xLmdldEZ1bmN0b3JDb21wb3NpdGlvbikoRiwgRykubWFwO1xuICAgIHZhciBfYXAgPSAoMCwgQXBwbHlfMS5hcCkoRiwgRyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWFwOiBtYXAsXG4gICAgICAgIG9mOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gRi5vZihHLm9mKGEpKTsgfSxcbiAgICAgICAgYXA6IGZ1bmN0aW9uIChmZ2FiLCBmZ2EpIHsgcmV0dXJuICgwLCBmdW5jdGlvbl8xLnBpcGUpKGZnYWIsIF9hcChmZ2EpKTsgfVxuICAgIH07XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fp-ts/lib/Applicative.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fp-ts/lib/Apply.js":
/*!*****************************************!*\
  !*** ./node_modules/fp-ts/lib/Apply.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ap = ap;\nexports.apFirst = apFirst;\nexports.apSecond = apSecond;\nexports.apS = apS;\nexports.getApplySemigroup = getApplySemigroup;\nexports.sequenceT = sequenceT;\nexports.sequenceS = sequenceS;\n/**\n * The `Apply` class provides the `ap` which is used to apply a function to an argument under a type constructor.\n *\n * `Apply` can be used to lift functions of two or more arguments to work on values wrapped with the type constructor\n * `f`.\n *\n * Instances must satisfy the following law in addition to the `Functor` laws:\n *\n * 1. Associative composition: `F.ap(F.ap(F.map(fbc, bc => ab => a => bc(ab(a))), fab), fa) <-> F.ap(fbc, F.ap(fab, fa))`\n *\n * Formally, `Apply` represents a strong lax semi-monoidal endofunctor.\n *\n * @example\n * import * as O from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * const f = (a: string) => (b: number) => (c: boolean) => a + String(b) + String(c)\n * const fa: O.Option<string> = O.some('s')\n * const fb: O.Option<number> = O.some(1)\n * const fc: O.Option<boolean> = O.some(true)\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     // lift a function\n *     O.some(f),\n *     // apply the first argument\n *     O.ap(fa),\n *     // apply the second argument\n *     O.ap(fb),\n *     // apply the third argument\n *     O.ap(fc)\n *   ),\n *   O.some('s1true')\n * )\n *\n * @since 2.0.0\n */\nvar function_1 = __webpack_require__(/*! ./function */ \"(app-pages-browser)/./node_modules/fp-ts/lib/function.js\");\nvar _ = __importStar(__webpack_require__(/*! ./internal */ \"(app-pages-browser)/./node_modules/fp-ts/lib/internal.js\"));\nfunction ap(F, G) {\n    return function (fa) {\n        return function (fab) {\n            return F.ap(F.map(fab, function (gab) { return function (ga) { return G.ap(gab, ga); }; }), fa);\n        };\n    };\n}\nfunction apFirst(A) {\n    return function (second) { return function (first) {\n        return A.ap(A.map(first, function (a) { return function () { return a; }; }), second);\n    }; };\n}\nfunction apSecond(A) {\n    return function (second) {\n        return function (first) {\n            return A.ap(A.map(first, function () { return function (b) { return b; }; }), second);\n        };\n    };\n}\nfunction apS(F) {\n    return function (name, fb) {\n        return function (fa) {\n            return F.ap(F.map(fa, function (a) { return function (b) {\n                var _a;\n                return Object.assign({}, a, (_a = {}, _a[name] = b, _a));\n            }; }), fb);\n        };\n    };\n}\nfunction getApplySemigroup(F) {\n    return function (S) { return ({\n        concat: function (first, second) {\n            return F.ap(F.map(first, function (x) { return function (y) { return S.concat(x, y); }; }), second);\n        }\n    }); };\n}\nfunction curried(f, n, acc) {\n    return function (x) {\n        var combined = Array(acc.length + 1);\n        for (var i = 0; i < acc.length; i++) {\n            combined[i] = acc[i];\n        }\n        combined[acc.length] = x;\n        return n === 0 ? f.apply(null, combined) : curried(f, n - 1, combined);\n    };\n}\nvar tupleConstructors = {\n    1: function (a) { return [a]; },\n    2: function (a) { return function (b) { return [a, b]; }; },\n    3: function (a) { return function (b) { return function (c) { return [a, b, c]; }; }; },\n    4: function (a) { return function (b) { return function (c) { return function (d) { return [a, b, c, d]; }; }; }; },\n    5: function (a) { return function (b) { return function (c) { return function (d) { return function (e) { return [a, b, c, d, e]; }; }; }; }; }\n};\nfunction getTupleConstructor(len) {\n    if (!_.has.call(tupleConstructors, len)) {\n        tupleConstructors[len] = curried(function_1.tuple, len - 1, []);\n    }\n    return tupleConstructors[len];\n}\nfunction sequenceT(F) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var len = args.length;\n        var f = getTupleConstructor(len);\n        var fas = F.map(args[0], f);\n        for (var i = 1; i < len; i++) {\n            fas = F.ap(fas, args[i]);\n        }\n        return fas;\n    };\n}\nfunction getRecordConstructor(keys) {\n    var len = keys.length;\n    switch (len) {\n        case 1:\n            return function (a) {\n                var _a;\n                return (_a = {}, _a[keys[0]] = a, _a);\n            };\n        case 2:\n            return function (a) { return function (b) {\n                var _a;\n                return (_a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a);\n            }; };\n        case 3:\n            return function (a) { return function (b) { return function (c) {\n                var _a;\n                return (_a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a[keys[2]] = c, _a);\n            }; }; };\n        case 4:\n            return function (a) { return function (b) { return function (c) { return function (d) {\n                var _a;\n                return (_a = {},\n                    _a[keys[0]] = a,\n                    _a[keys[1]] = b,\n                    _a[keys[2]] = c,\n                    _a[keys[3]] = d,\n                    _a);\n            }; }; }; };\n        case 5:\n            return function (a) { return function (b) { return function (c) { return function (d) { return function (e) {\n                var _a;\n                return (_a = {},\n                    _a[keys[0]] = a,\n                    _a[keys[1]] = b,\n                    _a[keys[2]] = c,\n                    _a[keys[3]] = d,\n                    _a[keys[4]] = e,\n                    _a);\n            }; }; }; }; };\n        default:\n            return curried(function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var r = {};\n                for (var i = 0; i < len; i++) {\n                    r[keys[i]] = args[i];\n                }\n                return r;\n            }, len - 1, []);\n    }\n}\nfunction sequenceS(F) {\n    return function (r) {\n        var keys = Object.keys(r);\n        var len = keys.length;\n        var f = getRecordConstructor(keys);\n        var fr = F.map(r[keys[0]], f);\n        for (var i = 1; i < len; i++) {\n            fr = F.ap(fr, r[keys[i]]);\n        }\n        return fr;\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcC10cy9saWIvQXBwbHkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFVBQVU7QUFDVixlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCLFdBQVc7QUFDWCx5QkFBeUI7QUFDekIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsNEVBQVk7QUFDckMscUJBQXFCLG1CQUFPLENBQUMsNEVBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHVCQUF1QiwwQkFBMEI7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsZ0RBQWdELHFCQUFxQixjQUFjO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsc0JBQXNCLGNBQWM7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0EsdUNBQXVDLGFBQWE7QUFDcEQsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0Esb0RBQW9ELHNCQUFzQiwyQkFBMkI7QUFDckc7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkMsc0JBQXNCLHNCQUFzQixtQkFBbUI7QUFDL0Qsc0JBQXNCLHNCQUFzQixzQkFBc0IseUJBQXlCO0FBQzNGLHNCQUFzQixzQkFBc0Isc0JBQXNCLHNCQUFzQiwrQkFBK0I7QUFDdkgsc0JBQXNCLHNCQUFzQixzQkFBc0Isc0JBQXNCLHNCQUFzQjtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0Esa0NBQWtDLHNCQUFzQjtBQUN4RDtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0Esa0NBQWtDLHNCQUFzQixzQkFBc0I7QUFDOUU7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msc0JBQXNCLHNCQUFzQixzQkFBc0I7QUFDcEc7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUJBQXVCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiSTpcXFNjYWxhQ3Vyc292YXlhXFxCdW5rZXJXZWJcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXGZwLXRzXFxsaWJcXEFwcGx5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFwID0gYXA7XG5leHBvcnRzLmFwRmlyc3QgPSBhcEZpcnN0O1xuZXhwb3J0cy5hcFNlY29uZCA9IGFwU2Vjb25kO1xuZXhwb3J0cy5hcFMgPSBhcFM7XG5leHBvcnRzLmdldEFwcGx5U2VtaWdyb3VwID0gZ2V0QXBwbHlTZW1pZ3JvdXA7XG5leHBvcnRzLnNlcXVlbmNlVCA9IHNlcXVlbmNlVDtcbmV4cG9ydHMuc2VxdWVuY2VTID0gc2VxdWVuY2VTO1xuLyoqXG4gKiBUaGUgYEFwcGx5YCBjbGFzcyBwcm92aWRlcyB0aGUgYGFwYCB3aGljaCBpcyB1c2VkIHRvIGFwcGx5IGEgZnVuY3Rpb24gdG8gYW4gYXJndW1lbnQgdW5kZXIgYSB0eXBlIGNvbnN0cnVjdG9yLlxuICpcbiAqIGBBcHBseWAgY2FuIGJlIHVzZWQgdG8gbGlmdCBmdW5jdGlvbnMgb2YgdHdvIG9yIG1vcmUgYXJndW1lbnRzIHRvIHdvcmsgb24gdmFsdWVzIHdyYXBwZWQgd2l0aCB0aGUgdHlwZSBjb25zdHJ1Y3RvclxuICogYGZgLlxuICpcbiAqIEluc3RhbmNlcyBtdXN0IHNhdGlzZnkgdGhlIGZvbGxvd2luZyBsYXcgaW4gYWRkaXRpb24gdG8gdGhlIGBGdW5jdG9yYCBsYXdzOlxuICpcbiAqIDEuIEFzc29jaWF0aXZlIGNvbXBvc2l0aW9uOiBgRi5hcChGLmFwKEYubWFwKGZiYywgYmMgPT4gYWIgPT4gYSA9PiBiYyhhYihhKSkpLCBmYWIpLCBmYSkgPC0+IEYuYXAoZmJjLCBGLmFwKGZhYiwgZmEpKWBcbiAqXG4gKiBGb3JtYWxseSwgYEFwcGx5YCByZXByZXNlbnRzIGEgc3Ryb25nIGxheCBzZW1pLW1vbm9pZGFsIGVuZG9mdW5jdG9yLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBPIGZyb20gJ2ZwLXRzL09wdGlvbidcbiAqIGltcG9ydCB7IHBpcGUgfSBmcm9tICdmcC10cy9mdW5jdGlvbidcbiAqXG4gKiBjb25zdCBmID0gKGE6IHN0cmluZykgPT4gKGI6IG51bWJlcikgPT4gKGM6IGJvb2xlYW4pID0+IGEgKyBTdHJpbmcoYikgKyBTdHJpbmcoYylcbiAqIGNvbnN0IGZhOiBPLk9wdGlvbjxzdHJpbmc+ID0gTy5zb21lKCdzJylcbiAqIGNvbnN0IGZiOiBPLk9wdGlvbjxudW1iZXI+ID0gTy5zb21lKDEpXG4gKiBjb25zdCBmYzogTy5PcHRpb248Ym9vbGVhbj4gPSBPLnNvbWUodHJ1ZSlcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogICBwaXBlKFxuICogICAgIC8vIGxpZnQgYSBmdW5jdGlvblxuICogICAgIE8uc29tZShmKSxcbiAqICAgICAvLyBhcHBseSB0aGUgZmlyc3QgYXJndW1lbnRcbiAqICAgICBPLmFwKGZhKSxcbiAqICAgICAvLyBhcHBseSB0aGUgc2Vjb25kIGFyZ3VtZW50XG4gKiAgICAgTy5hcChmYiksXG4gKiAgICAgLy8gYXBwbHkgdGhlIHRoaXJkIGFyZ3VtZW50XG4gKiAgICAgTy5hcChmYylcbiAqICAgKSxcbiAqICAgTy5zb21lKCdzMXRydWUnKVxuICogKVxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG52YXIgZnVuY3Rpb25fMSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9uXCIpO1xudmFyIF8gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vaW50ZXJuYWxcIikpO1xuZnVuY3Rpb24gYXAoRiwgRykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZmEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmYWIpIHtcbiAgICAgICAgICAgIHJldHVybiBGLmFwKEYubWFwKGZhYiwgZnVuY3Rpb24gKGdhYikgeyByZXR1cm4gZnVuY3Rpb24gKGdhKSB7IHJldHVybiBHLmFwKGdhYiwgZ2EpOyB9OyB9KSwgZmEpO1xuICAgICAgICB9O1xuICAgIH07XG59XG5mdW5jdGlvbiBhcEZpcnN0KEEpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNlY29uZCkgeyByZXR1cm4gZnVuY3Rpb24gKGZpcnN0KSB7XG4gICAgICAgIHJldHVybiBBLmFwKEEubWFwKGZpcnN0LCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gYTsgfTsgfSksIHNlY29uZCk7XG4gICAgfTsgfTtcbn1cbmZ1bmN0aW9uIGFwU2Vjb25kKEEpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNlY29uZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZpcnN0KSB7XG4gICAgICAgICAgICByZXR1cm4gQS5hcChBLm1hcChmaXJzdCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGI7IH07IH0pLCBzZWNvbmQpO1xuICAgICAgICB9O1xuICAgIH07XG59XG5mdW5jdGlvbiBhcFMoRikge1xuICAgIHJldHVybiBmdW5jdGlvbiAobmFtZSwgZmIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmYSkge1xuICAgICAgICAgICAgcmV0dXJuIEYuYXAoRi5tYXAoZmEsIGZ1bmN0aW9uIChhKSB7IHJldHVybiBmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgYSwgKF9hID0ge30sIF9hW25hbWVdID0gYiwgX2EpKTtcbiAgICAgICAgICAgIH07IH0pLCBmYik7XG4gICAgICAgIH07XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEFwcGx5U2VtaWdyb3VwKEYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKFMpIHsgcmV0dXJuICh7XG4gICAgICAgIGNvbmNhdDogZnVuY3Rpb24gKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBGLmFwKEYubWFwKGZpcnN0LCBmdW5jdGlvbiAoeCkgeyByZXR1cm4gZnVuY3Rpb24gKHkpIHsgcmV0dXJuIFMuY29uY2F0KHgsIHkpOyB9OyB9KSwgc2Vjb25kKTtcbiAgICAgICAgfVxuICAgIH0pOyB9O1xufVxuZnVuY3Rpb24gY3VycmllZChmLCBuLCBhY2MpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIGNvbWJpbmVkID0gQXJyYXkoYWNjLmxlbmd0aCArIDEpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjYy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29tYmluZWRbaV0gPSBhY2NbaV07XG4gICAgICAgIH1cbiAgICAgICAgY29tYmluZWRbYWNjLmxlbmd0aF0gPSB4O1xuICAgICAgICByZXR1cm4gbiA9PT0gMCA/IGYuYXBwbHkobnVsbCwgY29tYmluZWQpIDogY3VycmllZChmLCBuIC0gMSwgY29tYmluZWQpO1xuICAgIH07XG59XG52YXIgdHVwbGVDb25zdHJ1Y3RvcnMgPSB7XG4gICAgMTogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIFthXTsgfSxcbiAgICAyOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gZnVuY3Rpb24gKGIpIHsgcmV0dXJuIFthLCBiXTsgfTsgfSxcbiAgICAzOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGZ1bmN0aW9uIChjKSB7IHJldHVybiBbYSwgYiwgY107IH07IH07IH0sXG4gICAgNDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGZ1bmN0aW9uIChiKSB7IHJldHVybiBmdW5jdGlvbiAoYykgeyByZXR1cm4gZnVuY3Rpb24gKGQpIHsgcmV0dXJuIFthLCBiLCBjLCBkXTsgfTsgfTsgfTsgfSxcbiAgICA1OiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGZ1bmN0aW9uIChjKSB7IHJldHVybiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIFthLCBiLCBjLCBkLCBlXTsgfTsgfTsgfTsgfTsgfVxufTtcbmZ1bmN0aW9uIGdldFR1cGxlQ29uc3RydWN0b3IobGVuKSB7XG4gICAgaWYgKCFfLmhhcy5jYWxsKHR1cGxlQ29uc3RydWN0b3JzLCBsZW4pKSB7XG4gICAgICAgIHR1cGxlQ29uc3RydWN0b3JzW2xlbl0gPSBjdXJyaWVkKGZ1bmN0aW9uXzEudHVwbGUsIGxlbiAtIDEsIFtdKTtcbiAgICB9XG4gICAgcmV0dXJuIHR1cGxlQ29uc3RydWN0b3JzW2xlbl07XG59XG5mdW5jdGlvbiBzZXF1ZW5jZVQoRikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICB2YXIgZiA9IGdldFR1cGxlQ29uc3RydWN0b3IobGVuKTtcbiAgICAgICAgdmFyIGZhcyA9IEYubWFwKGFyZ3NbMF0sIGYpO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBmYXMgPSBGLmFwKGZhcywgYXJnc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhcztcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0UmVjb3JkQ29uc3RydWN0b3Ioa2V5cykge1xuICAgIHZhciBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChfYSA9IHt9LCBfYVtrZXlzWzBdXSA9IGEsIF9hKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChfYSA9IHt9LCBfYVtrZXlzWzBdXSA9IGEsIF9hW2tleXNbMV1dID0gYiwgX2EpO1xuICAgICAgICAgICAgfTsgfTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7IHJldHVybiBmdW5jdGlvbiAoYikgeyByZXR1cm4gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChfYSA9IHt9LCBfYVtrZXlzWzBdXSA9IGEsIF9hW2tleXNbMV1dID0gYiwgX2Fba2V5c1syXV0gPSBjLCBfYSk7XG4gICAgICAgICAgICB9OyB9OyB9O1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGZ1bmN0aW9uIChiKSB7IHJldHVybiBmdW5jdGlvbiAoYykgeyByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChfYSA9IHt9LFxuICAgICAgICAgICAgICAgICAgICBfYVtrZXlzWzBdXSA9IGEsXG4gICAgICAgICAgICAgICAgICAgIF9hW2tleXNbMV1dID0gYixcbiAgICAgICAgICAgICAgICAgICAgX2Fba2V5c1syXV0gPSBjLFxuICAgICAgICAgICAgICAgICAgICBfYVtrZXlzWzNdXSA9IGQsXG4gICAgICAgICAgICAgICAgICAgIF9hKTtcbiAgICAgICAgICAgIH07IH07IH07IH07XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGZ1bmN0aW9uIChjKSB7IHJldHVybiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChfYSA9IHt9LFxuICAgICAgICAgICAgICAgICAgICBfYVtrZXlzWzBdXSA9IGEsXG4gICAgICAgICAgICAgICAgICAgIF9hW2tleXNbMV1dID0gYixcbiAgICAgICAgICAgICAgICAgICAgX2Fba2V5c1syXV0gPSBjLFxuICAgICAgICAgICAgICAgICAgICBfYVtrZXlzWzNdXSA9IGQsXG4gICAgICAgICAgICAgICAgICAgIF9hW2tleXNbNF1dID0gZSxcbiAgICAgICAgICAgICAgICAgICAgX2EpO1xuICAgICAgICAgICAgfTsgfTsgfTsgfTsgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjdXJyaWVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHIgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJba2V5c1tpXV0gPSBhcmdzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgIH0sIGxlbiAtIDEsIFtdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXF1ZW5jZVMoRikge1xuICAgIHJldHVybiBmdW5jdGlvbiAocikge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHIpO1xuICAgICAgICB2YXIgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIHZhciBmID0gZ2V0UmVjb3JkQ29uc3RydWN0b3Ioa2V5cyk7XG4gICAgICAgIHZhciBmciA9IEYubWFwKHJba2V5c1swXV0sIGYpO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBmciA9IEYuYXAoZnIsIHJba2V5c1tpXV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcjtcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fp-ts/lib/Apply.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fp-ts/lib/Chain.js":
/*!*****************************************!*\
  !*** ./node_modules/fp-ts/lib/Chain.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.chainFirst = chainFirst;\nexports.tap = tap;\nexports.bind = bind;\nfunction chainFirst(M) {\n    var tapM = tap(M);\n    return function (f) { return function (first) { return tapM(first, f); }; };\n}\n/** @internal */\nfunction tap(M) {\n    return function (first, f) { return M.chain(first, function (a) { return M.map(f(a), function () { return a; }); }); };\n}\nfunction bind(M) {\n    return function (name, f) { return function (ma) { return M.chain(ma, function (a) { return M.map(f(a), function (b) {\n        var _a;\n        return Object.assign({}, a, (_a = {}, _a[name] = b, _a));\n    }); }); }; };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcC10cy9saWIvQ2hhaW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLFdBQVc7QUFDWCxZQUFZO0FBQ1o7QUFDQTtBQUNBLDBCQUEwQiwwQkFBMEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFDQUFxQyxpQ0FBaUMsV0FBVyxJQUFJO0FBQ3RIO0FBQ0E7QUFDQSxnQ0FBZ0MsdUJBQXVCLGtDQUFrQztBQUN6RjtBQUNBLCtCQUErQixhQUFhO0FBQzVDLEtBQUssSUFBSTtBQUNUIiwic291cmNlcyI6WyJJOlxcU2NhbGFDdXJzb3ZheWFcXEJ1bmtlcldlYlxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcZnAtdHNcXGxpYlxcQ2hhaW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNoYWluRmlyc3QgPSBjaGFpbkZpcnN0O1xuZXhwb3J0cy50YXAgPSB0YXA7XG5leHBvcnRzLmJpbmQgPSBiaW5kO1xuZnVuY3Rpb24gY2hhaW5GaXJzdChNKSB7XG4gICAgdmFyIHRhcE0gPSB0YXAoTSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiBmdW5jdGlvbiAoZmlyc3QpIHsgcmV0dXJuIHRhcE0oZmlyc3QsIGYpOyB9OyB9O1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gdGFwKE0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGZpcnN0LCBmKSB7IHJldHVybiBNLmNoYWluKGZpcnN0LCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gTS5tYXAoZihhKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gYTsgfSk7IH0pOyB9O1xufVxuZnVuY3Rpb24gYmluZChNKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lLCBmKSB7IHJldHVybiBmdW5jdGlvbiAobWEpIHsgcmV0dXJuIE0uY2hhaW4obWEsIGZ1bmN0aW9uIChhKSB7IHJldHVybiBNLm1hcChmKGEpLCBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBhLCAoX2EgPSB7fSwgX2FbbmFtZV0gPSBiLCBfYSkpO1xuICAgIH0pOyB9KTsgfTsgfTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fp-ts/lib/Chain.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fp-ts/lib/Eq.js":
/*!**************************************!*\
  !*** ./node_modules/fp-ts/lib/Eq.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.eqDate = exports.eqNumber = exports.eqString = exports.eqBoolean = exports.eq = exports.strictEqual = exports.getStructEq = exports.getTupleEq = exports.Contravariant = exports.getMonoid = exports.getSemigroup = exports.eqStrict = exports.URI = exports.contramap = exports.tuple = exports.struct = exports.fromEquals = void 0;\nvar function_1 = __webpack_require__(/*! ./function */ \"(app-pages-browser)/./node_modules/fp-ts/lib/function.js\");\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.0.0\n */\nvar fromEquals = function (equals) { return ({\n    equals: function (x, y) { return x === y || equals(x, y); }\n}); };\nexports.fromEquals = fromEquals;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.10.0\n */\nvar struct = function (eqs) {\n    return (0, exports.fromEquals)(function (first, second) {\n        for (var key in eqs) {\n            if (!eqs[key].equals(first[key], second[key])) {\n                return false;\n            }\n        }\n        return true;\n    });\n};\nexports.struct = struct;\n/**\n * Given a tuple of `Eq`s returns a `Eq` for the tuple\n *\n * @example\n * import { tuple } from 'fp-ts/Eq'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import * as B from 'fp-ts/boolean'\n *\n * const E = tuple(S.Eq, N.Eq, B.Eq)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, true]), true)\n * assert.strictEqual(E.equals(['a', 1, true], ['b', 1, true]), false)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 2, true]), false)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, false]), false)\n *\n * @since 2.10.0\n */\nvar tuple = function () {\n    var eqs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        eqs[_i] = arguments[_i];\n    }\n    return (0, exports.fromEquals)(function (first, second) { return eqs.every(function (E, i) { return E.equals(first[i], second[i]); }); });\n};\nexports.tuple = tuple;\n/* istanbul ignore next */\nvar contramap_ = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.contramap)(f)); };\n/**\n * A typical use case for `contramap` would be like, given some `User` type, to construct an `Eq<User>`.\n *\n * We can do so with a function from `User -> X` where `X` is some value that we know how to compare\n * for equality (meaning we have an `Eq<X>`)\n *\n * For example, given the following `User` type, we want to construct an `Eq<User>` that just looks at the `key` field\n * for each user (since it's known to be unique).\n *\n * If we have a way of comparing `UUID`s for equality (`eqUUID: Eq<UUID>`) and we know how to go from `User -> UUID`,\n * using `contramap` we can do this\n *\n * @example\n * import { contramap, Eq } from 'fp-ts/Eq'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/string'\n *\n * type UUID = string\n *\n * interface User {\n *   readonly key: UUID\n *   readonly firstName: string\n *   readonly lastName: string\n * }\n *\n * const eqUUID: Eq<UUID> = S.Eq\n *\n * const eqUserByKey: Eq<User> = pipe(\n *   eqUUID,\n *   contramap((user) => user.key)\n * )\n *\n * assert.deepStrictEqual(\n *   eqUserByKey.equals(\n *     { key: 'k1', firstName: 'a1', lastName: 'b1' },\n *     { key: 'k2', firstName: 'a1', lastName: 'b1' }\n *   ),\n *   false\n * )\n * assert.deepStrictEqual(\n *   eqUserByKey.equals(\n *     { key: 'k1', firstName: 'a1', lastName: 'b1' },\n *     { key: 'k1', firstName: 'a2', lastName: 'b1' }\n *   ),\n *   true\n * )\n *\n * @since 2.0.0\n */\nvar contramap = function (f) { return function (fa) {\n    return (0, exports.fromEquals)(function (x, y) { return fa.equals(f(x), f(y)); });\n}; };\nexports.contramap = contramap;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexports.URI = 'Eq';\n/**\n * @category instances\n * @since 2.5.0\n */\nexports.eqStrict = {\n    equals: function (a, b) { return a === b; }\n};\nvar empty = {\n    equals: function () { return true; }\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nvar getSemigroup = function () { return ({\n    concat: function (x, y) { return (0, exports.fromEquals)(function (a, b) { return x.equals(a, b) && y.equals(a, b); }); }\n}); };\nexports.getSemigroup = getSemigroup;\n/**\n * @category instances\n * @since 2.6.0\n */\nvar getMonoid = function () { return ({\n    concat: (0, exports.getSemigroup)().concat,\n    empty: empty\n}); };\nexports.getMonoid = getMonoid;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Contravariant = {\n    URI: exports.URI,\n    contramap: contramap_\n};\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use [`tuple`](#tuple) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getTupleEq = exports.tuple;\n/**\n * Use [`struct`](#struct) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getStructEq = exports.struct;\n/**\n * Use [`eqStrict`](#eqstrict) instead\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.strictEqual = exports.eqStrict.equals;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Contravariant` instance, pass `E.Contravariant` instead of `E.eq`\n * (where `E` is from `import E from 'fp-ts/Eq'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.eq = exports.Contravariant;\n/**\n * Use [`Eq`](./boolean.ts.html#eq) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.eqBoolean = exports.eqStrict;\n/**\n * Use [`Eq`](./string.ts.html#eq) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.eqString = exports.eqStrict;\n/**\n * Use [`Eq`](./number.ts.html#eq) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.eqNumber = exports.eqStrict;\n/**\n * Use [`Eq`](./Date.ts.html#eq) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.eqDate = {\n    equals: function (first, second) { return first.valueOf() === second.valueOf(); }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcC10cy9saWIvRXEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLGlCQUFpQixHQUFHLFVBQVUsR0FBRyxtQkFBbUIsR0FBRyxtQkFBbUIsR0FBRyxrQkFBa0IsR0FBRyxxQkFBcUIsR0FBRyxpQkFBaUIsR0FBRyxvQkFBb0IsR0FBRyxnQkFBZ0IsR0FBRyxXQUFXLEdBQUcsaUJBQWlCLEdBQUcsYUFBYSxHQUFHLGNBQWMsR0FBRyxrQkFBa0I7QUFDcFUsaUJBQWlCLG1CQUFPLENBQUMsNEVBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsOEJBQThCO0FBQzlCLENBQUM7QUFDRCxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0EsOERBQThELG1DQUFtQyx1Q0FBdUMsSUFBSTtBQUM1STtBQUNBLGFBQWE7QUFDYjtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNENBQTRDO0FBQ3JELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw0Q0FBNEM7QUFDckQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixxREFBcUQsK0JBQStCO0FBQ3BGO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsOEJBQThCLGlEQUFpRCwwQ0FBMEM7QUFDekgsQ0FBQztBQUNELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsQ0FBQztBQUNELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsdUNBQXVDO0FBQ3ZDIiwic291cmNlcyI6WyJJOlxcU2NhbGFDdXJzb3ZheWFcXEJ1bmtlcldlYlxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcZnAtdHNcXGxpYlxcRXEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVxRGF0ZSA9IGV4cG9ydHMuZXFOdW1iZXIgPSBleHBvcnRzLmVxU3RyaW5nID0gZXhwb3J0cy5lcUJvb2xlYW4gPSBleHBvcnRzLmVxID0gZXhwb3J0cy5zdHJpY3RFcXVhbCA9IGV4cG9ydHMuZ2V0U3RydWN0RXEgPSBleHBvcnRzLmdldFR1cGxlRXEgPSBleHBvcnRzLkNvbnRyYXZhcmlhbnQgPSBleHBvcnRzLmdldE1vbm9pZCA9IGV4cG9ydHMuZ2V0U2VtaWdyb3VwID0gZXhwb3J0cy5lcVN0cmljdCA9IGV4cG9ydHMuVVJJID0gZXhwb3J0cy5jb250cmFtYXAgPSBleHBvcnRzLnR1cGxlID0gZXhwb3J0cy5zdHJ1Y3QgPSBleHBvcnRzLmZyb21FcXVhbHMgPSB2b2lkIDA7XG52YXIgZnVuY3Rpb25fMSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9uXCIpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gY29uc3RydWN0b3JzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG52YXIgZnJvbUVxdWFscyA9IGZ1bmN0aW9uIChlcXVhbHMpIHsgcmV0dXJuICh7XG4gICAgZXF1YWxzOiBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geCA9PT0geSB8fCBlcXVhbHMoeCwgeSk7IH1cbn0pOyB9O1xuZXhwb3J0cy5mcm9tRXF1YWxzID0gZnJvbUVxdWFscztcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGNvbWJpbmF0b3JzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqIEBzaW5jZSAyLjEwLjBcbiAqL1xudmFyIHN0cnVjdCA9IGZ1bmN0aW9uIChlcXMpIHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuZnJvbUVxdWFscykoZnVuY3Rpb24gKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGVxcykge1xuICAgICAgICAgICAgaWYgKCFlcXNba2V5XS5lcXVhbHMoZmlyc3Rba2V5XSwgc2Vjb25kW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xufTtcbmV4cG9ydHMuc3RydWN0ID0gc3RydWN0O1xuLyoqXG4gKiBHaXZlbiBhIHR1cGxlIG9mIGBFcWBzIHJldHVybnMgYSBgRXFgIGZvciB0aGUgdHVwbGVcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgdHVwbGUgfSBmcm9tICdmcC10cy9FcSdcbiAqIGltcG9ydCAqIGFzIFMgZnJvbSAnZnAtdHMvc3RyaW5nJ1xuICogaW1wb3J0ICogYXMgTiBmcm9tICdmcC10cy9udW1iZXInXG4gKiBpbXBvcnQgKiBhcyBCIGZyb20gJ2ZwLXRzL2Jvb2xlYW4nXG4gKlxuICogY29uc3QgRSA9IHR1cGxlKFMuRXEsIE4uRXEsIEIuRXEpXG4gKiBhc3NlcnQuc3RyaWN0RXF1YWwoRS5lcXVhbHMoWydhJywgMSwgdHJ1ZV0sIFsnYScsIDEsIHRydWVdKSwgdHJ1ZSlcbiAqIGFzc2VydC5zdHJpY3RFcXVhbChFLmVxdWFscyhbJ2EnLCAxLCB0cnVlXSwgWydiJywgMSwgdHJ1ZV0pLCBmYWxzZSlcbiAqIGFzc2VydC5zdHJpY3RFcXVhbChFLmVxdWFscyhbJ2EnLCAxLCB0cnVlXSwgWydhJywgMiwgdHJ1ZV0pLCBmYWxzZSlcbiAqIGFzc2VydC5zdHJpY3RFcXVhbChFLmVxdWFscyhbJ2EnLCAxLCB0cnVlXSwgWydhJywgMSwgZmFsc2VdKSwgZmFsc2UpXG4gKlxuICogQHNpbmNlIDIuMTAuMFxuICovXG52YXIgdHVwbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVxcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGVxc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuZnJvbUVxdWFscykoZnVuY3Rpb24gKGZpcnN0LCBzZWNvbmQpIHsgcmV0dXJuIGVxcy5ldmVyeShmdW5jdGlvbiAoRSwgaSkgeyByZXR1cm4gRS5lcXVhbHMoZmlyc3RbaV0sIHNlY29uZFtpXSk7IH0pOyB9KTtcbn07XG5leHBvcnRzLnR1cGxlID0gdHVwbGU7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xudmFyIGNvbnRyYW1hcF8gPSBmdW5jdGlvbiAoZmEsIGYpIHsgcmV0dXJuICgwLCBmdW5jdGlvbl8xLnBpcGUpKGZhLCAoMCwgZXhwb3J0cy5jb250cmFtYXApKGYpKTsgfTtcbi8qKlxuICogQSB0eXBpY2FsIHVzZSBjYXNlIGZvciBgY29udHJhbWFwYCB3b3VsZCBiZSBsaWtlLCBnaXZlbiBzb21lIGBVc2VyYCB0eXBlLCB0byBjb25zdHJ1Y3QgYW4gYEVxPFVzZXI+YC5cbiAqXG4gKiBXZSBjYW4gZG8gc28gd2l0aCBhIGZ1bmN0aW9uIGZyb20gYFVzZXIgLT4gWGAgd2hlcmUgYFhgIGlzIHNvbWUgdmFsdWUgdGhhdCB3ZSBrbm93IGhvdyB0byBjb21wYXJlXG4gKiBmb3IgZXF1YWxpdHkgKG1lYW5pbmcgd2UgaGF2ZSBhbiBgRXE8WD5gKVxuICpcbiAqIEZvciBleGFtcGxlLCBnaXZlbiB0aGUgZm9sbG93aW5nIGBVc2VyYCB0eXBlLCB3ZSB3YW50IHRvIGNvbnN0cnVjdCBhbiBgRXE8VXNlcj5gIHRoYXQganVzdCBsb29rcyBhdCB0aGUgYGtleWAgZmllbGRcbiAqIGZvciBlYWNoIHVzZXIgKHNpbmNlIGl0J3Mga25vd24gdG8gYmUgdW5pcXVlKS5cbiAqXG4gKiBJZiB3ZSBoYXZlIGEgd2F5IG9mIGNvbXBhcmluZyBgVVVJRGBzIGZvciBlcXVhbGl0eSAoYGVxVVVJRDogRXE8VVVJRD5gKSBhbmQgd2Uga25vdyBob3cgdG8gZ28gZnJvbSBgVXNlciAtPiBVVUlEYCxcbiAqIHVzaW5nIGBjb250cmFtYXBgIHdlIGNhbiBkbyB0aGlzXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGNvbnRyYW1hcCwgRXEgfSBmcm9tICdmcC10cy9FcSdcbiAqIGltcG9ydCB7IHBpcGUgfSBmcm9tICdmcC10cy9mdW5jdGlvbidcbiAqIGltcG9ydCAqIGFzIFMgZnJvbSAnZnAtdHMvc3RyaW5nJ1xuICpcbiAqIHR5cGUgVVVJRCA9IHN0cmluZ1xuICpcbiAqIGludGVyZmFjZSBVc2VyIHtcbiAqICAgcmVhZG9ubHkga2V5OiBVVUlEXG4gKiAgIHJlYWRvbmx5IGZpcnN0TmFtZTogc3RyaW5nXG4gKiAgIHJlYWRvbmx5IGxhc3ROYW1lOiBzdHJpbmdcbiAqIH1cbiAqXG4gKiBjb25zdCBlcVVVSUQ6IEVxPFVVSUQ+ID0gUy5FcVxuICpcbiAqIGNvbnN0IGVxVXNlckJ5S2V5OiBFcTxVc2VyPiA9IHBpcGUoXG4gKiAgIGVxVVVJRCxcbiAqICAgY29udHJhbWFwKCh1c2VyKSA9PiB1c2VyLmtleSlcbiAqIClcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogICBlcVVzZXJCeUtleS5lcXVhbHMoXG4gKiAgICAgeyBrZXk6ICdrMScsIGZpcnN0TmFtZTogJ2ExJywgbGFzdE5hbWU6ICdiMScgfSxcbiAqICAgICB7IGtleTogJ2syJywgZmlyc3ROYW1lOiAnYTEnLCBsYXN0TmFtZTogJ2IxJyB9XG4gKiAgICksXG4gKiAgIGZhbHNlXG4gKiApXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogICBlcVVzZXJCeUtleS5lcXVhbHMoXG4gKiAgICAgeyBrZXk6ICdrMScsIGZpcnN0TmFtZTogJ2ExJywgbGFzdE5hbWU6ICdiMScgfSxcbiAqICAgICB7IGtleTogJ2sxJywgZmlyc3ROYW1lOiAnYTInLCBsYXN0TmFtZTogJ2IxJyB9XG4gKiAgICksXG4gKiAgIHRydWVcbiAqIClcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xudmFyIGNvbnRyYW1hcCA9IGZ1bmN0aW9uIChmKSB7IHJldHVybiBmdW5jdGlvbiAoZmEpIHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuZnJvbUVxdWFscykoZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIGZhLmVxdWFscyhmKHgpLCBmKHkpKTsgfSk7XG59OyB9O1xuZXhwb3J0cy5jb250cmFtYXAgPSBjb250cmFtYXA7XG4vKipcbiAqIEBjYXRlZ29yeSB0eXBlIGxhbWJkYXNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnRzLlVSSSA9ICdFcSc7XG4vKipcbiAqIEBjYXRlZ29yeSBpbnN0YW5jZXNcbiAqIEBzaW5jZSAyLjUuMFxuICovXG5leHBvcnRzLmVxU3RyaWN0ID0ge1xuICAgIGVxdWFsczogZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgPT09IGI7IH1cbn07XG52YXIgZW1wdHkgPSB7XG4gICAgZXF1YWxzOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9XG59O1xuLyoqXG4gKiBAY2F0ZWdvcnkgaW5zdGFuY2VzXG4gKiBAc2luY2UgMi4xMC4wXG4gKi9cbnZhciBnZXRTZW1pZ3JvdXAgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgIGNvbmNhdDogZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuICgwLCBleHBvcnRzLmZyb21FcXVhbHMpKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiB4LmVxdWFscyhhLCBiKSAmJiB5LmVxdWFscyhhLCBiKTsgfSk7IH1cbn0pOyB9O1xuZXhwb3J0cy5nZXRTZW1pZ3JvdXAgPSBnZXRTZW1pZ3JvdXA7XG4vKipcbiAqIEBjYXRlZ29yeSBpbnN0YW5jZXNcbiAqIEBzaW5jZSAyLjYuMFxuICovXG52YXIgZ2V0TW9ub2lkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICBjb25jYXQ6ICgwLCBleHBvcnRzLmdldFNlbWlncm91cCkoKS5jb25jYXQsXG4gICAgZW1wdHk6IGVtcHR5XG59KTsgfTtcbmV4cG9ydHMuZ2V0TW9ub2lkID0gZ2V0TW9ub2lkO1xuLyoqXG4gKiBAY2F0ZWdvcnkgaW5zdGFuY2VzXG4gKiBAc2luY2UgMi43LjBcbiAqL1xuZXhwb3J0cy5Db250cmF2YXJpYW50ID0ge1xuICAgIFVSSTogZXhwb3J0cy5VUkksXG4gICAgY29udHJhbWFwOiBjb250cmFtYXBfXG59O1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZGVwcmVjYXRlZFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBVc2UgW2B0dXBsZWBdKCN0dXBsZSkgaW5zdGVhZC5cbiAqXG4gKiBAY2F0ZWdvcnkgem9uZSBvZiBkZWF0aFxuICogQHNpbmNlIDIuMC4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnRzLmdldFR1cGxlRXEgPSBleHBvcnRzLnR1cGxlO1xuLyoqXG4gKiBVc2UgW2BzdHJ1Y3RgXSgjc3RydWN0KSBpbnN0ZWFkLlxuICpcbiAqIEBjYXRlZ29yeSB6b25lIG9mIGRlYXRoXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydHMuZ2V0U3RydWN0RXEgPSBleHBvcnRzLnN0cnVjdDtcbi8qKlxuICogVXNlIFtgZXFTdHJpY3RgXSgjZXFzdHJpY3QpIGluc3RlYWRcbiAqXG4gKiBAY2F0ZWdvcnkgem9uZSBvZiBkZWF0aFxuICogQHNpbmNlIDIuMC4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnRzLnN0cmljdEVxdWFsID0gZXhwb3J0cy5lcVN0cmljdC5lcXVhbHM7XG4vKipcbiAqIFRoaXMgaW5zdGFuY2UgaXMgZGVwcmVjYXRlZCwgdXNlIHNtYWxsLCBzcGVjaWZpYyBpbnN0YW5jZXMgaW5zdGVhZC5cbiAqIEZvciBleGFtcGxlIGlmIGEgZnVuY3Rpb24gbmVlZHMgYSBgQ29udHJhdmFyaWFudGAgaW5zdGFuY2UsIHBhc3MgYEUuQ29udHJhdmFyaWFudGAgaW5zdGVhZCBvZiBgRS5lcWBcbiAqICh3aGVyZSBgRWAgaXMgZnJvbSBgaW1wb3J0IEUgZnJvbSAnZnAtdHMvRXEnYClcbiAqXG4gKiBAY2F0ZWdvcnkgem9uZSBvZiBkZWF0aFxuICogQHNpbmNlIDIuMC4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnRzLmVxID0gZXhwb3J0cy5Db250cmF2YXJpYW50O1xuLyoqXG4gKiBVc2UgW2BFcWBdKC4vYm9vbGVhbi50cy5odG1sI2VxKSBpbnN0ZWFkLlxuICpcbiAqIEBjYXRlZ29yeSB6b25lIG9mIGRlYXRoXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydHMuZXFCb29sZWFuID0gZXhwb3J0cy5lcVN0cmljdDtcbi8qKlxuICogVXNlIFtgRXFgXSguL3N0cmluZy50cy5odG1sI2VxKSBpbnN0ZWFkLlxuICpcbiAqIEBjYXRlZ29yeSB6b25lIG9mIGRlYXRoXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydHMuZXFTdHJpbmcgPSBleHBvcnRzLmVxU3RyaWN0O1xuLyoqXG4gKiBVc2UgW2BFcWBdKC4vbnVtYmVyLnRzLmh0bWwjZXEpIGluc3RlYWQuXG4gKlxuICogQGNhdGVnb3J5IHpvbmUgb2YgZGVhdGhcbiAqIEBzaW5jZSAyLjAuMFxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0cy5lcU51bWJlciA9IGV4cG9ydHMuZXFTdHJpY3Q7XG4vKipcbiAqIFVzZSBbYEVxYF0oLi9EYXRlLnRzLmh0bWwjZXEpIGluc3RlYWQuXG4gKlxuICogQGNhdGVnb3J5IHpvbmUgb2YgZGVhdGhcbiAqIEBzaW5jZSAyLjAuMFxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0cy5lcURhdGUgPSB7XG4gICAgZXF1YWxzOiBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkgeyByZXR1cm4gZmlyc3QudmFsdWVPZigpID09PSBzZWNvbmQudmFsdWVPZigpOyB9XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fp-ts/lib/Eq.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fp-ts/lib/FromEither.js":
/*!**********************************************!*\
  !*** ./node_modules/fp-ts/lib/FromEither.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\n/**\n * The `FromEither` type class represents those data types which support errors.\n *\n * @since 2.10.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fromOption = fromOption;\nexports.fromPredicate = fromPredicate;\nexports.fromOptionK = fromOptionK;\nexports.chainOptionK = chainOptionK;\nexports.fromEitherK = fromEitherK;\nexports.chainEitherK = chainEitherK;\nexports.chainFirstEitherK = chainFirstEitherK;\nexports.filterOrElse = filterOrElse;\nexports.tapEither = tapEither;\nvar Chain_1 = __webpack_require__(/*! ./Chain */ \"(app-pages-browser)/./node_modules/fp-ts/lib/Chain.js\");\nvar function_1 = __webpack_require__(/*! ./function */ \"(app-pages-browser)/./node_modules/fp-ts/lib/function.js\");\nvar _ = __importStar(__webpack_require__(/*! ./internal */ \"(app-pages-browser)/./node_modules/fp-ts/lib/internal.js\"));\nfunction fromOption(F) {\n    return function (onNone) { return function (ma) { return F.fromEither(_.isNone(ma) ? _.left(onNone()) : _.right(ma.value)); }; };\n}\nfunction fromPredicate(F) {\n    return function (predicate, onFalse) {\n        return function (a) {\n            return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a)));\n        };\n    };\n}\nfunction fromOptionK(F) {\n    var fromOptionF = fromOption(F);\n    return function (onNone) {\n        var from = fromOptionF(onNone);\n        return function (f) { return (0, function_1.flow)(f, from); };\n    };\n}\nfunction chainOptionK(F, M) {\n    var fromOptionKF = fromOptionK(F);\n    return function (onNone) {\n        var from = fromOptionKF(onNone);\n        return function (f) { return function (ma) { return M.chain(ma, from(f)); }; };\n    };\n}\nfunction fromEitherK(F) {\n    return function (f) { return (0, function_1.flow)(f, F.fromEither); };\n}\nfunction chainEitherK(F, M) {\n    var fromEitherKF = fromEitherK(F);\n    return function (f) { return function (ma) { return M.chain(ma, fromEitherKF(f)); }; };\n}\nfunction chainFirstEitherK(F, M) {\n    var tapEitherM = tapEither(F, M);\n    return function (f) { return function (ma) { return tapEitherM(ma, f); }; };\n}\nfunction filterOrElse(F, M) {\n    return function (predicate, onFalse) {\n        return function (ma) {\n            return M.chain(ma, function (a) { return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a))); });\n        };\n    };\n}\n/** @internal */\nfunction tapEither(F, M) {\n    var fromEither = fromEitherK(F);\n    var tapM = (0, Chain_1.tap)(M);\n    return function (self, f) { return tapM(self, fromEither(f)); };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcC10cy9saWIvRnJvbUVpdGhlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkIsb0JBQW9CO0FBQ3BCLHlCQUF5QjtBQUN6QixvQkFBb0I7QUFDcEIsaUJBQWlCO0FBQ2pCLGNBQWMsbUJBQU8sQ0FBQyxzRUFBUztBQUMvQixpQkFBaUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUNyQyxxQkFBcUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN6QztBQUNBLCtCQUErQix1QkFBdUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix1QkFBdUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxzRUFBc0U7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMiLCJzb3VyY2VzIjpbIkk6XFxTY2FsYUN1cnNvdmF5YVxcQnVua2VyV2ViXFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxmcC10c1xcbGliXFxGcm9tRWl0aGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBUaGUgYEZyb21FaXRoZXJgIHR5cGUgY2xhc3MgcmVwcmVzZW50cyB0aG9zZSBkYXRhIHR5cGVzIHdoaWNoIHN1cHBvcnQgZXJyb3JzLlxuICpcbiAqIEBzaW5jZSAyLjEwLjBcbiAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZyb21PcHRpb24gPSBmcm9tT3B0aW9uO1xuZXhwb3J0cy5mcm9tUHJlZGljYXRlID0gZnJvbVByZWRpY2F0ZTtcbmV4cG9ydHMuZnJvbU9wdGlvbksgPSBmcm9tT3B0aW9uSztcbmV4cG9ydHMuY2hhaW5PcHRpb25LID0gY2hhaW5PcHRpb25LO1xuZXhwb3J0cy5mcm9tRWl0aGVySyA9IGZyb21FaXRoZXJLO1xuZXhwb3J0cy5jaGFpbkVpdGhlcksgPSBjaGFpbkVpdGhlcks7XG5leHBvcnRzLmNoYWluRmlyc3RFaXRoZXJLID0gY2hhaW5GaXJzdEVpdGhlcks7XG5leHBvcnRzLmZpbHRlck9yRWxzZSA9IGZpbHRlck9yRWxzZTtcbmV4cG9ydHMudGFwRWl0aGVyID0gdGFwRWl0aGVyO1xudmFyIENoYWluXzEgPSByZXF1aXJlKFwiLi9DaGFpblwiKTtcbnZhciBmdW5jdGlvbl8xID0gcmVxdWlyZShcIi4vZnVuY3Rpb25cIik7XG52YXIgXyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9pbnRlcm5hbFwiKSk7XG5mdW5jdGlvbiBmcm9tT3B0aW9uKEYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9uTm9uZSkgeyByZXR1cm4gZnVuY3Rpb24gKG1hKSB7IHJldHVybiBGLmZyb21FaXRoZXIoXy5pc05vbmUobWEpID8gXy5sZWZ0KG9uTm9uZSgpKSA6IF8ucmlnaHQobWEudmFsdWUpKTsgfTsgfTtcbn1cbmZ1bmN0aW9uIGZyb21QcmVkaWNhdGUoRikge1xuICAgIHJldHVybiBmdW5jdGlvbiAocHJlZGljYXRlLCBvbkZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgcmV0dXJuIEYuZnJvbUVpdGhlcihwcmVkaWNhdGUoYSkgPyBfLnJpZ2h0KGEpIDogXy5sZWZ0KG9uRmFsc2UoYSkpKTtcbiAgICAgICAgfTtcbiAgICB9O1xufVxuZnVuY3Rpb24gZnJvbU9wdGlvbksoRikge1xuICAgIHZhciBmcm9tT3B0aW9uRiA9IGZyb21PcHRpb24oRik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvbk5vbmUpIHtcbiAgICAgICAgdmFyIGZyb20gPSBmcm9tT3B0aW9uRihvbk5vbmUpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuICgwLCBmdW5jdGlvbl8xLmZsb3cpKGYsIGZyb20pOyB9O1xuICAgIH07XG59XG5mdW5jdGlvbiBjaGFpbk9wdGlvbksoRiwgTSkge1xuICAgIHZhciBmcm9tT3B0aW9uS0YgPSBmcm9tT3B0aW9uSyhGKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9uTm9uZSkge1xuICAgICAgICB2YXIgZnJvbSA9IGZyb21PcHRpb25LRihvbk5vbmUpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGZ1bmN0aW9uIChtYSkgeyByZXR1cm4gTS5jaGFpbihtYSwgZnJvbShmKSk7IH07IH07XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZyb21FaXRoZXJLKEYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuICgwLCBmdW5jdGlvbl8xLmZsb3cpKGYsIEYuZnJvbUVpdGhlcik7IH07XG59XG5mdW5jdGlvbiBjaGFpbkVpdGhlcksoRiwgTSkge1xuICAgIHZhciBmcm9tRWl0aGVyS0YgPSBmcm9tRWl0aGVySyhGKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGZ1bmN0aW9uIChtYSkgeyByZXR1cm4gTS5jaGFpbihtYSwgZnJvbUVpdGhlcktGKGYpKTsgfTsgfTtcbn1cbmZ1bmN0aW9uIGNoYWluRmlyc3RFaXRoZXJLKEYsIE0pIHtcbiAgICB2YXIgdGFwRWl0aGVyTSA9IHRhcEVpdGhlcihGLCBNKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGZ1bmN0aW9uIChtYSkgeyByZXR1cm4gdGFwRWl0aGVyTShtYSwgZik7IH07IH07XG59XG5mdW5jdGlvbiBmaWx0ZXJPckVsc2UoRiwgTSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAocHJlZGljYXRlLCBvbkZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobWEpIHtcbiAgICAgICAgICAgIHJldHVybiBNLmNoYWluKG1hLCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gRi5mcm9tRWl0aGVyKHByZWRpY2F0ZShhKSA/IF8ucmlnaHQoYSkgOiBfLmxlZnQob25GYWxzZShhKSkpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gdGFwRWl0aGVyKEYsIE0pIHtcbiAgICB2YXIgZnJvbUVpdGhlciA9IGZyb21FaXRoZXJLKEYpO1xuICAgIHZhciB0YXBNID0gKDAsIENoYWluXzEudGFwKShNKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNlbGYsIGYpIHsgcmV0dXJuIHRhcE0oc2VsZiwgZnJvbUVpdGhlcihmKSk7IH07XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fp-ts/lib/FromEither.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fp-ts/lib/Functor.js":
/*!*******************************************!*\
  !*** ./node_modules/fp-ts/lib/Functor.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.map = map;\nexports.flap = flap;\nexports.bindTo = bindTo;\nexports[\"let\"] = let_;\nexports.getFunctorComposition = getFunctorComposition;\nexports.as = as;\nexports.asUnit = asUnit;\n/**\n * A `Functor` is a type constructor which supports a mapping operation `map`.\n *\n * `map` can be used to turn functions `a -> b` into functions `f a -> f b` whose argument and return types use the type\n * constructor `f` to represent some computational context.\n *\n * Instances must satisfy the following laws:\n *\n * 1. Identity: `F.map(fa, a => a) <-> fa`\n * 2. Composition: `F.map(fa, a => bc(ab(a))) <-> F.map(F.map(fa, ab), bc)`\n *\n * @since 2.0.0\n */\nvar function_1 = __webpack_require__(/*! ./function */ \"(app-pages-browser)/./node_modules/fp-ts/lib/function.js\");\nfunction map(F, G) {\n    return function (f) { return function (fa) { return F.map(fa, function (ga) { return G.map(ga, f); }); }; };\n}\nfunction flap(F) {\n    return function (a) { return function (fab) { return F.map(fab, function (f) { return f(a); }); }; };\n}\nfunction bindTo(F) {\n    return function (name) { return function (fa) { return F.map(fa, function (a) {\n        var _a;\n        return (_a = {}, _a[name] = a, _a);\n    }); }; };\n}\nfunction let_(F) {\n    return function (name, f) { return function (fa) { return F.map(fa, function (a) {\n        var _a;\n        return Object.assign({}, a, (_a = {}, _a[name] = f(a), _a));\n    }); }; };\n}\n/** @deprecated */\nfunction getFunctorComposition(F, G) {\n    var _map = map(F, G);\n    return {\n        map: function (fga, f) { return (0, function_1.pipe)(fga, _map(f)); }\n    };\n}\n/** @internal */\nfunction as(F) {\n    return function (self, b) { return F.map(self, function () { return b; }); };\n}\n/** @internal */\nfunction asUnit(F) {\n    var asM = as(F);\n    return function (self) { return asM(self, undefined); };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcC10cy9saWIvRnVuY3Rvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxXQUFXO0FBQ1gsWUFBWTtBQUNaLGNBQWM7QUFDZCxjQUFXO0FBQ1gsNkJBQTZCO0FBQzdCLFVBQVU7QUFDVixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUNyQztBQUNBLDBCQUEwQix1QkFBdUIsaUNBQWlDLHNCQUFzQjtBQUN4RztBQUNBO0FBQ0EsMEJBQTBCLHdCQUF3QixpQ0FBaUMsY0FBYztBQUNqRztBQUNBO0FBQ0EsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNBLHVCQUF1QjtBQUN2QixLQUFLO0FBQ0w7QUFDQTtBQUNBLGdDQUFnQyx1QkFBdUI7QUFDdkQ7QUFDQSwrQkFBK0IsYUFBYTtBQUM1QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQ0FBaUMsV0FBVztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsiSTpcXFNjYWxhQ3Vyc292YXlhXFxCdW5rZXJXZWJcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXGZwLXRzXFxsaWJcXEZ1bmN0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1hcCA9IG1hcDtcbmV4cG9ydHMuZmxhcCA9IGZsYXA7XG5leHBvcnRzLmJpbmRUbyA9IGJpbmRUbztcbmV4cG9ydHMubGV0ID0gbGV0XztcbmV4cG9ydHMuZ2V0RnVuY3RvckNvbXBvc2l0aW9uID0gZ2V0RnVuY3RvckNvbXBvc2l0aW9uO1xuZXhwb3J0cy5hcyA9IGFzO1xuZXhwb3J0cy5hc1VuaXQgPSBhc1VuaXQ7XG4vKipcbiAqIEEgYEZ1bmN0b3JgIGlzIGEgdHlwZSBjb25zdHJ1Y3RvciB3aGljaCBzdXBwb3J0cyBhIG1hcHBpbmcgb3BlcmF0aW9uIGBtYXBgLlxuICpcbiAqIGBtYXBgIGNhbiBiZSB1c2VkIHRvIHR1cm4gZnVuY3Rpb25zIGBhIC0+IGJgIGludG8gZnVuY3Rpb25zIGBmIGEgLT4gZiBiYCB3aG9zZSBhcmd1bWVudCBhbmQgcmV0dXJuIHR5cGVzIHVzZSB0aGUgdHlwZVxuICogY29uc3RydWN0b3IgYGZgIHRvIHJlcHJlc2VudCBzb21lIGNvbXB1dGF0aW9uYWwgY29udGV4dC5cbiAqXG4gKiBJbnN0YW5jZXMgbXVzdCBzYXRpc2Z5IHRoZSBmb2xsb3dpbmcgbGF3czpcbiAqXG4gKiAxLiBJZGVudGl0eTogYEYubWFwKGZhLCBhID0+IGEpIDwtPiBmYWBcbiAqIDIuIENvbXBvc2l0aW9uOiBgRi5tYXAoZmEsIGEgPT4gYmMoYWIoYSkpKSA8LT4gRi5tYXAoRi5tYXAoZmEsIGFiKSwgYmMpYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG52YXIgZnVuY3Rpb25fMSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9uXCIpO1xuZnVuY3Rpb24gbWFwKEYsIEcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGZ1bmN0aW9uIChmYSkgeyByZXR1cm4gRi5tYXAoZmEsIGZ1bmN0aW9uIChnYSkgeyByZXR1cm4gRy5tYXAoZ2EsIGYpOyB9KTsgfTsgfTtcbn1cbmZ1bmN0aW9uIGZsYXAoRikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gZnVuY3Rpb24gKGZhYikgeyByZXR1cm4gRi5tYXAoZmFiLCBmdW5jdGlvbiAoZikgeyByZXR1cm4gZihhKTsgfSk7IH07IH07XG59XG5mdW5jdGlvbiBiaW5kVG8oRikge1xuICAgIHJldHVybiBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gZnVuY3Rpb24gKGZhKSB7IHJldHVybiBGLm1hcChmYSwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0ge30sIF9hW25hbWVdID0gYSwgX2EpO1xuICAgIH0pOyB9OyB9O1xufVxuZnVuY3Rpb24gbGV0XyhGKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lLCBmKSB7IHJldHVybiBmdW5jdGlvbiAoZmEpIHsgcmV0dXJuIEYubWFwKGZhLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBhLCAoX2EgPSB7fSwgX2FbbmFtZV0gPSBmKGEpLCBfYSkpO1xuICAgIH0pOyB9OyB9O1xufVxuLyoqIEBkZXByZWNhdGVkICovXG5mdW5jdGlvbiBnZXRGdW5jdG9yQ29tcG9zaXRpb24oRiwgRykge1xuICAgIHZhciBfbWFwID0gbWFwKEYsIEcpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG1hcDogZnVuY3Rpb24gKGZnYSwgZikgeyByZXR1cm4gKDAsIGZ1bmN0aW9uXzEucGlwZSkoZmdhLCBfbWFwKGYpKTsgfVxuICAgIH07XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBhcyhGKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzZWxmLCBiKSB7IHJldHVybiBGLm1hcChzZWxmLCBmdW5jdGlvbiAoKSB7IHJldHVybiBiOyB9KTsgfTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIGFzVW5pdChGKSB7XG4gICAgdmFyIGFzTSA9IGFzKEYpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc2VsZikgeyByZXR1cm4gYXNNKHNlbGYsIHVuZGVmaW5lZCk7IH07XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fp-ts/lib/Functor.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fp-ts/lib/Magma.js":
/*!*****************************************!*\
  !*** ./node_modules/fp-ts/lib/Magma.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\n/**\n * A `Magma` is a pair `(A, concat)` in which `A` is a non-empty set and `concat` is a binary operation on `A`\n *\n * See [Semigroup](https://gcanti.github.io/fp-ts/modules/Semigroup.ts.html) for some instances.\n *\n * @since 2.0.0\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.concatAll = exports.endo = exports.filterSecond = exports.filterFirst = exports.reverse = void 0;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * The dual of a `Magma`, obtained by swapping the arguments of `concat`.\n *\n * @example\n * import { reverse, concatAll } from 'fp-ts/Magma'\n * import * as N from 'fp-ts/number'\n *\n * const subAll = concatAll(reverse(N.MagmaSub))(0)\n *\n * assert.deepStrictEqual(subAll([1, 2, 3]), 2)\n *\n * @since 2.11.0\n */\nvar reverse = function (M) { return ({\n    concat: function (first, second) { return M.concat(second, first); }\n}); };\nexports.reverse = reverse;\n/**\n * @since 2.11.0\n */\nvar filterFirst = function (predicate) {\n    return function (M) { return ({\n        concat: function (first, second) { return (predicate(first) ? M.concat(first, second) : second); }\n    }); };\n};\nexports.filterFirst = filterFirst;\n/**\n * @since 2.11.0\n */\nvar filterSecond = function (predicate) {\n    return function (M) { return ({\n        concat: function (first, second) { return (predicate(second) ? M.concat(first, second) : first); }\n    }); };\n};\nexports.filterSecond = filterSecond;\n/**\n * @since 2.11.0\n */\nvar endo = function (f) {\n    return function (M) { return ({\n        concat: function (first, second) { return M.concat(f(first), f(second)); }\n    }); };\n};\nexports.endo = endo;\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Given a sequence of `as`, concat them and return the total.\n *\n * If `as` is empty, return the provided `startWith` value.\n *\n * @example\n * import { concatAll } from 'fp-ts/Magma'\n * import * as N from 'fp-ts/number'\n *\n * const subAll = concatAll(N.MagmaSub)(0)\n *\n * assert.deepStrictEqual(subAll([1, 2, 3]), -6)\n *\n * @since 2.11.0\n */\nvar concatAll = function (M) {\n    return function (startWith) {\n        return function (as) {\n            return as.reduce(function (a, acc) { return M.concat(a, acc); }, startWith);\n        };\n    };\n};\nexports.concatAll = concatAll;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcC10cy9saWIvTWFnbWEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyxZQUFZLEdBQUcsb0JBQW9CLEdBQUcsbUJBQW1CLEdBQUcsZUFBZTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsdUNBQXVDO0FBQ3ZDLENBQUM7QUFDRCxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsMkNBQTJDO0FBQzNDLEtBQUs7QUFDTDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiwyQ0FBMkM7QUFDM0MsS0FBSztBQUNMO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDJDQUEyQztBQUMzQyxLQUFLO0FBQ0w7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsMEJBQTBCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiIsInNvdXJjZXMiOlsiSTpcXFNjYWxhQ3Vyc292YXlhXFxCdW5rZXJXZWJcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXGZwLXRzXFxsaWJcXE1hZ21hLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBBIGBNYWdtYWAgaXMgYSBwYWlyIGAoQSwgY29uY2F0KWAgaW4gd2hpY2ggYEFgIGlzIGEgbm9uLWVtcHR5IHNldCBhbmQgYGNvbmNhdGAgaXMgYSBiaW5hcnkgb3BlcmF0aW9uIG9uIGBBYFxuICpcbiAqIFNlZSBbU2VtaWdyb3VwXShodHRwczovL2djYW50aS5naXRodWIuaW8vZnAtdHMvbW9kdWxlcy9TZW1pZ3JvdXAudHMuaHRtbCkgZm9yIHNvbWUgaW5zdGFuY2VzLlxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbmNhdEFsbCA9IGV4cG9ydHMuZW5kbyA9IGV4cG9ydHMuZmlsdGVyU2Vjb25kID0gZXhwb3J0cy5maWx0ZXJGaXJzdCA9IGV4cG9ydHMucmV2ZXJzZSA9IHZvaWQgMDtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGNvbWJpbmF0b3JzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqIFRoZSBkdWFsIG9mIGEgYE1hZ21hYCwgb2J0YWluZWQgYnkgc3dhcHBpbmcgdGhlIGFyZ3VtZW50cyBvZiBgY29uY2F0YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgcmV2ZXJzZSwgY29uY2F0QWxsIH0gZnJvbSAnZnAtdHMvTWFnbWEnXG4gKiBpbXBvcnQgKiBhcyBOIGZyb20gJ2ZwLXRzL251bWJlcidcbiAqXG4gKiBjb25zdCBzdWJBbGwgPSBjb25jYXRBbGwocmV2ZXJzZShOLk1hZ21hU3ViKSkoMClcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHN1YkFsbChbMSwgMiwgM10pLCAyKVxuICpcbiAqIEBzaW5jZSAyLjExLjBcbiAqL1xudmFyIHJldmVyc2UgPSBmdW5jdGlvbiAoTSkgeyByZXR1cm4gKHtcbiAgICBjb25jYXQ6IGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKSB7IHJldHVybiBNLmNvbmNhdChzZWNvbmQsIGZpcnN0KTsgfVxufSk7IH07XG5leHBvcnRzLnJldmVyc2UgPSByZXZlcnNlO1xuLyoqXG4gKiBAc2luY2UgMi4xMS4wXG4gKi9cbnZhciBmaWx0ZXJGaXJzdCA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKE0pIHsgcmV0dXJuICh7XG4gICAgICAgIGNvbmNhdDogZnVuY3Rpb24gKGZpcnN0LCBzZWNvbmQpIHsgcmV0dXJuIChwcmVkaWNhdGUoZmlyc3QpID8gTS5jb25jYXQoZmlyc3QsIHNlY29uZCkgOiBzZWNvbmQpOyB9XG4gICAgfSk7IH07XG59O1xuZXhwb3J0cy5maWx0ZXJGaXJzdCA9IGZpbHRlckZpcnN0O1xuLyoqXG4gKiBAc2luY2UgMi4xMS4wXG4gKi9cbnZhciBmaWx0ZXJTZWNvbmQgPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChNKSB7IHJldHVybiAoe1xuICAgICAgICBjb25jYXQ6IGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKSB7IHJldHVybiAocHJlZGljYXRlKHNlY29uZCkgPyBNLmNvbmNhdChmaXJzdCwgc2Vjb25kKSA6IGZpcnN0KTsgfVxuICAgIH0pOyB9O1xufTtcbmV4cG9ydHMuZmlsdGVyU2Vjb25kID0gZmlsdGVyU2Vjb25kO1xuLyoqXG4gKiBAc2luY2UgMi4xMS4wXG4gKi9cbnZhciBlbmRvID0gZnVuY3Rpb24gKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKE0pIHsgcmV0dXJuICh7XG4gICAgICAgIGNvbmNhdDogZnVuY3Rpb24gKGZpcnN0LCBzZWNvbmQpIHsgcmV0dXJuIE0uY29uY2F0KGYoZmlyc3QpLCBmKHNlY29uZCkpOyB9XG4gICAgfSk7IH07XG59O1xuZXhwb3J0cy5lbmRvID0gZW5kbztcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHV0aWxzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqIEdpdmVuIGEgc2VxdWVuY2Ugb2YgYGFzYCwgY29uY2F0IHRoZW0gYW5kIHJldHVybiB0aGUgdG90YWwuXG4gKlxuICogSWYgYGFzYCBpcyBlbXB0eSwgcmV0dXJuIHRoZSBwcm92aWRlZCBgc3RhcnRXaXRoYCB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgY29uY2F0QWxsIH0gZnJvbSAnZnAtdHMvTWFnbWEnXG4gKiBpbXBvcnQgKiBhcyBOIGZyb20gJ2ZwLXRzL251bWJlcidcbiAqXG4gKiBjb25zdCBzdWJBbGwgPSBjb25jYXRBbGwoTi5NYWdtYVN1YikoMClcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHN1YkFsbChbMSwgMiwgM10pLCAtNilcbiAqXG4gKiBAc2luY2UgMi4xMS4wXG4gKi9cbnZhciBjb25jYXRBbGwgPSBmdW5jdGlvbiAoTSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhcnRXaXRoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXMpIHtcbiAgICAgICAgICAgIHJldHVybiBhcy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGFjYykgeyByZXR1cm4gTS5jb25jYXQoYSwgYWNjKTsgfSwgc3RhcnRXaXRoKTtcbiAgICAgICAgfTtcbiAgICB9O1xufTtcbmV4cG9ydHMuY29uY2F0QWxsID0gY29uY2F0QWxsO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fp-ts/lib/Magma.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fp-ts/lib/Option.js":
/*!******************************************!*\
  !*** ./node_modules/fp-ts/lib/Option.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.throwError = exports.Witherable = exports.wilt = exports.wither = exports.Traversable = exports.sequence = exports.traverse = exports.Filterable = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = exports.Compactable = exports.separate = exports.compact = exports.Extend = exports.extend = exports.Alternative = exports.guard = exports.Zero = exports.zero = exports.Alt = exports.alt = exports.altW = exports.orElse = exports.Foldable = exports.reduceRight = exports.foldMap = exports.reduce = exports.Monad = exports.Chain = exports.flatMap = exports.Applicative = exports.Apply = exports.ap = exports.Pointed = exports.of = exports.asUnit = exports.as = exports.Functor = exports.map = exports.getMonoid = exports.getOrd = exports.getEq = exports.getShow = exports.URI = exports.getRight = exports.getLeft = exports.some = exports.none = void 0;\nexports.getLastMonoid = exports.getFirstMonoid = exports.getApplyMonoid = exports.getApplySemigroup = exports.option = exports.mapNullable = exports.chainFirst = exports.chain = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apS = exports.bind = exports[\"let\"] = exports.bindTo = exports.Do = exports.exists = exports.toUndefined = exports.toNullable = exports.chainNullableK = exports.fromNullableK = exports.tryCatchK = exports.tryCatch = exports.fromNullable = exports.chainFirstEitherK = exports.chainEitherK = exports.fromEitherK = exports.duplicate = exports.tapEither = exports.tap = exports.flatten = exports.apSecond = exports.apFirst = exports.flap = exports.getOrElse = exports.getOrElseW = exports.fold = exports.match = exports.foldW = exports.matchW = exports.isNone = exports.isSome = exports.FromEither = exports.fromEither = exports.MonadThrow = void 0;\nexports.fromPredicate = fromPredicate;\nexports.elem = elem;\nexports.getRefinement = getRefinement;\nvar Applicative_1 = __webpack_require__(/*! ./Applicative */ \"(app-pages-browser)/./node_modules/fp-ts/lib/Applicative.js\");\nvar Apply_1 = __webpack_require__(/*! ./Apply */ \"(app-pages-browser)/./node_modules/fp-ts/lib/Apply.js\");\nvar chainable = __importStar(__webpack_require__(/*! ./Chain */ \"(app-pages-browser)/./node_modules/fp-ts/lib/Chain.js\"));\nvar FromEither_1 = __webpack_require__(/*! ./FromEither */ \"(app-pages-browser)/./node_modules/fp-ts/lib/FromEither.js\");\nvar function_1 = __webpack_require__(/*! ./function */ \"(app-pages-browser)/./node_modules/fp-ts/lib/function.js\");\nvar Functor_1 = __webpack_require__(/*! ./Functor */ \"(app-pages-browser)/./node_modules/fp-ts/lib/Functor.js\");\nvar _ = __importStar(__webpack_require__(/*! ./internal */ \"(app-pages-browser)/./node_modules/fp-ts/lib/internal.js\"));\nvar Predicate_1 = __webpack_require__(/*! ./Predicate */ \"(app-pages-browser)/./node_modules/fp-ts/lib/Predicate.js\");\nvar Semigroup_1 = __webpack_require__(/*! ./Semigroup */ \"(app-pages-browser)/./node_modules/fp-ts/lib/Semigroup.js\");\nvar Separated_1 = __webpack_require__(/*! ./Separated */ \"(app-pages-browser)/./node_modules/fp-ts/lib/Separated.js\");\nvar Witherable_1 = __webpack_require__(/*! ./Witherable */ \"(app-pages-browser)/./node_modules/fp-ts/lib/Witherable.js\");\nvar Zero_1 = __webpack_require__(/*! ./Zero */ \"(app-pages-browser)/./node_modules/fp-ts/lib/Zero.js\");\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * `None` doesn't have a constructor, instead you can use it directly as a value. Represents a missing value.\n *\n * @category constructors\n * @since 2.0.0\n */\nexports.none = _.none;\n/**\n * Constructs a `Some`. Represents an optional value that exists.\n *\n * @category constructors\n * @since 2.0.0\n */\nexports.some = _.some;\nfunction fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? (0, exports.some)(a) : exports.none); };\n}\n/**\n * Returns the `Left` value of an `Either` if possible.\n *\n * @example\n * import { getLeft, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getLeft(right(1)), none)\n * assert.deepStrictEqual(getLeft(left('a')), some('a'))\n *\n * @category constructors\n * @since 2.0.0\n */\nvar getLeft = function (ma) { return (ma._tag === 'Right' ? exports.none : (0, exports.some)(ma.left)); };\nexports.getLeft = getLeft;\n/**\n * Returns the `Right` value of an `Either` if possible.\n *\n * @example\n * import { getRight, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getRight(right(1)), some(1))\n * assert.deepStrictEqual(getRight(left('a')), none)\n *\n * @category constructors\n * @since 2.0.0\n */\nvar getRight = function (ma) { return (ma._tag === 'Left' ? exports.none : (0, exports.some)(ma.right)); };\nexports.getRight = getRight;\nvar _map = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.map)(f)); };\nvar _ap = function (fab, fa) { return (0, function_1.pipe)(fab, (0, exports.ap)(fa)); };\nvar _reduce = function (fa, b, f) { return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f)); };\nvar _foldMap = function (M) {\n    var foldMapM = (0, exports.foldMap)(M);\n    return function (fa, f) { return (0, function_1.pipe)(fa, foldMapM(f)); };\n};\nvar _reduceRight = function (fa, b, f) { return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f)); };\nvar _traverse = function (F) {\n    var traverseF = (0, exports.traverse)(F);\n    return function (ta, f) { return (0, function_1.pipe)(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return (0, function_1.pipe)(fa, (0, exports.alt)(that)); };\nvar _filter = function (fa, predicate) { return (0, function_1.pipe)(fa, (0, exports.filter)(predicate)); };\n/* istanbul ignore next */\nvar _filterMap = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.filterMap)(f)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return (0, function_1.pipe)(wa, (0, exports.extend)(f)); };\n/* istanbul ignore next */\nvar _partition = function (fa, predicate) {\n    return (0, function_1.pipe)(fa, (0, exports.partition)(predicate));\n};\n/* istanbul ignore next */\nvar _partitionMap = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.partitionMap)(f)); };\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexports.URI = 'Option';\n/**\n * @category instances\n * @since 2.0.0\n */\nvar getShow = function (S) { return ({\n    show: function (ma) { return ((0, exports.isNone)(ma) ? 'none' : \"some(\".concat(S.show(ma.value), \")\")); }\n}); };\nexports.getShow = getShow;\n/**\n * @example\n * import { none, some, getEq } from 'fp-ts/Option'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals(none, none), true)\n * assert.strictEqual(E.equals(none, some(1)), false)\n * assert.strictEqual(E.equals(some(1), none), false)\n * assert.strictEqual(E.equals(some(1), some(2)), false)\n * assert.strictEqual(E.equals(some(1), some(1)), true)\n *\n * @category instances\n * @since 2.0.0\n */\nvar getEq = function (E) { return ({\n    equals: function (x, y) { return x === y || ((0, exports.isNone)(x) ? (0, exports.isNone)(y) : (0, exports.isNone)(y) ? false : E.equals(x.value, y.value)); }\n}); };\nexports.getEq = getEq;\n/**\n * The `Ord` instance allows `Option` values to be compared with\n * `compare`, whenever there is an `Ord` instance for\n * the type the `Option` contains.\n *\n * `None` is considered to be less than any `Some` value.\n *\n *\n * @example\n * import { none, some, getOrd } from 'fp-ts/Option'\n * import * as N from 'fp-ts/number'\n *\n * const O = getOrd(N.Ord)\n * assert.strictEqual(O.compare(none, none), 0)\n * assert.strictEqual(O.compare(none, some(1)), -1)\n * assert.strictEqual(O.compare(some(1), none), 1)\n * assert.strictEqual(O.compare(some(1), some(2)), -1)\n * assert.strictEqual(O.compare(some(1), some(1)), 0)\n *\n * @category instances\n * @since 2.0.0\n */\nvar getOrd = function (O) { return ({\n    equals: (0, exports.getEq)(O).equals,\n    compare: function (x, y) { return (x === y ? 0 : (0, exports.isSome)(x) ? ((0, exports.isSome)(y) ? O.compare(x.value, y.value) : 1) : -1); }\n}); };\nexports.getOrd = getOrd;\n/**\n * Monoid returning the left-most non-`None` value. If both operands are `Some`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | some(a)            |\n * | none    | some(b) | some(b)            |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getMonoid, some, none } from 'fp-ts/Option'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const M = getMonoid(SemigroupSum)\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(3))\n *\n * @category instances\n * @since 2.0.0\n */\nvar getMonoid = function (S) { return ({\n    concat: function (x, y) { return ((0, exports.isNone)(x) ? y : (0, exports.isNone)(y) ? x : (0, exports.some)(S.concat(x.value, y.value))); },\n    empty: exports.none\n}); };\nexports.getMonoid = getMonoid;\n/**\n * @category mapping\n * @since 2.0.0\n */\nvar map = function (f) { return function (fa) {\n    return (0, exports.isNone)(fa) ? exports.none : (0, exports.some)(f(fa.value));\n}; };\nexports.map = map;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Functor = {\n    URI: exports.URI,\n    map: _map\n};\n/**\n * Maps the `Some` value of this `Option` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexports.as = (0, function_1.dual)(2, (0, Functor_1.as)(exports.Functor));\n/**\n * Maps the `Some` value of this `Option` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexports.asUnit = (0, Functor_1.asUnit)(exports.Functor);\n/**\n * @category constructors\n * @since 2.7.0\n */\nexports.of = exports.some;\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.Pointed = {\n    URI: exports.URI,\n    of: exports.of\n};\n/**\n * @since 2.0.0\n */\nvar ap = function (fa) { return function (fab) {\n    return (0, exports.isNone)(fab) ? exports.none : (0, exports.isNone)(fa) ? exports.none : (0, exports.some)(fab.value(fa.value));\n}; };\nexports.ap = ap;\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.Apply = {\n    URI: exports.URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Applicative = {\n    URI: exports.URI,\n    map: _map,\n    ap: _ap,\n    of: exports.of\n};\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexports.flatMap = (0, function_1.dual)(2, function (ma, f) { return ((0, exports.isNone)(ma) ? exports.none : f(ma.value)); });\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.Chain = {\n    URI: exports.URI,\n    map: _map,\n    ap: _ap,\n    chain: exports.flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Monad = {\n    URI: exports.URI,\n    map: _map,\n    ap: _ap,\n    of: exports.of,\n    chain: exports.flatMap\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nvar reduce = function (b, f) { return function (fa) {\n    return (0, exports.isNone)(fa) ? b : f(b, fa.value);\n}; };\nexports.reduce = reduce;\n/**\n * @category folding\n * @since 2.0.0\n */\nvar foldMap = function (M) { return function (f) { return function (fa) {\n    return (0, exports.isNone)(fa) ? M.empty : f(fa.value);\n}; }; };\nexports.foldMap = foldMap;\n/**\n * @category folding\n * @since 2.0.0\n */\nvar reduceRight = function (b, f) { return function (fa) {\n    return (0, exports.isNone)(fa) ? b : f(fa.value, b);\n}; };\nexports.reduceRight = reduceRight;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Foldable = {\n    URI: exports.URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * Returns the provided `Option` `that` if `self` is `None`, otherwise returns `self`.\n *\n * @param self - The first `Option` to be checked.\n * @param that - The `Option` to return if `self` is `None`.\n *\n * @example\n * import * as O from \"fp-ts/Option\"\n *\n * assert.deepStrictEqual(O.orElse(O.none, () => O.none), O.none)\n * assert.deepStrictEqual(O.orElse(O.some(1), () => O.none), O.some(1))\n * assert.deepStrictEqual(O.orElse(O.none, () => O.some('b')), O.some('b'))\n * assert.deepStrictEqual(O.orElse(O.some(1), () => O.some('b')), O.some(1))\n *\n * @category error handling\n * @since 2.16.0\n */\nexports.orElse = (0, function_1.dual)(2, function (self, that) { return ((0, exports.isNone)(self) ? that() : self); });\n/**\n * Alias of `orElse`.\n *\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category legacy\n * @since 2.9.0\n */\nexports.altW = exports.orElse;\n/**\n * Alias of `orElse`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexports.alt = exports.orElse;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Alt = {\n    URI: exports.URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @since 2.7.0\n */\nvar zero = function () { return exports.none; };\nexports.zero = zero;\n/**\n * @category instances\n * @since 2.11.0\n */\nexports.Zero = {\n    URI: exports.URI,\n    zero: exports.zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexports.guard = (0, Zero_1.guard)(exports.Zero, exports.Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Alternative = {\n    URI: exports.URI,\n    map: _map,\n    ap: _ap,\n    of: exports.of,\n    alt: _alt,\n    zero: exports.zero\n};\n/**\n * @since 2.0.0\n */\nvar extend = function (f) { return function (wa) {\n    return (0, exports.isNone)(wa) ? exports.none : (0, exports.some)(f(wa));\n}; };\nexports.extend = extend;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Extend = {\n    URI: exports.URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexports.compact = (0, exports.flatMap)(function_1.identity);\nvar defaultSeparated = /*#__PURE__*/ (0, Separated_1.separated)(exports.none, exports.none);\n/**\n * @category filtering\n * @since 2.0.0\n */\nvar separate = function (ma) {\n    return (0, exports.isNone)(ma) ? defaultSeparated : (0, Separated_1.separated)((0, exports.getLeft)(ma.value), (0, exports.getRight)(ma.value));\n};\nexports.separate = separate;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Compactable = {\n    URI: exports.URI,\n    compact: exports.compact,\n    separate: exports.separate\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nvar filter = function (predicate) {\n    return function (fa) {\n        return (0, exports.isNone)(fa) ? exports.none : predicate(fa.value) ? fa : exports.none;\n    };\n};\nexports.filter = filter;\n/**\n * @category filtering\n * @since 2.0.0\n */\nvar filterMap = function (f) { return function (fa) {\n    return (0, exports.isNone)(fa) ? exports.none : f(fa.value);\n}; };\nexports.filterMap = filterMap;\n/**\n * @category filtering\n * @since 2.0.0\n */\nvar partition = function (predicate) {\n    return function (fa) {\n        return (0, Separated_1.separated)(_filter(fa, (0, Predicate_1.not)(predicate)), _filter(fa, predicate));\n    };\n};\nexports.partition = partition;\n/**\n * @category filtering\n * @since 2.0.0\n */\nvar partitionMap = function (f) { return (0, function_1.flow)((0, exports.map)(f), exports.separate); };\nexports.partitionMap = partitionMap;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Filterable = {\n    URI: exports.URI,\n    map: _map,\n    compact: exports.compact,\n    separate: exports.separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nvar traverse = function (F) {\n    return function (f) {\n        return function (ta) {\n            return (0, exports.isNone)(ta) ? F.of(exports.none) : F.map(f(ta.value), exports.some);\n        };\n    };\n};\nexports.traverse = traverse;\n/**\n * @category traversing\n * @since 2.6.3\n */\nvar sequence = function (F) {\n    return function (ta) {\n        return (0, exports.isNone)(ta) ? F.of(exports.none) : F.map(ta.value, exports.some);\n    };\n};\nexports.sequence = sequence;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Traversable = {\n    URI: exports.URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: exports.sequence\n};\nvar _wither = /*#__PURE__*/ (0, Witherable_1.witherDefault)(exports.Traversable, exports.Compactable);\nvar _wilt = /*#__PURE__*/ (0, Witherable_1.wiltDefault)(exports.Traversable, exports.Compactable);\n/**\n * @category filtering\n * @since 2.6.5\n */\nvar wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\nexports.wither = wither;\n/**\n * @category filtering\n * @since 2.6.5\n */\nvar wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\nexports.wilt = wilt;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Witherable = {\n    URI: exports.URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: exports.sequence,\n    compact: exports.compact,\n    separate: exports.separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * @since 2.7.0\n */\nvar throwError = function () { return exports.none; };\nexports.throwError = throwError;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.MonadThrow = {\n    URI: exports.URI,\n    map: _map,\n    ap: _ap,\n    of: exports.of,\n    chain: exports.flatMap,\n    throwError: exports.throwError\n};\n/**\n * Transforms an `Either` to an `Option` discarding the error.\n *\n * Alias of [getRight](#getright)\n *\n * @category conversions\n * @since 2.0.0\n */\nexports.fromEither = exports.getRight;\n/**\n * @category instances\n * @since 2.11.0\n */\nexports.FromEither = {\n    URI: exports.URI,\n    fromEither: exports.fromEither\n};\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the option is an instance of `Some`, `false` otherwise.\n *\n * @example\n * import { some, none, isSome } from 'fp-ts/Option'\n *\n * assert.strictEqual(isSome(some(1)), true)\n * assert.strictEqual(isSome(none), false)\n *\n * @category refinements\n * @since 2.0.0\n */\nexports.isSome = _.isSome;\n/**\n * Returns `true` if the option is `None`, `false` otherwise.\n *\n * @example\n * import { some, none, isNone } from 'fp-ts/Option'\n *\n * assert.strictEqual(isNone(some(1)), false)\n * assert.strictEqual(isNone(none), true)\n *\n * @category refinements\n * @since 2.0.0\n */\nvar isNone = function (fa) { return fa._tag === 'None'; };\nexports.isNone = isNone;\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nvar matchW = function (onNone, onSome) {\n    return function (ma) {\n        return (0, exports.isNone)(ma) ? onNone() : onSome(ma.value);\n    };\n};\nexports.matchW = matchW;\n/**\n * Alias of [`matchW`](#matchw).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexports.foldW = exports.matchW;\n/**\n * Takes a (lazy) default value, a function, and an `Option` value, if the `Option` value is `None` the default value is\n * returned, otherwise the function is applied to the value inside the `Some` and the result is returned.\n *\n * @example\n * import { some, none, match } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     match(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a some containing 1'\n * )\n *\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     match(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a none'\n * )\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexports.match = exports.matchW;\n/**\n * Alias of [`match`](#match).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexports.fold = exports.match;\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nvar getOrElseW = function (onNone) {\n    return function (ma) {\n        return (0, exports.isNone)(ma) ? onNone() : ma.value;\n    };\n};\nexports.getOrElseW = getOrElseW;\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns the given default value\n *\n * @example\n * import { some, none, getOrElse } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexports.getOrElse = exports.getOrElseW;\n/**\n * @category mapping\n * @since 2.10.0\n */\nexports.flap = (0, Functor_1.flap)(exports.Functor);\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexports.apFirst = (0, Apply_1.apFirst)(exports.Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexports.apSecond = (0, Apply_1.apSecond)(exports.Apply);\n/**\n * @category sequencing\n * @since 2.0.0\n */\nexports.flatten = exports.compact;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexports.tap = (0, function_1.dual)(2, chainable.tap(exports.Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n * import * as E from 'fp-ts/Either'\n *\n * const compute = (value: number) => pipe(\n *   O.of(value),\n *   O.tapEither((value) => value > 0 ? E.right('ok') : E.left('error')),\n * )\n *\n * assert.deepStrictEqual(compute(1), O.of(1))\n * assert.deepStrictEqual(compute(-42), O.none)\n *\n * @category combinators\n * @since 2.16.0\n */\nexports.tapEither = (0, function_1.dual)(2, (0, FromEither_1.tapEither)(exports.FromEither, exports.Chain));\n/**\n * @since 2.0.0\n */\nexports.duplicate = (0, exports.extend)(function_1.identity);\n/**\n * @category lifting\n * @since 2.11.0\n */\nexports.fromEitherK = (0, FromEither_1.fromEitherK)(exports.FromEither);\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexports.chainEitherK = \n/*#__PURE__*/ (0, FromEither_1.chainEitherK)(exports.FromEither, exports.Chain);\n/**\n * Alias of `tapEither`.\n *\n * @category legacy\n * @since 2.12.0\n */\nexports.chainFirstEitherK = exports.tapEither;\n/**\n * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise\n * returns the value wrapped in a `Some`.\n *\n * @example\n * import { none, some, fromNullable } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(fromNullable(undefined), none)\n * assert.deepStrictEqual(fromNullable(null), none)\n * assert.deepStrictEqual(fromNullable(1), some(1))\n *\n * @category conversions\n * @since 2.0.0\n */\nvar fromNullable = function (a) { return (a == null ? exports.none : (0, exports.some)(a)); };\nexports.fromNullable = fromNullable;\n/**\n * Transforms an exception into an `Option`. If `f` throws, returns `None`, otherwise returns the output wrapped in a\n * `Some`.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import { none, some, tryCatch } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   tryCatch(() => {\n *     throw new Error()\n *   }),\n *   none\n * )\n * assert.deepStrictEqual(tryCatch(() => 1), some(1))\n *\n * @category interop\n * @since 2.0.0\n */\nvar tryCatch = function (f) {\n    try {\n        return (0, exports.some)(f());\n    }\n    catch (e) {\n        return exports.none;\n    }\n};\nexports.tryCatch = tryCatch;\n/**\n * Converts a function that may throw to one returning a `Option`.\n *\n * @category interop\n * @since 2.10.0\n */\nvar tryCatchK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return (0, exports.tryCatch)(function () { return f.apply(void 0, a); });\n    };\n};\nexports.tryCatchK = tryCatchK;\n/**\n * Returns a *smart constructor* from a function that returns a nullable value.\n *\n * @example\n * import { fromNullableK, none, some } from 'fp-ts/Option'\n *\n * const f = (s: string): number | undefined => {\n *   const n = parseFloat(s)\n *   return isNaN(n) ? undefined : n\n * }\n *\n * const g = fromNullableK(f)\n *\n * assert.deepStrictEqual(g('1'), some(1))\n * assert.deepStrictEqual(g('a'), none)\n *\n * @category lifting\n * @since 2.9.0\n */\nvar fromNullableK = function (f) { return (0, function_1.flow)(f, exports.fromNullable); };\nexports.fromNullableK = fromNullableK;\n/**\n * This is `chain` + `fromNullable`, useful when working with optional values.\n *\n * @example\n * import { some, none, fromNullable, chainNullableK } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Employee {\n *   readonly company?: {\n *     readonly address?: {\n *       readonly street?: {\n *         readonly name?: string\n *       }\n *     }\n *   }\n * }\n *\n * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee1.company),\n *     chainNullableK(company => company.address),\n *     chainNullableK(address => address.street),\n *     chainNullableK(street => street.name)\n *   ),\n *   some('high street')\n * )\n *\n * const employee2: Employee = { company: { address: { street: {} } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee2.company),\n *     chainNullableK(company => company.address),\n *     chainNullableK(address => address.street),\n *     chainNullableK(street => street.name)\n *   ),\n *   none\n * )\n *\n * @category sequencing\n * @since 2.9.0\n */\nvar chainNullableK = function (f) {\n    return function (ma) {\n        return (0, exports.isNone)(ma) ? exports.none : (0, exports.fromNullable)(f(ma.value));\n    };\n};\nexports.chainNullableK = chainNullableK;\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `null`.\n *\n * @example\n * import { some, none, toNullable } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toNullable\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toNullable\n *   ),\n *   null\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexports.toNullable = (0, exports.match)(function_1.constNull, function_1.identity);\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `undefined`.\n *\n * @example\n * import { some, none, toUndefined } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toUndefined\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toUndefined\n *   ),\n *   undefined\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexports.toUndefined = (0, exports.match)(function_1.constUndefined, function_1.identity);\nfunction elem(E) {\n    return function (a, ma) {\n        if (ma === undefined) {\n            var elemE_1 = elem(E);\n            return function (ma) { return elemE_1(a, ma); };\n        }\n        return (0, exports.isNone)(ma) ? false : E.equals(a, ma.value);\n    };\n}\n/**\n * Returns `true` if the predicate is satisfied by the wrapped value\n *\n * @example\n * import { some, none, exists } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 0)\n *   ),\n *   true\n * )\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 1)\n *   ),\n *   false\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     exists(n => n > 0)\n *   ),\n *   false\n * )\n *\n * @since 2.0.0\n */\nvar exists = function (predicate) {\n    return function (ma) {\n        return (0, exports.isNone)(ma) ? false : predicate(ma.value);\n    };\n};\nexports.exists = exists;\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexports.Do = (0, exports.of)(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexports.bindTo = (0, Functor_1.bindTo)(exports.Functor);\nvar let_ = /*#__PURE__*/ (0, Functor_1.let)(exports.Functor);\nexports[\"let\"] = let_;\n/**\n * @category do notation\n * @since 2.8.0\n */\nexports.bind = chainable.bind(exports.Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexports.apS = (0, Apply_1.apS)(exports.Apply);\n/**\n * @since 2.11.0\n */\nexports.ApT = (0, exports.of)(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nvar traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        var o = f(0, _.head(as));\n        if ((0, exports.isNone)(o)) {\n            return exports.none;\n        }\n        var out = [o.value];\n        for (var i = 1; i < as.length; i++) {\n            var o_1 = f(i, as[i]);\n            if ((0, exports.isNone)(o_1)) {\n                return exports.none;\n            }\n            out.push(o_1.value);\n        }\n        return (0, exports.some)(out);\n    };\n};\nexports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nvar traverseReadonlyArrayWithIndex = function (f) {\n    var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : exports.ApT); };\n};\nexports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nvar traverseArray = function (f) {\n    return (0, exports.traverseReadonlyArrayWithIndex)(function (_, a) { return f(a); });\n};\nexports.traverseArray = traverseArray;\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexports.sequenceArray = \n/*#__PURE__*/ (0, exports.traverseArray)(function_1.identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexports.chain = exports.flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexports.chainFirst = exports.tap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `Refinement` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nfunction getRefinement(getOption) {\n    return function (a) { return (0, exports.isSome)(getOption(a)); };\n}\n/**\n * Use [`chainNullableK`](#chainnullablek) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.mapNullable = exports.chainNullableK;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `O.Functor` instead of `O.option`\n * (where `O` is from `import O from 'fp-ts/Option'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.option = {\n    URI: exports.URI,\n    map: _map,\n    of: exports.of,\n    ap: _ap,\n    chain: exports.flatMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: exports.sequence,\n    zero: exports.zero,\n    alt: _alt,\n    extend: _extend,\n    compact: exports.compact,\n    separate: exports.separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt,\n    throwError: exports.throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getApplySemigroup = (0, Apply_1.getApplySemigroup)(exports.Apply);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getApplyMonoid = (0, Applicative_1.getApplicativeMonoid)(exports.Applicative);\n/**\n * Use\n *\n * ```ts\n * import { first } from 'fp-ts/Semigroup'\n * import { getMonoid } from 'fp-ts/Option'\n *\n * getMonoid(first())\n * ```\n *\n * instead.\n *\n * Monoid returning the left-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(b) | some(b)      |\n * | some(a) | some(b) | some(a)      |\n *\n * @example\n * import { getFirstMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getFirstMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(2)), some(2))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(1))\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nvar getFirstMonoid = function () { return (0, exports.getMonoid)((0, Semigroup_1.first)()); };\nexports.getFirstMonoid = getFirstMonoid;\n/**\n * Use\n *\n * ```ts\n * import { last } from 'fp-ts/Semigroup'\n * import { getMonoid } from 'fp-ts/Option'\n *\n * getMonoid(last())\n * ```\n *\n * instead.\n *\n * Monoid returning the right-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(b) | some(b)      |\n * | some(a) | some(b) | some(b)      |\n *\n * @example\n * import { getLastMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getLastMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(2)), some(2))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(2))\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nvar getLastMonoid = function () { return (0, exports.getMonoid)((0, Semigroup_1.last)()); };\nexports.getLastMonoid = getLastMonoid;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcC10cy9saWIvT3B0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyxrQkFBa0IsR0FBRyxZQUFZLEdBQUcsY0FBYyxHQUFHLG1CQUFtQixHQUFHLGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLGtCQUFrQixHQUFHLG9CQUFvQixHQUFHLGlCQUFpQixHQUFHLGlCQUFpQixHQUFHLGNBQWMsR0FBRyxtQkFBbUIsR0FBRyxnQkFBZ0IsR0FBRyxlQUFlLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxtQkFBbUIsR0FBRyxhQUFhLEdBQUcsWUFBWSxHQUFHLFlBQVksR0FBRyxXQUFXLEdBQUcsV0FBVyxHQUFHLFlBQVksR0FBRyxjQUFjLEdBQUcsZ0JBQWdCLEdBQUcsbUJBQW1CLEdBQUcsZUFBZSxHQUFHLGNBQWMsR0FBRyxhQUFhLEdBQUcsYUFBYSxHQUFHLGVBQWUsR0FBRyxtQkFBbUIsR0FBRyxhQUFhLEdBQUcsVUFBVSxHQUFHLGVBQWUsR0FBRyxVQUFVLEdBQUcsY0FBYyxHQUFHLFVBQVUsR0FBRyxlQUFlLEdBQUcsV0FBVyxHQUFHLGlCQUFpQixHQUFHLGNBQWMsR0FBRyxhQUFhLEdBQUcsZUFBZSxHQUFHLFdBQVcsR0FBRyxnQkFBZ0IsR0FBRyxlQUFlLEdBQUcsWUFBWSxHQUFHLFlBQVk7QUFDMzJCLHFCQUFxQixHQUFHLHNCQUFzQixHQUFHLHNCQUFzQixHQUFHLHlCQUF5QixHQUFHLGNBQWMsR0FBRyxtQkFBbUIsR0FBRyxrQkFB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Q0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLHFCQUFxQiIsInNvdXJjZXMiOlsiSTpcXFNjYWxhQ3Vyc292YXlhXFxCdW5rZXJXZWJcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXGZwLXRzXFxsaWJcXE9wdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50aHJvd0Vycm9yID0gZXhwb3J0cy5XaXRoZXJhYmxlID0gZXhwb3J0cy53aWx0ID0gZXhwb3J0cy53aXRoZXIgPSBleHBvcnRzLlRyYXZlcnNhYmxlID0gZXhwb3J0cy5zZXF1ZW5jZSA9IGV4cG9ydHMudHJhdmVyc2UgPSBleHBvcnRzLkZpbHRlcmFibGUgPSBleHBvcnRzLnBhcnRpdGlvbk1hcCA9IGV4cG9ydHMucGFydGl0aW9uID0gZXhwb3J0cy5maWx0ZXJNYXAgPSBleHBvcnRzLmZpbHRlciA9IGV4cG9ydHMuQ29tcGFjdGFibGUgPSBleHBvcnRzLnNlcGFyYXRlID0gZXhwb3J0cy5jb21wYWN0ID0gZXhwb3J0cy5FeHRlbmQgPSBleHBvcnRzLmV4dGVuZCA9IGV4cG9ydHMuQWx0ZXJuYXRpdmUgPSBleHBvcnRzLmd1YXJkID0gZXhwb3J0cy5aZXJvID0gZXhwb3J0cy56ZXJvID0gZXhwb3J0cy5BbHQgPSBleHBvcnRzLmFsdCA9IGV4cG9ydHMuYWx0VyA9IGV4cG9ydHMub3JFbHNlID0gZXhwb3J0cy5Gb2xkYWJsZSA9IGV4cG9ydHMucmVkdWNlUmlnaHQgPSBleHBvcnRzLmZvbGRNYXAgPSBleHBvcnRzLnJlZHVjZSA9IGV4cG9ydHMuTW9uYWQgPSBleHBvcnRzLkNoYWluID0gZXhwb3J0cy5mbGF0TWFwID0gZXhwb3J0cy5BcHBsaWNhdGl2ZSA9IGV4cG9ydHMuQXBwbHkgPSBleHBvcnRzLmFwID0gZXhwb3J0cy5Qb2ludGVkID0gZXhwb3J0cy5vZiA9IGV4cG9ydHMuYXNVbml0ID0gZXhwb3J0cy5hcyA9IGV4cG9ydHMuRnVuY3RvciA9IGV4cG9ydHMubWFwID0gZXhwb3J0cy5nZXRNb25vaWQgPSBleHBvcnRzLmdldE9yZCA9IGV4cG9ydHMuZ2V0RXEgPSBleHBvcnRzLmdldFNob3cgPSBleHBvcnRzLlVSSSA9IGV4cG9ydHMuZ2V0UmlnaHQgPSBleHBvcnRzLmdldExlZnQgPSBleHBvcnRzLnNvbWUgPSBleHBvcnRzLm5vbmUgPSB2b2lkIDA7XG5leHBvcnRzLmdldExhc3RNb25vaWQgPSBleHBvcnRzLmdldEZpcnN0TW9ub2lkID0gZXhwb3J0cy5nZXRBcHBseU1vbm9pZCA9IGV4cG9ydHMuZ2V0QXBwbHlTZW1pZ3JvdXAgPSBleHBvcnRzLm9wdGlvbiA9IGV4cG9ydHMubWFwTnVsbGFibGUgPSBleHBvcnRzLmNoYWluRmlyc3QgPSBleHBvcnRzLmNoYWluID0gZXhwb3J0cy5zZXF1ZW5jZUFycmF5ID0gZXhwb3J0cy50cmF2ZXJzZUFycmF5ID0gZXhwb3J0cy50cmF2ZXJzZUFycmF5V2l0aEluZGV4ID0gZXhwb3J0cy50cmF2ZXJzZVJlYWRvbmx5QXJyYXlXaXRoSW5kZXggPSBleHBvcnRzLnRyYXZlcnNlUmVhZG9ubHlOb25FbXB0eUFycmF5V2l0aEluZGV4ID0gZXhwb3J0cy5BcFQgPSBleHBvcnRzLmFwUyA9IGV4cG9ydHMuYmluZCA9IGV4cG9ydHMubGV0ID0gZXhwb3J0cy5iaW5kVG8gPSBleHBvcnRzLkRvID0gZXhwb3J0cy5leGlzdHMgPSBleHBvcnRzLnRvVW5kZWZpbmVkID0gZXhwb3J0cy50b051bGxhYmxlID0gZXhwb3J0cy5jaGFpbk51bGxhYmxlSyA9IGV4cG9ydHMuZnJvbU51bGxhYmxlSyA9IGV4cG9ydHMudHJ5Q2F0Y2hLID0gZXhwb3J0cy50cnlDYXRjaCA9IGV4cG9ydHMuZnJvbU51bGxhYmxlID0gZXhwb3J0cy5jaGFpbkZpcnN0RWl0aGVySyA9IGV4cG9ydHMuY2hhaW5FaXRoZXJLID0gZXhwb3J0cy5mcm9tRWl0aGVySyA9IGV4cG9ydHMuZHVwbGljYXRlID0gZXhwb3J0cy50YXBFaXRoZXIgPSBleHBvcnRzLnRhcCA9IGV4cG9ydHMuZmxhdHRlbiA9IGV4cG9ydHMuYXBTZWNvbmQgPSBleHBvcnRzLmFwRmlyc3QgPSBleHBvcnRzLmZsYXAgPSBleHBvcnRzLmdldE9yRWxzZSA9IGV4cG9ydHMuZ2V0T3JFbHNlVyA9IGV4cG9ydHMuZm9sZCA9IGV4cG9ydHMubWF0Y2ggPSBleHBvcnRzLmZvbGRXID0gZXhwb3J0cy5tYXRjaFcgPSBleHBvcnRzLmlzTm9uZSA9IGV4cG9ydHMuaXNTb21lID0gZXhwb3J0cy5Gcm9tRWl0aGVyID0gZXhwb3J0cy5mcm9tRWl0aGVyID0gZXhwb3J0cy5Nb25hZFRocm93ID0gdm9pZCAwO1xuZXhwb3J0cy5mcm9tUHJlZGljYXRlID0gZnJvbVByZWRpY2F0ZTtcbmV4cG9ydHMuZWxlbSA9IGVsZW07XG5leHBvcnRzLmdldFJlZmluZW1lbnQgPSBnZXRSZWZpbmVtZW50O1xudmFyIEFwcGxpY2F0aXZlXzEgPSByZXF1aXJlKFwiLi9BcHBsaWNhdGl2ZVwiKTtcbnZhciBBcHBseV8xID0gcmVxdWlyZShcIi4vQXBwbHlcIik7XG52YXIgY2hhaW5hYmxlID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL0NoYWluXCIpKTtcbnZhciBGcm9tRWl0aGVyXzEgPSByZXF1aXJlKFwiLi9Gcm9tRWl0aGVyXCIpO1xudmFyIGZ1bmN0aW9uXzEgPSByZXF1aXJlKFwiLi9mdW5jdGlvblwiKTtcbnZhciBGdW5jdG9yXzEgPSByZXF1aXJlKFwiLi9GdW5jdG9yXCIpO1xudmFyIF8gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vaW50ZXJuYWxcIikpO1xudmFyIFByZWRpY2F0ZV8xID0gcmVxdWlyZShcIi4vUHJlZGljYXRlXCIpO1xudmFyIFNlbWlncm91cF8xID0gcmVxdWlyZShcIi4vU2VtaWdyb3VwXCIpO1xudmFyIFNlcGFyYXRlZF8xID0gcmVxdWlyZShcIi4vU2VwYXJhdGVkXCIpO1xudmFyIFdpdGhlcmFibGVfMSA9IHJlcXVpcmUoXCIuL1dpdGhlcmFibGVcIik7XG52YXIgWmVyb18xID0gcmVxdWlyZShcIi4vWmVyb1wiKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGNvbnN0cnVjdG9yc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBgTm9uZWAgZG9lc24ndCBoYXZlIGEgY29uc3RydWN0b3IsIGluc3RlYWQgeW91IGNhbiB1c2UgaXQgZGlyZWN0bHkgYXMgYSB2YWx1ZS4gUmVwcmVzZW50cyBhIG1pc3NpbmcgdmFsdWUuXG4gKlxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydHMubm9uZSA9IF8ubm9uZTtcbi8qKlxuICogQ29uc3RydWN0cyBhIGBTb21lYC4gUmVwcmVzZW50cyBhbiBvcHRpb25hbCB2YWx1ZSB0aGF0IGV4aXN0cy5cbiAqXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0cy5zb21lID0gXy5zb21lO1xuZnVuY3Rpb24gZnJvbVByZWRpY2F0ZShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIChwcmVkaWNhdGUoYSkgPyAoMCwgZXhwb3J0cy5zb21lKShhKSA6IGV4cG9ydHMubm9uZSk7IH07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGBMZWZ0YCB2YWx1ZSBvZiBhbiBgRWl0aGVyYCBpZiBwb3NzaWJsZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgZ2V0TGVmdCwgbm9uZSwgc29tZSB9IGZyb20gJ2ZwLXRzL09wdGlvbidcbiAqIGltcG9ydCB7IHJpZ2h0LCBsZWZ0IH0gZnJvbSAnZnAtdHMvRWl0aGVyJ1xuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoZ2V0TGVmdChyaWdodCgxKSksIG5vbmUpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGdldExlZnQobGVmdCgnYScpKSwgc29tZSgnYScpKVxuICpcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG52YXIgZ2V0TGVmdCA9IGZ1bmN0aW9uIChtYSkgeyByZXR1cm4gKG1hLl90YWcgPT09ICdSaWdodCcgPyBleHBvcnRzLm5vbmUgOiAoMCwgZXhwb3J0cy5zb21lKShtYS5sZWZ0KSk7IH07XG5leHBvcnRzLmdldExlZnQgPSBnZXRMZWZ0O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBgUmlnaHRgIHZhbHVlIG9mIGFuIGBFaXRoZXJgIGlmIHBvc3NpYmxlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBnZXRSaWdodCwgbm9uZSwgc29tZSB9IGZyb20gJ2ZwLXRzL09wdGlvbidcbiAqIGltcG9ydCB7IHJpZ2h0LCBsZWZ0IH0gZnJvbSAnZnAtdHMvRWl0aGVyJ1xuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoZ2V0UmlnaHQocmlnaHQoMSkpLCBzb21lKDEpKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChnZXRSaWdodChsZWZ0KCdhJykpLCBub25lKVxuICpcbiAqIEBjYXRlZ29yeSBjb25zdHJ1Y3RvcnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG52YXIgZ2V0UmlnaHQgPSBmdW5jdGlvbiAobWEpIHsgcmV0dXJuIChtYS5fdGFnID09PSAnTGVmdCcgPyBleHBvcnRzLm5vbmUgOiAoMCwgZXhwb3J0cy5zb21lKShtYS5yaWdodCkpOyB9O1xuZXhwb3J0cy5nZXRSaWdodCA9IGdldFJpZ2h0O1xudmFyIF9tYXAgPSBmdW5jdGlvbiAoZmEsIGYpIHsgcmV0dXJuICgwLCBmdW5jdGlvbl8xLnBpcGUpKGZhLCAoMCwgZXhwb3J0cy5tYXApKGYpKTsgfTtcbnZhciBfYXAgPSBmdW5jdGlvbiAoZmFiLCBmYSkgeyByZXR1cm4gKDAsIGZ1bmN0aW9uXzEucGlwZSkoZmFiLCAoMCwgZXhwb3J0cy5hcCkoZmEpKTsgfTtcbnZhciBfcmVkdWNlID0gZnVuY3Rpb24gKGZhLCBiLCBmKSB7IHJldHVybiAoMCwgZnVuY3Rpb25fMS5waXBlKShmYSwgKDAsIGV4cG9ydHMucmVkdWNlKShiLCBmKSk7IH07XG52YXIgX2ZvbGRNYXAgPSBmdW5jdGlvbiAoTSkge1xuICAgIHZhciBmb2xkTWFwTSA9ICgwLCBleHBvcnRzLmZvbGRNYXApKE0pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZmEsIGYpIHsgcmV0dXJuICgwLCBmdW5jdGlvbl8xLnBpcGUpKGZhLCBmb2xkTWFwTShmKSk7IH07XG59O1xudmFyIF9yZWR1Y2VSaWdodCA9IGZ1bmN0aW9uIChmYSwgYiwgZikgeyByZXR1cm4gKDAsIGZ1bmN0aW9uXzEucGlwZSkoZmEsICgwLCBleHBvcnRzLnJlZHVjZVJpZ2h0KShiLCBmKSk7IH07XG52YXIgX3RyYXZlcnNlID0gZnVuY3Rpb24gKEYpIHtcbiAgICB2YXIgdHJhdmVyc2VGID0gKDAsIGV4cG9ydHMudHJhdmVyc2UpKEYpO1xuICAgIHJldHVybiBmdW5jdGlvbiAodGEsIGYpIHsgcmV0dXJuICgwLCBmdW5jdGlvbl8xLnBpcGUpKHRhLCB0cmF2ZXJzZUYoZikpOyB9O1xufTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG52YXIgX2FsdCA9IGZ1bmN0aW9uIChmYSwgdGhhdCkgeyByZXR1cm4gKDAsIGZ1bmN0aW9uXzEucGlwZSkoZmEsICgwLCBleHBvcnRzLmFsdCkodGhhdCkpOyB9O1xudmFyIF9maWx0ZXIgPSBmdW5jdGlvbiAoZmEsIHByZWRpY2F0ZSkgeyByZXR1cm4gKDAsIGZ1bmN0aW9uXzEucGlwZSkoZmEsICgwLCBleHBvcnRzLmZpbHRlcikocHJlZGljYXRlKSk7IH07XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xudmFyIF9maWx0ZXJNYXAgPSBmdW5jdGlvbiAoZmEsIGYpIHsgcmV0dXJuICgwLCBmdW5jdGlvbl8xLnBpcGUpKGZhLCAoMCwgZXhwb3J0cy5maWx0ZXJNYXApKGYpKTsgfTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG52YXIgX2V4dGVuZCA9IGZ1bmN0aW9uICh3YSwgZikgeyByZXR1cm4gKDAsIGZ1bmN0aW9uXzEucGlwZSkod2EsICgwLCBleHBvcnRzLmV4dGVuZCkoZikpOyB9O1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnZhciBfcGFydGl0aW9uID0gZnVuY3Rpb24gKGZhLCBwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gKDAsIGZ1bmN0aW9uXzEucGlwZSkoZmEsICgwLCBleHBvcnRzLnBhcnRpdGlvbikocHJlZGljYXRlKSk7XG59O1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnZhciBfcGFydGl0aW9uTWFwID0gZnVuY3Rpb24gKGZhLCBmKSB7IHJldHVybiAoMCwgZnVuY3Rpb25fMS5waXBlKShmYSwgKDAsIGV4cG9ydHMucGFydGl0aW9uTWFwKShmKSk7IH07XG4vKipcbiAqIEBjYXRlZ29yeSB0eXBlIGxhbWJkYXNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnRzLlVSSSA9ICdPcHRpb24nO1xuLyoqXG4gKiBAY2F0ZWdvcnkgaW5zdGFuY2VzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xudmFyIGdldFNob3cgPSBmdW5jdGlvbiAoUykgeyByZXR1cm4gKHtcbiAgICBzaG93OiBmdW5jdGlvbiAobWEpIHsgcmV0dXJuICgoMCwgZXhwb3J0cy5pc05vbmUpKG1hKSA/ICdub25lJyA6IFwic29tZShcIi5jb25jYXQoUy5zaG93KG1hLnZhbHVlKSwgXCIpXCIpKTsgfVxufSk7IH07XG5leHBvcnRzLmdldFNob3cgPSBnZXRTaG93O1xuLyoqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgbm9uZSwgc29tZSwgZ2V0RXEgfSBmcm9tICdmcC10cy9PcHRpb24nXG4gKiBpbXBvcnQgKiBhcyBOIGZyb20gJ2ZwLXRzL251bWJlcidcbiAqXG4gKiBjb25zdCBFID0gZ2V0RXEoTi5FcSlcbiAqIGFzc2VydC5zdHJpY3RFcXVhbChFLmVxdWFscyhub25lLCBub25lKSwgdHJ1ZSlcbiAqIGFzc2VydC5zdHJpY3RFcXVhbChFLmVxdWFscyhub25lLCBzb21lKDEpKSwgZmFsc2UpXG4gKiBhc3NlcnQuc3RyaWN0RXF1YWwoRS5lcXVhbHMoc29tZSgxKSwgbm9uZSksIGZhbHNlKVxuICogYXNzZXJ0LnN0cmljdEVxdWFsKEUuZXF1YWxzKHNvbWUoMSksIHNvbWUoMikpLCBmYWxzZSlcbiAqIGFzc2VydC5zdHJpY3RFcXVhbChFLmVxdWFscyhzb21lKDEpLCBzb21lKDEpKSwgdHJ1ZSlcbiAqXG4gKiBAY2F0ZWdvcnkgaW5zdGFuY2VzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xudmFyIGdldEVxID0gZnVuY3Rpb24gKEUpIHsgcmV0dXJuICh7XG4gICAgZXF1YWxzOiBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geCA9PT0geSB8fCAoKDAsIGV4cG9ydHMuaXNOb25lKSh4KSA/ICgwLCBleHBvcnRzLmlzTm9uZSkoeSkgOiAoMCwgZXhwb3J0cy5pc05vbmUpKHkpID8gZmFsc2UgOiBFLmVxdWFscyh4LnZhbHVlLCB5LnZhbHVlKSk7IH1cbn0pOyB9O1xuZXhwb3J0cy5nZXRFcSA9IGdldEVxO1xuLyoqXG4gKiBUaGUgYE9yZGAgaW5zdGFuY2UgYWxsb3dzIGBPcHRpb25gIHZhbHVlcyB0byBiZSBjb21wYXJlZCB3aXRoXG4gKiBgY29tcGFyZWAsIHdoZW5ldmVyIHRoZXJlIGlzIGFuIGBPcmRgIGluc3RhbmNlIGZvclxuICogdGhlIHR5cGUgdGhlIGBPcHRpb25gIGNvbnRhaW5zLlxuICpcbiAqIGBOb25lYCBpcyBjb25zaWRlcmVkIHRvIGJlIGxlc3MgdGhhbiBhbnkgYFNvbWVgIHZhbHVlLlxuICpcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgbm9uZSwgc29tZSwgZ2V0T3JkIH0gZnJvbSAnZnAtdHMvT3B0aW9uJ1xuICogaW1wb3J0ICogYXMgTiBmcm9tICdmcC10cy9udW1iZXInXG4gKlxuICogY29uc3QgTyA9IGdldE9yZChOLk9yZClcbiAqIGFzc2VydC5zdHJpY3RFcXVhbChPLmNvbXBhcmUobm9uZSwgbm9uZSksIDApXG4gKiBhc3NlcnQuc3RyaWN0RXF1YWwoTy5jb21wYXJlKG5vbmUsIHNvbWUoMSkpLCAtMSlcbiAqIGFzc2VydC5zdHJpY3RFcXVhbChPLmNvbXBhcmUoc29tZSgxKSwgbm9uZSksIDEpXG4gKiBhc3NlcnQuc3RyaWN0RXF1YWwoTy5jb21wYXJlKHNvbWUoMSksIHNvbWUoMikpLCAtMSlcbiAqIGFzc2VydC5zdHJpY3RFcXVhbChPLmNvbXBhcmUoc29tZSgxKSwgc29tZSgxKSksIDApXG4gKlxuICogQGNhdGVnb3J5IGluc3RhbmNlc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbnZhciBnZXRPcmQgPSBmdW5jdGlvbiAoTykgeyByZXR1cm4gKHtcbiAgICBlcXVhbHM6ICgwLCBleHBvcnRzLmdldEVxKShPKS5lcXVhbHMsXG4gICAgY29tcGFyZTogZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuICh4ID09PSB5ID8gMCA6ICgwLCBleHBvcnRzLmlzU29tZSkoeCkgPyAoKDAsIGV4cG9ydHMuaXNTb21lKSh5KSA/IE8uY29tcGFyZSh4LnZhbHVlLCB5LnZhbHVlKSA6IDEpIDogLTEpOyB9XG59KTsgfTtcbmV4cG9ydHMuZ2V0T3JkID0gZ2V0T3JkO1xuLyoqXG4gKiBNb25vaWQgcmV0dXJuaW5nIHRoZSBsZWZ0LW1vc3Qgbm9uLWBOb25lYCB2YWx1ZS4gSWYgYm90aCBvcGVyYW5kcyBhcmUgYFNvbWVgcyB0aGVuIHRoZSBpbm5lciB2YWx1ZXMgYXJlXG4gKiBjb25jYXRlbmF0ZWQgdXNpbmcgdGhlIHByb3ZpZGVkIGBTZW1pZ3JvdXBgXG4gKlxuICogfCB4ICAgICAgIHwgeSAgICAgICB8IGNvbmNhdCh4LCB5KSAgICAgICB8XG4gKiB8IC0tLS0tLS0gfCAtLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tIHxcbiAqIHwgbm9uZSAgICB8IG5vbmUgICAgfCBub25lICAgICAgICAgICAgICAgfFxuICogfCBzb21lKGEpIHwgbm9uZSAgICB8IHNvbWUoYSkgICAgICAgICAgICB8XG4gKiB8IG5vbmUgICAgfCBzb21lKGIpIHwgc29tZShiKSAgICAgICAgICAgIHxcbiAqIHwgc29tZShhKSB8IHNvbWUoYikgfCBzb21lKGNvbmNhdChhLCBiKSkgfFxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBnZXRNb25vaWQsIHNvbWUsIG5vbmUgfSBmcm9tICdmcC10cy9PcHRpb24nXG4gKiBpbXBvcnQgeyBTZW1pZ3JvdXBTdW0gfSBmcm9tICdmcC10cy9udW1iZXInXG4gKlxuICogY29uc3QgTSA9IGdldE1vbm9pZChTZW1pZ3JvdXBTdW0pXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE0uY29uY2F0KG5vbmUsIG5vbmUpLCBub25lKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChNLmNvbmNhdChzb21lKDEpLCBub25lKSwgc29tZSgxKSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoTS5jb25jYXQobm9uZSwgc29tZSgxKSksIHNvbWUoMSkpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE0uY29uY2F0KHNvbWUoMSksIHNvbWUoMikpLCBzb21lKDMpKVxuICpcbiAqIEBjYXRlZ29yeSBpbnN0YW5jZXNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG52YXIgZ2V0TW9ub2lkID0gZnVuY3Rpb24gKFMpIHsgcmV0dXJuICh7XG4gICAgY29uY2F0OiBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4gKCgwLCBleHBvcnRzLmlzTm9uZSkoeCkgPyB5IDogKDAsIGV4cG9ydHMuaXNOb25lKSh5KSA/IHggOiAoMCwgZXhwb3J0cy5zb21lKShTLmNvbmNhdCh4LnZhbHVlLCB5LnZhbHVlKSkpOyB9LFxuICAgIGVtcHR5OiBleHBvcnRzLm5vbmVcbn0pOyB9O1xuZXhwb3J0cy5nZXRNb25vaWQgPSBnZXRNb25vaWQ7XG4vKipcbiAqIEBjYXRlZ29yeSBtYXBwaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xudmFyIG1hcCA9IGZ1bmN0aW9uIChmKSB7IHJldHVybiBmdW5jdGlvbiAoZmEpIHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuaXNOb25lKShmYSkgPyBleHBvcnRzLm5vbmUgOiAoMCwgZXhwb3J0cy5zb21lKShmKGZhLnZhbHVlKSk7XG59OyB9O1xuZXhwb3J0cy5tYXAgPSBtYXA7XG4vKipcbiAqIEBjYXRlZ29yeSBpbnN0YW5jZXNcbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnRzLkZ1bmN0b3IgPSB7XG4gICAgVVJJOiBleHBvcnRzLlVSSSxcbiAgICBtYXA6IF9tYXBcbn07XG4vKipcbiAqIE1hcHMgdGhlIGBTb21lYCB2YWx1ZSBvZiB0aGlzIGBPcHRpb25gIHRvIHRoZSBzcGVjaWZpZWQgY29uc3RhbnQgdmFsdWUuXG4gKlxuICogQGNhdGVnb3J5IG1hcHBpbmdcbiAqIEBzaW5jZSAyLjE2LjBcbiAqL1xuZXhwb3J0cy5hcyA9ICgwLCBmdW5jdGlvbl8xLmR1YWwpKDIsICgwLCBGdW5jdG9yXzEuYXMpKGV4cG9ydHMuRnVuY3RvcikpO1xuLyoqXG4gKiBNYXBzIHRoZSBgU29tZWAgdmFsdWUgb2YgdGhpcyBgT3B0aW9uYCB0byB0aGUgdm9pZCBjb25zdGFudCB2YWx1ZS5cbiAqXG4gKiBAY2F0ZWdvcnkgbWFwcGluZ1xuICogQHNpbmNlIDIuMTYuMFxuICovXG5leHBvcnRzLmFzVW5pdCA9ICgwLCBGdW5jdG9yXzEuYXNVbml0KShleHBvcnRzLkZ1bmN0b3IpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKiBAc2luY2UgMi43LjBcbiAqL1xuZXhwb3J0cy5vZiA9IGV4cG9ydHMuc29tZTtcbi8qKlxuICogQGNhdGVnb3J5IGluc3RhbmNlc1xuICogQHNpbmNlIDIuMTAuMFxuICovXG5leHBvcnRzLlBvaW50ZWQgPSB7XG4gICAgVVJJOiBleHBvcnRzLlVSSSxcbiAgICBvZjogZXhwb3J0cy5vZlxufTtcbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbnZhciBhcCA9IGZ1bmN0aW9uIChmYSkgeyByZXR1cm4gZnVuY3Rpb24gKGZhYikge1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy5pc05vbmUpKGZhYikgPyBleHBvcnRzLm5vbmUgOiAoMCwgZXhwb3J0cy5pc05vbmUpKGZhKSA/IGV4cG9ydHMubm9uZSA6ICgwLCBleHBvcnRzLnNvbWUpKGZhYi52YWx1ZShmYS52YWx1ZSkpO1xufTsgfTtcbmV4cG9ydHMuYXAgPSBhcDtcbi8qKlxuICogQGNhdGVnb3J5IGluc3RhbmNlc1xuICogQHNpbmNlIDIuMTAuMFxuICovXG5leHBvcnRzLkFwcGx5ID0ge1xuICAgIFVSSTogZXhwb3J0cy5VUkksXG4gICAgbWFwOiBfbWFwLFxuICAgIGFwOiBfYXBcbn07XG4vKipcbiAqIEBjYXRlZ29yeSBpbnN0YW5jZXNcbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnRzLkFwcGxpY2F0aXZlID0ge1xuICAgIFVSSTogZXhwb3J0cy5VUkksXG4gICAgbWFwOiBfbWFwLFxuICAgIGFwOiBfYXAsXG4gICAgb2Y6IGV4cG9ydHMub2Zcbn07XG4vKipcbiAqIEBjYXRlZ29yeSBzZXF1ZW5jaW5nXG4gKiBAc2luY2UgMi4xNC4wXG4gKi9cbmV4cG9ydHMuZmxhdE1hcCA9ICgwLCBmdW5jdGlvbl8xLmR1YWwpKDIsIGZ1bmN0aW9uIChtYSwgZikgeyByZXR1cm4gKCgwLCBleHBvcnRzLmlzTm9uZSkobWEpID8gZXhwb3J0cy5ub25lIDogZihtYS52YWx1ZSkpOyB9KTtcbi8qKlxuICogQGNhdGVnb3J5IGluc3RhbmNlc1xuICogQHNpbmNlIDIuMTAuMFxuICovXG5leHBvcnRzLkNoYWluID0ge1xuICAgIFVSSTogZXhwb3J0cy5VUkksXG4gICAgbWFwOiBfbWFwLFxuICAgIGFwOiBfYXAsXG4gICAgY2hhaW46IGV4cG9ydHMuZmxhdE1hcFxufTtcbi8qKlxuICogQGNhdGVnb3J5IGluc3RhbmNlc1xuICogQHNpbmNlIDIuNy4wXG4gKi9cbmV4cG9ydHMuTW9uYWQgPSB7XG4gICAgVVJJOiBleHBvcnRzLlVSSSxcbiAgICBtYXA6IF9tYXAsXG4gICAgYXA6IF9hcCxcbiAgICBvZjogZXhwb3J0cy5vZixcbiAgICBjaGFpbjogZXhwb3J0cy5mbGF0TWFwXG59O1xuLyoqXG4gKiBAY2F0ZWdvcnkgZm9sZGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbnZhciByZWR1Y2UgPSBmdW5jdGlvbiAoYiwgZikgeyByZXR1cm4gZnVuY3Rpb24gKGZhKSB7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLmlzTm9uZSkoZmEpID8gYiA6IGYoYiwgZmEudmFsdWUpO1xufTsgfTtcbmV4cG9ydHMucmVkdWNlID0gcmVkdWNlO1xuLyoqXG4gKiBAY2F0ZWdvcnkgZm9sZGluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbnZhciBmb2xkTWFwID0gZnVuY3Rpb24gKE0pIHsgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiBmdW5jdGlvbiAoZmEpIHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuaXNOb25lKShmYSkgPyBNLmVtcHR5IDogZihmYS52YWx1ZSk7XG59OyB9OyB9O1xuZXhwb3J0cy5mb2xkTWFwID0gZm9sZE1hcDtcbi8qKlxuICogQGNhdGVnb3J5IGZvbGRpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG52YXIgcmVkdWNlUmlnaHQgPSBmdW5jdGlvbiAoYiwgZikgeyByZXR1cm4gZnVuY3Rpb24gKGZhKSB7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLmlzTm9uZSkoZmEpID8gYiA6IGYoZmEudmFsdWUsIGIpO1xufTsgfTtcbmV4cG9ydHMucmVkdWNlUmlnaHQgPSByZWR1Y2VSaWdodDtcbi8qKlxuICogQGNhdGVnb3J5IGluc3RhbmNlc1xuICogQHNpbmNlIDIuNy4wXG4gKi9cbmV4cG9ydHMuRm9sZGFibGUgPSB7XG4gICAgVVJJOiBleHBvcnRzLlVSSSxcbiAgICByZWR1Y2U6IF9yZWR1Y2UsXG4gICAgZm9sZE1hcDogX2ZvbGRNYXAsXG4gICAgcmVkdWNlUmlnaHQ6IF9yZWR1Y2VSaWdodFxufTtcbi8qKlxuICogUmV0dXJucyB0aGUgcHJvdmlkZWQgYE9wdGlvbmAgYHRoYXRgIGlmIGBzZWxmYCBpcyBgTm9uZWAsIG90aGVyd2lzZSByZXR1cm5zIGBzZWxmYC5cbiAqXG4gKiBAcGFyYW0gc2VsZiAtIFRoZSBmaXJzdCBgT3B0aW9uYCB0byBiZSBjaGVja2VkLlxuICogQHBhcmFtIHRoYXQgLSBUaGUgYE9wdGlvbmAgdG8gcmV0dXJuIGlmIGBzZWxmYCBpcyBgTm9uZWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIE8gZnJvbSBcImZwLXRzL09wdGlvblwiXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChPLm9yRWxzZShPLm5vbmUsICgpID0+IE8ubm9uZSksIE8ubm9uZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoTy5vckVsc2UoTy5zb21lKDEpLCAoKSA9PiBPLm5vbmUpLCBPLnNvbWUoMSkpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE8ub3JFbHNlKE8ubm9uZSwgKCkgPT4gTy5zb21lKCdiJykpLCBPLnNvbWUoJ2InKSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoTy5vckVsc2UoTy5zb21lKDEpLCAoKSA9PiBPLnNvbWUoJ2InKSksIE8uc29tZSgxKSlcbiAqXG4gKiBAY2F0ZWdvcnkgZXJyb3IgaGFuZGxpbmdcbiAqIEBzaW5jZSAyLjE2LjBcbiAqL1xuZXhwb3J0cy5vckVsc2UgPSAoMCwgZnVuY3Rpb25fMS5kdWFsKSgyLCBmdW5jdGlvbiAoc2VsZiwgdGhhdCkgeyByZXR1cm4gKCgwLCBleHBvcnRzLmlzTm9uZSkoc2VsZikgPyB0aGF0KCkgOiBzZWxmKTsgfSk7XG4vKipcbiAqIEFsaWFzIG9mIGBvckVsc2VgLlxuICpcbiAqIExlc3Mgc3RyaWN0IHZlcnNpb24gb2YgW2BhbHRgXSgjYWx0KS5cbiAqXG4gKiBUaGUgYFdgIHN1ZmZpeCAoc2hvcnQgZm9yICoqVyoqaWRlbmluZykgbWVhbnMgdGhhdCB0aGUgcmV0dXJuIHR5cGVzIHdpbGwgYmUgbWVyZ2VkLlxuICpcbiAqIEBjYXRlZ29yeSBsZWdhY3lcbiAqIEBzaW5jZSAyLjkuMFxuICovXG5leHBvcnRzLmFsdFcgPSBleHBvcnRzLm9yRWxzZTtcbi8qKlxuICogQWxpYXMgb2YgYG9yRWxzZWAuXG4gKlxuICogQGNhdGVnb3J5IGxlZ2FjeVxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydHMuYWx0ID0gZXhwb3J0cy5vckVsc2U7XG4vKipcbiAqIEBjYXRlZ29yeSBpbnN0YW5jZXNcbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnRzLkFsdCA9IHtcbiAgICBVUkk6IGV4cG9ydHMuVVJJLFxuICAgIG1hcDogX21hcCxcbiAgICBhbHQ6IF9hbHRcbn07XG4vKipcbiAqIEBzaW5jZSAyLjcuMFxuICovXG52YXIgemVybyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4cG9ydHMubm9uZTsgfTtcbmV4cG9ydHMuemVybyA9IHplcm87XG4vKipcbiAqIEBjYXRlZ29yeSBpbnN0YW5jZXNcbiAqIEBzaW5jZSAyLjExLjBcbiAqL1xuZXhwb3J0cy5aZXJvID0ge1xuICAgIFVSSTogZXhwb3J0cy5VUkksXG4gICAgemVybzogZXhwb3J0cy56ZXJvXG59O1xuLyoqXG4gKiBAY2F0ZWdvcnkgZG8gbm90YXRpb25cbiAqIEBzaW5jZSAyLjExLjBcbiAqL1xuZXhwb3J0cy5ndWFyZCA9ICgwLCBaZXJvXzEuZ3VhcmQpKGV4cG9ydHMuWmVybywgZXhwb3J0cy5Qb2ludGVkKTtcbi8qKlxuICogQGNhdGVnb3J5IGluc3RhbmNlc1xuICogQHNpbmNlIDIuNy4wXG4gKi9cbmV4cG9ydHMuQWx0ZXJuYXRpdmUgPSB7XG4gICAgVVJJOiBleHBvcnRzLlVSSSxcbiAgICBtYXA6IF9tYXAsXG4gICAgYXA6IF9hcCxcbiAgICBvZjogZXhwb3J0cy5vZixcbiAgICBhbHQ6IF9hbHQsXG4gICAgemVybzogZXhwb3J0cy56ZXJvXG59O1xuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChmKSB7IHJldHVybiBmdW5jdGlvbiAod2EpIHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuaXNOb25lKSh3YSkgPyBleHBvcnRzLm5vbmUgOiAoMCwgZXhwb3J0cy5zb21lKShmKHdhKSk7XG59OyB9O1xuZXhwb3J0cy5leHRlbmQgPSBleHRlbmQ7XG4vKipcbiAqIEBjYXRlZ29yeSBpbnN0YW5jZXNcbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnRzLkV4dGVuZCA9IHtcbiAgICBVUkk6IGV4cG9ydHMuVVJJLFxuICAgIG1hcDogX21hcCxcbiAgICBleHRlbmQ6IF9leHRlbmRcbn07XG4vKipcbiAqIEBjYXRlZ29yeSBmaWx0ZXJpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnRzLmNvbXBhY3QgPSAoMCwgZXhwb3J0cy5mbGF0TWFwKShmdW5jdGlvbl8xLmlkZW50aXR5KTtcbnZhciBkZWZhdWx0U2VwYXJhdGVkID0gLyojX19QVVJFX18qLyAoMCwgU2VwYXJhdGVkXzEuc2VwYXJhdGVkKShleHBvcnRzLm5vbmUsIGV4cG9ydHMubm9uZSk7XG4vKipcbiAqIEBjYXRlZ29yeSBmaWx0ZXJpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG52YXIgc2VwYXJhdGUgPSBmdW5jdGlvbiAobWEpIHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuaXNOb25lKShtYSkgPyBkZWZhdWx0U2VwYXJhdGVkIDogKDAsIFNlcGFyYXRlZF8xLnNlcGFyYXRlZCkoKDAsIGV4cG9ydHMuZ2V0TGVmdCkobWEudmFsdWUpLCAoMCwgZXhwb3J0cy5nZXRSaWdodCkobWEudmFsdWUpKTtcbn07XG5leHBvcnRzLnNlcGFyYXRlID0gc2VwYXJhdGU7XG4vKipcbiAqIEBjYXRlZ29yeSBpbnN0YW5jZXNcbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnRzLkNvbXBhY3RhYmxlID0ge1xuICAgIFVSSTogZXhwb3J0cy5VUkksXG4gICAgY29tcGFjdDogZXhwb3J0cy5jb21wYWN0LFxuICAgIHNlcGFyYXRlOiBleHBvcnRzLnNlcGFyYXRlXG59O1xuLyoqXG4gKiBAY2F0ZWdvcnkgZmlsdGVyaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xudmFyIGZpbHRlciA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGZhKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5pc05vbmUpKGZhKSA/IGV4cG9ydHMubm9uZSA6IHByZWRpY2F0ZShmYS52YWx1ZSkgPyBmYSA6IGV4cG9ydHMubm9uZTtcbiAgICB9O1xufTtcbmV4cG9ydHMuZmlsdGVyID0gZmlsdGVyO1xuLyoqXG4gKiBAY2F0ZWdvcnkgZmlsdGVyaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xudmFyIGZpbHRlck1hcCA9IGZ1bmN0aW9uIChmKSB7IHJldHVybiBmdW5jdGlvbiAoZmEpIHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuaXNOb25lKShmYSkgPyBleHBvcnRzLm5vbmUgOiBmKGZhLnZhbHVlKTtcbn07IH07XG5leHBvcnRzLmZpbHRlck1hcCA9IGZpbHRlck1hcDtcbi8qKlxuICogQGNhdGVnb3J5IGZpbHRlcmluZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbnZhciBwYXJ0aXRpb24gPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChmYSkge1xuICAgICAgICByZXR1cm4gKDAsIFNlcGFyYXRlZF8xLnNlcGFyYXRlZCkoX2ZpbHRlcihmYSwgKDAsIFByZWRpY2F0ZV8xLm5vdCkocHJlZGljYXRlKSksIF9maWx0ZXIoZmEsIHByZWRpY2F0ZSkpO1xuICAgIH07XG59O1xuZXhwb3J0cy5wYXJ0aXRpb24gPSBwYXJ0aXRpb247XG4vKipcbiAqIEBjYXRlZ29yeSBmaWx0ZXJpbmdcbiAqIEBzaW5jZSAyLjAuMFxuICovXG52YXIgcGFydGl0aW9uTWFwID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuICgwLCBmdW5jdGlvbl8xLmZsb3cpKCgwLCBleHBvcnRzLm1hcCkoZiksIGV4cG9ydHMuc2VwYXJhdGUpOyB9O1xuZXhwb3J0cy5wYXJ0aXRpb25NYXAgPSBwYXJ0aXRpb25NYXA7XG4vKipcbiAqIEBjYXRlZ29yeSBpbnN0YW5jZXNcbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnRzLkZpbHRlcmFibGUgPSB7XG4gICAgVVJJOiBleHBvcnRzLlVSSSxcbiAgICBtYXA6IF9tYXAsXG4gICAgY29tcGFjdDogZXhwb3J0cy5jb21wYWN0LFxuICAgIHNlcGFyYXRlOiBleHBvcnRzLnNlcGFyYXRlLFxuICAgIGZpbHRlcjogX2ZpbHRlcixcbiAgICBmaWx0ZXJNYXA6IF9maWx0ZXJNYXAsXG4gICAgcGFydGl0aW9uOiBfcGFydGl0aW9uLFxuICAgIHBhcnRpdGlvbk1hcDogX3BhcnRpdGlvbk1hcFxufTtcbi8qKlxuICogQGNhdGVnb3J5IHRyYXZlcnNpbmdcbiAqIEBzaW5jZSAyLjYuM1xuICovXG52YXIgdHJhdmVyc2UgPSBmdW5jdGlvbiAoRikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuaXNOb25lKSh0YSkgPyBGLm9mKGV4cG9ydHMubm9uZSkgOiBGLm1hcChmKHRhLnZhbHVlKSwgZXhwb3J0cy5zb21lKTtcbiAgICAgICAgfTtcbiAgICB9O1xufTtcbmV4cG9ydHMudHJhdmVyc2UgPSB0cmF2ZXJzZTtcbi8qKlxuICogQGNhdGVnb3J5IHRyYXZlcnNpbmdcbiAqIEBzaW5jZSAyLjYuM1xuICovXG52YXIgc2VxdWVuY2UgPSBmdW5jdGlvbiAoRikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGEpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLmlzTm9uZSkodGEpID8gRi5vZihleHBvcnRzLm5vbmUpIDogRi5tYXAodGEudmFsdWUsIGV4cG9ydHMuc29tZSk7XG4gICAgfTtcbn07XG5leHBvcnRzLnNlcXVlbmNlID0gc2VxdWVuY2U7XG4vKipcbiAqIEBjYXRlZ29yeSBpbnN0YW5jZXNcbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnRzLlRyYXZlcnNhYmxlID0ge1xuICAgIFVSSTogZXhwb3J0cy5VUkksXG4gICAgbWFwOiBfbWFwLFxuICAgIHJlZHVjZTogX3JlZHVjZSxcbiAgICBmb2xkTWFwOiBfZm9sZE1hcCxcbiAgICByZWR1Y2VSaWdodDogX3JlZHVjZVJpZ2h0LFxuICAgIHRyYXZlcnNlOiBfdHJhdmVyc2UsXG4gICAgc2VxdWVuY2U6IGV4cG9ydHMuc2VxdWVuY2Vcbn07XG52YXIgX3dpdGhlciA9IC8qI19fUFVSRV9fKi8gKDAsIFdpdGhlcmFibGVfMS53aXRoZXJEZWZhdWx0KShleHBvcnRzLlRyYXZlcnNhYmxlLCBleHBvcnRzLkNvbXBhY3RhYmxlKTtcbnZhciBfd2lsdCA9IC8qI19fUFVSRV9fKi8gKDAsIFdpdGhlcmFibGVfMS53aWx0RGVmYXVsdCkoZXhwb3J0cy5UcmF2ZXJzYWJsZSwgZXhwb3J0cy5Db21wYWN0YWJsZSk7XG4vKipcbiAqIEBjYXRlZ29yeSBmaWx0ZXJpbmdcbiAqIEBzaW5jZSAyLjYuNVxuICovXG52YXIgd2l0aGVyID0gZnVuY3Rpb24gKEYpIHtcbiAgICB2YXIgX3dpdGhlckYgPSBfd2l0aGVyKEYpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZikgeyByZXR1cm4gZnVuY3Rpb24gKGZhKSB7IHJldHVybiBfd2l0aGVyRihmYSwgZik7IH07IH07XG59O1xuZXhwb3J0cy53aXRoZXIgPSB3aXRoZXI7XG4vKipcbiAqIEBjYXRlZ29yeSBmaWx0ZXJpbmdcbiAqIEBzaW5jZSAyLjYuNVxuICovXG52YXIgd2lsdCA9IGZ1bmN0aW9uIChGKSB7XG4gICAgdmFyIF93aWx0RiA9IF93aWx0KEYpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZikgeyByZXR1cm4gZnVuY3Rpb24gKGZhKSB7IHJldHVybiBfd2lsdEYoZmEsIGYpOyB9OyB9O1xufTtcbmV4cG9ydHMud2lsdCA9IHdpbHQ7XG4vKipcbiAqIEBjYXRlZ29yeSBpbnN0YW5jZXNcbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnRzLldpdGhlcmFibGUgPSB7XG4gICAgVVJJOiBleHBvcnRzLlVSSSxcbiAgICBtYXA6IF9tYXAsXG4gICAgcmVkdWNlOiBfcmVkdWNlLFxuICAgIGZvbGRNYXA6IF9mb2xkTWFwLFxuICAgIHJlZHVjZVJpZ2h0OiBfcmVkdWNlUmlnaHQsXG4gICAgdHJhdmVyc2U6IF90cmF2ZXJzZSxcbiAgICBzZXF1ZW5jZTogZXhwb3J0cy5zZXF1ZW5jZSxcbiAgICBjb21wYWN0OiBleHBvcnRzLmNvbXBhY3QsXG4gICAgc2VwYXJhdGU6IGV4cG9ydHMuc2VwYXJhdGUsXG4gICAgZmlsdGVyOiBfZmlsdGVyLFxuICAgIGZpbHRlck1hcDogX2ZpbHRlck1hcCxcbiAgICBwYXJ0aXRpb246IF9wYXJ0aXRpb24sXG4gICAgcGFydGl0aW9uTWFwOiBfcGFydGl0aW9uTWFwLFxuICAgIHdpdGhlcjogX3dpdGhlcixcbiAgICB3aWx0OiBfd2lsdFxufTtcbi8qKlxuICogQHNpbmNlIDIuNy4wXG4gKi9cbnZhciB0aHJvd0Vycm9yID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhwb3J0cy5ub25lOyB9O1xuZXhwb3J0cy50aHJvd0Vycm9yID0gdGhyb3dFcnJvcjtcbi8qKlxuICogQGNhdGVnb3J5IGluc3RhbmNlc1xuICogQHNpbmNlIDIuNy4wXG4gKi9cbmV4cG9ydHMuTW9uYWRUaHJvdyA9IHtcbiAgICBVUkk6IGV4cG9ydHMuVVJJLFxuICAgIG1hcDogX21hcCxcbiAgICBhcDogX2FwLFxuICAgIG9mOiBleHBvcnRzLm9mLFxuICAgIGNoYWluOiBleHBvcnRzLmZsYXRNYXAsXG4gICAgdGhyb3dFcnJvcjogZXhwb3J0cy50aHJvd0Vycm9yXG59O1xuLyoqXG4gKiBUcmFuc2Zvcm1zIGFuIGBFaXRoZXJgIHRvIGFuIGBPcHRpb25gIGRpc2NhcmRpbmcgdGhlIGVycm9yLlxuICpcbiAqIEFsaWFzIG9mIFtnZXRSaWdodF0oI2dldHJpZ2h0KVxuICpcbiAqIEBjYXRlZ29yeSBjb252ZXJzaW9uc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydHMuZnJvbUVpdGhlciA9IGV4cG9ydHMuZ2V0UmlnaHQ7XG4vKipcbiAqIEBjYXRlZ29yeSBpbnN0YW5jZXNcbiAqIEBzaW5jZSAyLjExLjBcbiAqL1xuZXhwb3J0cy5Gcm9tRWl0aGVyID0ge1xuICAgIFVSSTogZXhwb3J0cy5VUkksXG4gICAgZnJvbUVpdGhlcjogZXhwb3J0cy5mcm9tRWl0aGVyXG59O1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gcmVmaW5lbWVudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9wdGlvbiBpcyBhbiBpbnN0YW5jZSBvZiBgU29tZWAsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBzb21lLCBub25lLCBpc1NvbWUgfSBmcm9tICdmcC10cy9PcHRpb24nXG4gKlxuICogYXNzZXJ0LnN0cmljdEVxdWFsKGlzU29tZShzb21lKDEpKSwgdHJ1ZSlcbiAqIGFzc2VydC5zdHJpY3RFcXVhbChpc1NvbWUobm9uZSksIGZhbHNlKVxuICpcbiAqIEBjYXRlZ29yeSByZWZpbmVtZW50c1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydHMuaXNTb21lID0gXy5pc1NvbWU7XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBvcHRpb24gaXMgYE5vbmVgLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgc29tZSwgbm9uZSwgaXNOb25lIH0gZnJvbSAnZnAtdHMvT3B0aW9uJ1xuICpcbiAqIGFzc2VydC5zdHJpY3RFcXVhbChpc05vbmUoc29tZSgxKSksIGZhbHNlKVxuICogYXNzZXJ0LnN0cmljdEVxdWFsKGlzTm9uZShub25lKSwgdHJ1ZSlcbiAqXG4gKiBAY2F0ZWdvcnkgcmVmaW5lbWVudHNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG52YXIgaXNOb25lID0gZnVuY3Rpb24gKGZhKSB7IHJldHVybiBmYS5fdGFnID09PSAnTm9uZSc7IH07XG5leHBvcnRzLmlzTm9uZSA9IGlzTm9uZTtcbi8qKlxuICogTGVzcyBzdHJpY3QgdmVyc2lvbiBvZiBbYG1hdGNoYF0oI21hdGNoKS5cbiAqXG4gKiBUaGUgYFdgIHN1ZmZpeCAoc2hvcnQgZm9yICoqVyoqaWRlbmluZykgbWVhbnMgdGhhdCB0aGUgaGFuZGxlciByZXR1cm4gdHlwZXMgd2lsbCBiZSBtZXJnZWQuXG4gKlxuICogQGNhdGVnb3J5IHBhdHRlcm4gbWF0Y2hpbmdcbiAqIEBzaW5jZSAyLjEwLjBcbiAqL1xudmFyIG1hdGNoVyA9IGZ1bmN0aW9uIChvbk5vbmUsIG9uU29tZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobWEpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLmlzTm9uZSkobWEpID8gb25Ob25lKCkgOiBvblNvbWUobWEudmFsdWUpO1xuICAgIH07XG59O1xuZXhwb3J0cy5tYXRjaFcgPSBtYXRjaFc7XG4vKipcbiAqIEFsaWFzIG9mIFtgbWF0Y2hXYF0oI21hdGNodykuXG4gKlxuICogQGNhdGVnb3J5IHBhdHRlcm4gbWF0Y2hpbmdcbiAqIEBzaW5jZSAyLjEwLjBcbiAqL1xuZXhwb3J0cy5mb2xkVyA9IGV4cG9ydHMubWF0Y2hXO1xuLyoqXG4gKiBUYWtlcyBhIChsYXp5KSBkZWZhdWx0IHZhbHVlLCBhIGZ1bmN0aW9uLCBhbmQgYW4gYE9wdGlvbmAgdmFsdWUsIGlmIHRoZSBgT3B0aW9uYCB2YWx1ZSBpcyBgTm9uZWAgdGhlIGRlZmF1bHQgdmFsdWUgaXNcbiAqIHJldHVybmVkLCBvdGhlcndpc2UgdGhlIGZ1bmN0aW9uIGlzIGFwcGxpZWQgdG8gdGhlIHZhbHVlIGluc2lkZSB0aGUgYFNvbWVgIGFuZCB0aGUgcmVzdWx0IGlzIHJldHVybmVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBzb21lLCBub25lLCBtYXRjaCB9IGZyb20gJ2ZwLXRzL09wdGlvbidcbiAqIGltcG9ydCB7IHBpcGUgfSBmcm9tICdmcC10cy9mdW5jdGlvbidcbiAqXG4gKiBhc3NlcnQuc3RyaWN0RXF1YWwoXG4gKiAgIHBpcGUoXG4gKiAgICAgc29tZSgxKSxcbiAqICAgICBtYXRjaCgoKSA9PiAnYSBub25lJywgYSA9PiBgYSBzb21lIGNvbnRhaW5pbmcgJHthfWApXG4gKiAgICksXG4gKiAgICdhIHNvbWUgY29udGFpbmluZyAxJ1xuICogKVxuICpcbiAqIGFzc2VydC5zdHJpY3RFcXVhbChcbiAqICAgcGlwZShcbiAqICAgICBub25lLFxuICogICAgIG1hdGNoKCgpID0+ICdhIG5vbmUnLCBhID0+IGBhIHNvbWUgY29udGFpbmluZyAke2F9YClcbiAqICAgKSxcbiAqICAgJ2Egbm9uZSdcbiAqIClcbiAqXG4gKiBAY2F0ZWdvcnkgcGF0dGVybiBtYXRjaGluZ1xuICogQHNpbmNlIDIuMTAuMFxuICovXG5leHBvcnRzLm1hdGNoID0gZXhwb3J0cy5tYXRjaFc7XG4vKipcbiAqIEFsaWFzIG9mIFtgbWF0Y2hgXSgjbWF0Y2gpLlxuICpcbiAqIEBjYXRlZ29yeSBwYXR0ZXJuIG1hdGNoaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0cy5mb2xkID0gZXhwb3J0cy5tYXRjaDtcbi8qKlxuICogTGVzcyBzdHJpY3QgdmVyc2lvbiBvZiBbYGdldE9yRWxzZWBdKCNnZXRvcmVsc2UpLlxuICpcbiAqIFRoZSBgV2Agc3VmZml4IChzaG9ydCBmb3IgKipXKippZGVuaW5nKSBtZWFucyB0aGF0IHRoZSBoYW5kbGVyIHJldHVybiB0eXBlIHdpbGwgYmUgbWVyZ2VkLlxuICpcbiAqIEBjYXRlZ29yeSBlcnJvciBoYW5kbGluZ1xuICogQHNpbmNlIDIuNi4wXG4gKi9cbnZhciBnZXRPckVsc2VXID0gZnVuY3Rpb24gKG9uTm9uZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobWEpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLmlzTm9uZSkobWEpID8gb25Ob25lKCkgOiBtYS52YWx1ZTtcbiAgICB9O1xufTtcbmV4cG9ydHMuZ2V0T3JFbHNlVyA9IGdldE9yRWxzZVc7XG4vKipcbiAqIEV4dHJhY3RzIHRoZSB2YWx1ZSBvdXQgb2YgdGhlIHN0cnVjdHVyZSwgaWYgaXQgZXhpc3RzLiBPdGhlcndpc2UgcmV0dXJucyB0aGUgZ2l2ZW4gZGVmYXVsdCB2YWx1ZVxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBzb21lLCBub25lLCBnZXRPckVsc2UgfSBmcm9tICdmcC10cy9PcHRpb24nXG4gKiBpbXBvcnQgeyBwaXBlIH0gZnJvbSAnZnAtdHMvZnVuY3Rpb24nXG4gKlxuICogYXNzZXJ0LnN0cmljdEVxdWFsKFxuICogICBwaXBlKFxuICogICAgIHNvbWUoMSksXG4gKiAgICAgZ2V0T3JFbHNlKCgpID0+IDApXG4gKiAgICksXG4gKiAgIDFcbiAqIClcbiAqIGFzc2VydC5zdHJpY3RFcXVhbChcbiAqICAgcGlwZShcbiAqICAgICBub25lLFxuICogICAgIGdldE9yRWxzZSgoKSA9PiAwKVxuICogICApLFxuICogICAwXG4gKiApXG4gKlxuICogQGNhdGVnb3J5IGVycm9yIGhhbmRsaW5nXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0cy5nZXRPckVsc2UgPSBleHBvcnRzLmdldE9yRWxzZVc7XG4vKipcbiAqIEBjYXRlZ29yeSBtYXBwaW5nXG4gKiBAc2luY2UgMi4xMC4wXG4gKi9cbmV4cG9ydHMuZmxhcCA9ICgwLCBGdW5jdG9yXzEuZmxhcCkoZXhwb3J0cy5GdW5jdG9yKTtcbi8qKlxuICogQ29tYmluZSB0d28gZWZmZWN0ZnVsIGFjdGlvbnMsIGtlZXBpbmcgb25seSB0aGUgcmVzdWx0IG9mIHRoZSBmaXJzdC5cbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0cy5hcEZpcnN0ID0gKDAsIEFwcGx5XzEuYXBGaXJzdCkoZXhwb3J0cy5BcHBseSk7XG4vKipcbiAqIENvbWJpbmUgdHdvIGVmZmVjdGZ1bCBhY3Rpb25zLCBrZWVwaW5nIG9ubHkgdGhlIHJlc3VsdCBvZiB0aGUgc2Vjb25kLlxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnRzLmFwU2Vjb25kID0gKDAsIEFwcGx5XzEuYXBTZWNvbmQpKGV4cG9ydHMuQXBwbHkpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgc2VxdWVuY2luZ1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydHMuZmxhdHRlbiA9IGV4cG9ydHMuY29tcGFjdDtcbi8qKlxuICogQ29tcG9zZXMgY29tcHV0YXRpb25zIGluIHNlcXVlbmNlLCB1c2luZyB0aGUgcmV0dXJuIHZhbHVlIG9mIG9uZSBjb21wdXRhdGlvbiB0byBkZXRlcm1pbmUgdGhlIG5leHQgY29tcHV0YXRpb24gYW5kXG4gKiBrZWVwaW5nIG9ubHkgdGhlIHJlc3VsdCBvZiB0aGUgZmlyc3QuXG4gKlxuICogQGNhdGVnb3J5IGNvbWJpbmF0b3JzXG4gKiBAc2luY2UgMi4xNS4wXG4gKi9cbmV4cG9ydHMudGFwID0gKDAsIGZ1bmN0aW9uXzEuZHVhbCkoMiwgY2hhaW5hYmxlLnRhcChleHBvcnRzLkNoYWluKSk7XG4vKipcbiAqIENvbXBvc2VzIGNvbXB1dGF0aW9ucyBpbiBzZXF1ZW5jZSwgdXNpbmcgdGhlIHJldHVybiB2YWx1ZSBvZiBvbmUgY29tcHV0YXRpb24gdG8gZGV0ZXJtaW5lIHRoZSBuZXh0IGNvbXB1dGF0aW9uIGFuZFxuICoga2VlcGluZyBvbmx5IHRoZSByZXN1bHQgb2YgdGhlIGZpcnN0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBwaXBlIH0gZnJvbSAnZnAtdHMvZnVuY3Rpb24nXG4gKiBpbXBvcnQgKiBhcyBPIGZyb20gJ2ZwLXRzL09wdGlvbidcbiAqIGltcG9ydCAqIGFzIEUgZnJvbSAnZnAtdHMvRWl0aGVyJ1xuICpcbiAqIGNvbnN0IGNvbXB1dGUgPSAodmFsdWU6IG51bWJlcikgPT4gcGlwZShcbiAqICAgTy5vZih2YWx1ZSksXG4gKiAgIE8udGFwRWl0aGVyKCh2YWx1ZSkgPT4gdmFsdWUgPiAwID8gRS5yaWdodCgnb2snKSA6IEUubGVmdCgnZXJyb3InKSksXG4gKiApXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChjb21wdXRlKDEpLCBPLm9mKDEpKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChjb21wdXRlKC00MiksIE8ubm9uZSlcbiAqXG4gKiBAY2F0ZWdvcnkgY29tYmluYXRvcnNcbiAqIEBzaW5jZSAyLjE2LjBcbiAqL1xuZXhwb3J0cy50YXBFaXRoZXIgPSAoMCwgZnVuY3Rpb25fMS5kdWFsKSgyLCAoMCwgRnJvbUVpdGhlcl8xLnRhcEVpdGhlcikoZXhwb3J0cy5Gcm9tRWl0aGVyLCBleHBvcnRzLkNoYWluKSk7XG4vKipcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnRzLmR1cGxpY2F0ZSA9ICgwLCBleHBvcnRzLmV4dGVuZCkoZnVuY3Rpb25fMS5pZGVudGl0eSk7XG4vKipcbiAqIEBjYXRlZ29yeSBsaWZ0aW5nXG4gKiBAc2luY2UgMi4xMS4wXG4gKi9cbmV4cG9ydHMuZnJvbUVpdGhlcksgPSAoMCwgRnJvbUVpdGhlcl8xLmZyb21FaXRoZXJLKShleHBvcnRzLkZyb21FaXRoZXIpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgc2VxdWVuY2luZ1xuICogQHNpbmNlIDIuMTEuMFxuICovXG5leHBvcnRzLmNoYWluRWl0aGVySyA9IFxuLyojX19QVVJFX18qLyAoMCwgRnJvbUVpdGhlcl8xLmNoYWluRWl0aGVySykoZXhwb3J0cy5Gcm9tRWl0aGVyLCBleHBvcnRzLkNoYWluKTtcbi8qKlxuICogQWxpYXMgb2YgYHRhcEVpdGhlcmAuXG4gKlxuICogQGNhdGVnb3J5IGxlZ2FjeVxuICogQHNpbmNlIDIuMTIuMFxuICovXG5leHBvcnRzLmNoYWluRmlyc3RFaXRoZXJLID0gZXhwb3J0cy50YXBFaXRoZXI7XG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYE9wdGlvbmAgZnJvbSBhIG51bGxhYmxlIHR5cGUuIElmIHRoZSB2YWx1ZSBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAsIHJldHVybnMgYE5vbmVgLCBvdGhlcndpc2VcbiAqIHJldHVybnMgdGhlIHZhbHVlIHdyYXBwZWQgaW4gYSBgU29tZWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IG5vbmUsIHNvbWUsIGZyb21OdWxsYWJsZSB9IGZyb20gJ2ZwLXRzL09wdGlvbidcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGZyb21OdWxsYWJsZSh1bmRlZmluZWQpLCBub25lKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChmcm9tTnVsbGFibGUobnVsbCksIG5vbmUpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGZyb21OdWxsYWJsZSgxKSwgc29tZSgxKSlcbiAqXG4gKiBAY2F0ZWdvcnkgY29udmVyc2lvbnNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG52YXIgZnJvbU51bGxhYmxlID0gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIChhID09IG51bGwgPyBleHBvcnRzLm5vbmUgOiAoMCwgZXhwb3J0cy5zb21lKShhKSk7IH07XG5leHBvcnRzLmZyb21OdWxsYWJsZSA9IGZyb21OdWxsYWJsZTtcbi8qKlxuICogVHJhbnNmb3JtcyBhbiBleGNlcHRpb24gaW50byBhbiBgT3B0aW9uYC4gSWYgYGZgIHRocm93cywgcmV0dXJucyBgTm9uZWAsIG90aGVyd2lzZSByZXR1cm5zIHRoZSBvdXRwdXQgd3JhcHBlZCBpbiBhXG4gKiBgU29tZWAuXG4gKlxuICogU2VlIGFsc28gW2B0cnlDYXRjaEtgXSgjdHJ5Y2F0Y2hrKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgbm9uZSwgc29tZSwgdHJ5Q2F0Y2ggfSBmcm9tICdmcC10cy9PcHRpb24nXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChcbiAqICAgdHJ5Q2F0Y2goKCkgPT4ge1xuICogICAgIHRocm93IG5ldyBFcnJvcigpXG4gKiAgIH0pLFxuICogICBub25lXG4gKiApXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHRyeUNhdGNoKCgpID0+IDEpLCBzb21lKDEpKVxuICpcbiAqIEBjYXRlZ29yeSBpbnRlcm9wXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xudmFyIHRyeUNhdGNoID0gZnVuY3Rpb24gKGYpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuc29tZSkoZigpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMubm9uZTtcbiAgICB9XG59O1xuZXhwb3J0cy50cnlDYXRjaCA9IHRyeUNhdGNoO1xuLyoqXG4gKiBDb252ZXJ0cyBhIGZ1bmN0aW9uIHRoYXQgbWF5IHRocm93IHRvIG9uZSByZXR1cm5pbmcgYSBgT3B0aW9uYC5cbiAqXG4gKiBAY2F0ZWdvcnkgaW50ZXJvcFxuICogQHNpbmNlIDIuMTAuMFxuICovXG52YXIgdHJ5Q2F0Y2hLID0gZnVuY3Rpb24gKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYVtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy50cnlDYXRjaCkoZnVuY3Rpb24gKCkgeyByZXR1cm4gZi5hcHBseSh2b2lkIDAsIGEpOyB9KTtcbiAgICB9O1xufTtcbmV4cG9ydHMudHJ5Q2F0Y2hLID0gdHJ5Q2F0Y2hLO1xuLyoqXG4gKiBSZXR1cm5zIGEgKnNtYXJ0IGNvbnN0cnVjdG9yKiBmcm9tIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgbnVsbGFibGUgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGZyb21OdWxsYWJsZUssIG5vbmUsIHNvbWUgfSBmcm9tICdmcC10cy9PcHRpb24nXG4gKlxuICogY29uc3QgZiA9IChzOiBzdHJpbmcpOiBudW1iZXIgfCB1bmRlZmluZWQgPT4ge1xuICogICBjb25zdCBuID0gcGFyc2VGbG9hdChzKVxuICogICByZXR1cm4gaXNOYU4obikgPyB1bmRlZmluZWQgOiBuXG4gKiB9XG4gKlxuICogY29uc3QgZyA9IGZyb21OdWxsYWJsZUsoZilcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKGcoJzEnKSwgc29tZSgxKSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoZygnYScpLCBub25lKVxuICpcbiAqIEBjYXRlZ29yeSBsaWZ0aW5nXG4gKiBAc2luY2UgMi45LjBcbiAqL1xudmFyIGZyb21OdWxsYWJsZUsgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gKDAsIGZ1bmN0aW9uXzEuZmxvdykoZiwgZXhwb3J0cy5mcm9tTnVsbGFibGUpOyB9O1xuZXhwb3J0cy5mcm9tTnVsbGFibGVLID0gZnJvbU51bGxhYmxlSztcbi8qKlxuICogVGhpcyBpcyBgY2hhaW5gICsgYGZyb21OdWxsYWJsZWAsIHVzZWZ1bCB3aGVuIHdvcmtpbmcgd2l0aCBvcHRpb25hbCB2YWx1ZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IHNvbWUsIG5vbmUsIGZyb21OdWxsYWJsZSwgY2hhaW5OdWxsYWJsZUsgfSBmcm9tICdmcC10cy9PcHRpb24nXG4gKiBpbXBvcnQgeyBwaXBlIH0gZnJvbSAnZnAtdHMvZnVuY3Rpb24nXG4gKlxuICogaW50ZXJmYWNlIEVtcGxveWVlIHtcbiAqICAgcmVhZG9ubHkgY29tcGFueT86IHtcbiAqICAgICByZWFkb25seSBhZGRyZXNzPzoge1xuICogICAgICAgcmVhZG9ubHkgc3RyZWV0Pzoge1xuICogICAgICAgICByZWFkb25seSBuYW1lPzogc3RyaW5nXG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogICB9XG4gKiB9XG4gKlxuICogY29uc3QgZW1wbG95ZWUxOiBFbXBsb3llZSA9IHsgY29tcGFueTogeyBhZGRyZXNzOiB7IHN0cmVldDogeyBuYW1lOiAnaGlnaCBzdHJlZXQnIH0gfSB9IH1cbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFxuICogICBwaXBlKFxuICogICAgIGZyb21OdWxsYWJsZShlbXBsb3llZTEuY29tcGFueSksXG4gKiAgICAgY2hhaW5OdWxsYWJsZUsoY29tcGFueSA9PiBjb21wYW55LmFkZHJlc3MpLFxuICogICAgIGNoYWluTnVsbGFibGVLKGFkZHJlc3MgPT4gYWRkcmVzcy5zdHJlZXQpLFxuICogICAgIGNoYWluTnVsbGFibGVLKHN0cmVldCA9PiBzdHJlZXQubmFtZSlcbiAqICAgKSxcbiAqICAgc29tZSgnaGlnaCBzdHJlZXQnKVxuICogKVxuICpcbiAqIGNvbnN0IGVtcGxveWVlMjogRW1wbG95ZWUgPSB7IGNvbXBhbnk6IHsgYWRkcmVzczogeyBzdHJlZXQ6IHt9IH0gfSB9XG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChcbiAqICAgcGlwZShcbiAqICAgICBmcm9tTnVsbGFibGUoZW1wbG95ZWUyLmNvbXBhbnkpLFxuICogICAgIGNoYWluTnVsbGFibGVLKGNvbXBhbnkgPT4gY29tcGFueS5hZGRyZXNzKSxcbiAqICAgICBjaGFpbk51bGxhYmxlSyhhZGRyZXNzID0+IGFkZHJlc3Muc3RyZWV0KSxcbiAqICAgICBjaGFpbk51bGxhYmxlSyhzdHJlZXQgPT4gc3RyZWV0Lm5hbWUpXG4gKiAgICksXG4gKiAgIG5vbmVcbiAqIClcbiAqXG4gKiBAY2F0ZWdvcnkgc2VxdWVuY2luZ1xuICogQHNpbmNlIDIuOS4wXG4gKi9cbnZhciBjaGFpbk51bGxhYmxlSyA9IGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtYSkge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuaXNOb25lKShtYSkgPyBleHBvcnRzLm5vbmUgOiAoMCwgZXhwb3J0cy5mcm9tTnVsbGFibGUpKGYobWEudmFsdWUpKTtcbiAgICB9O1xufTtcbmV4cG9ydHMuY2hhaW5OdWxsYWJsZUsgPSBjaGFpbk51bGxhYmxlSztcbi8qKlxuICogRXh0cmFjdHMgdGhlIHZhbHVlIG91dCBvZiB0aGUgc3RydWN0dXJlLCBpZiBpdCBleGlzdHMuIE90aGVyd2lzZSByZXR1cm5zIGBudWxsYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgc29tZSwgbm9uZSwgdG9OdWxsYWJsZSB9IGZyb20gJ2ZwLXRzL09wdGlvbidcbiAqIGltcG9ydCB7IHBpcGUgfSBmcm9tICdmcC10cy9mdW5jdGlvbidcbiAqXG4gKiBhc3NlcnQuc3RyaWN0RXF1YWwoXG4gKiAgIHBpcGUoXG4gKiAgICAgc29tZSgxKSxcbiAqICAgICB0b051bGxhYmxlXG4gKiAgICksXG4gKiAgIDFcbiAqIClcbiAqIGFzc2VydC5zdHJpY3RFcXVhbChcbiAqICAgcGlwZShcbiAqICAgICBub25lLFxuICogICAgIHRvTnVsbGFibGVcbiAqICAgKSxcbiAqICAgbnVsbFxuICogKVxuICpcbiAqIEBjYXRlZ29yeSBjb252ZXJzaW9uc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydHMudG9OdWxsYWJsZSA9ICgwLCBleHBvcnRzLm1hdGNoKShmdW5jdGlvbl8xLmNvbnN0TnVsbCwgZnVuY3Rpb25fMS5pZGVudGl0eSk7XG4vKipcbiAqIEV4dHJhY3RzIHRoZSB2YWx1ZSBvdXQgb2YgdGhlIHN0cnVjdHVyZSwgaWYgaXQgZXhpc3RzLiBPdGhlcndpc2UgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgc29tZSwgbm9uZSwgdG9VbmRlZmluZWQgfSBmcm9tICdmcC10cy9PcHRpb24nXG4gKiBpbXBvcnQgeyBwaXBlIH0gZnJvbSAnZnAtdHMvZnVuY3Rpb24nXG4gKlxuICogYXNzZXJ0LnN0cmljdEVxdWFsKFxuICogICBwaXBlKFxuICogICAgIHNvbWUoMSksXG4gKiAgICAgdG9VbmRlZmluZWRcbiAqICAgKSxcbiAqICAgMVxuICogKVxuICogYXNzZXJ0LnN0cmljdEVxdWFsKFxuICogICBwaXBlKFxuICogICAgIG5vbmUsXG4gKiAgICAgdG9VbmRlZmluZWRcbiAqICAgKSxcbiAqICAgdW5kZWZpbmVkXG4gKiApXG4gKlxuICogQGNhdGVnb3J5IGNvbnZlcnNpb25zXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0cy50b1VuZGVmaW5lZCA9ICgwLCBleHBvcnRzLm1hdGNoKShmdW5jdGlvbl8xLmNvbnN0VW5kZWZpbmVkLCBmdW5jdGlvbl8xLmlkZW50aXR5KTtcbmZ1bmN0aW9uIGVsZW0oRSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYSwgbWEpIHtcbiAgICAgICAgaWYgKG1hID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBlbGVtRV8xID0gZWxlbShFKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobWEpIHsgcmV0dXJuIGVsZW1FXzEoYSwgbWEpOyB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5pc05vbmUpKG1hKSA/IGZhbHNlIDogRS5lcXVhbHMoYSwgbWEudmFsdWUpO1xuICAgIH07XG59XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBwcmVkaWNhdGUgaXMgc2F0aXNmaWVkIGJ5IHRoZSB3cmFwcGVkIHZhbHVlXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IHNvbWUsIG5vbmUsIGV4aXN0cyB9IGZyb20gJ2ZwLXRzL09wdGlvbidcbiAqIGltcG9ydCB7IHBpcGUgfSBmcm9tICdmcC10cy9mdW5jdGlvbidcbiAqXG4gKiBhc3NlcnQuc3RyaWN0RXF1YWwoXG4gKiAgIHBpcGUoXG4gKiAgICAgc29tZSgxKSxcbiAqICAgICBleGlzdHMobiA9PiBuID4gMClcbiAqICAgKSxcbiAqICAgdHJ1ZVxuICogKVxuICogYXNzZXJ0LnN0cmljdEVxdWFsKFxuICogICBwaXBlKFxuICogICAgIHNvbWUoMSksXG4gKiAgICAgZXhpc3RzKG4gPT4gbiA+IDEpXG4gKiAgICksXG4gKiAgIGZhbHNlXG4gKiApXG4gKiBhc3NlcnQuc3RyaWN0RXF1YWwoXG4gKiAgIHBpcGUoXG4gKiAgICAgbm9uZSxcbiAqICAgICBleGlzdHMobiA9PiBuID4gMClcbiAqICAgKSxcbiAqICAgZmFsc2VcbiAqIClcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xudmFyIGV4aXN0cyA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1hKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5pc05vbmUpKG1hKSA/IGZhbHNlIDogcHJlZGljYXRlKG1hLnZhbHVlKTtcbiAgICB9O1xufTtcbmV4cG9ydHMuZXhpc3RzID0gZXhpc3RzO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZG8gbm90YXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogQGNhdGVnb3J5IGRvIG5vdGF0aW9uXG4gKiBAc2luY2UgMi45LjBcbiAqL1xuZXhwb3J0cy5EbyA9ICgwLCBleHBvcnRzLm9mKShfLmVtcHR5UmVjb3JkKTtcbi8qKlxuICogQGNhdGVnb3J5IGRvIG5vdGF0aW9uXG4gKiBAc2luY2UgMi44LjBcbiAqL1xuZXhwb3J0cy5iaW5kVG8gPSAoMCwgRnVuY3Rvcl8xLmJpbmRUbykoZXhwb3J0cy5GdW5jdG9yKTtcbnZhciBsZXRfID0gLyojX19QVVJFX18qLyAoMCwgRnVuY3Rvcl8xLmxldCkoZXhwb3J0cy5GdW5jdG9yKTtcbmV4cG9ydHMubGV0ID0gbGV0Xztcbi8qKlxuICogQGNhdGVnb3J5IGRvIG5vdGF0aW9uXG4gKiBAc2luY2UgMi44LjBcbiAqL1xuZXhwb3J0cy5iaW5kID0gY2hhaW5hYmxlLmJpbmQoZXhwb3J0cy5DaGFpbik7XG4vKipcbiAqIEBjYXRlZ29yeSBkbyBub3RhdGlvblxuICogQHNpbmNlIDIuOC4wXG4gKi9cbmV4cG9ydHMuYXBTID0gKDAsIEFwcGx5XzEuYXBTKShleHBvcnRzLkFwcGx5KTtcbi8qKlxuICogQHNpbmNlIDIuMTEuMFxuICovXG5leHBvcnRzLkFwVCA9ICgwLCBleHBvcnRzLm9mKShfLmVtcHR5UmVhZG9ubHlBcnJheSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBhcnJheSB1dGlsc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIGBSZWFkb25seU5vbkVtcHR5QXJyYXkjdHJhdmVyc2VXaXRoSW5kZXgoQXBwbGljYXRpdmUpYC5cbiAqXG4gKiBAY2F0ZWdvcnkgdHJhdmVyc2luZ1xuICogQHNpbmNlIDIuMTEuMFxuICovXG52YXIgdHJhdmVyc2VSZWFkb25seU5vbkVtcHR5QXJyYXlXaXRoSW5kZXggPSBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXMpIHtcbiAgICAgICAgdmFyIG8gPSBmKDAsIF8uaGVhZChhcykpO1xuICAgICAgICBpZiAoKDAsIGV4cG9ydHMuaXNOb25lKShvKSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMubm9uZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0ID0gW28udmFsdWVdO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgb18xID0gZihpLCBhc1tpXSk7XG4gICAgICAgICAgICBpZiAoKDAsIGV4cG9ydHMuaXNOb25lKShvXzEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMubm9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dC5wdXNoKG9fMS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLnNvbWUpKG91dCk7XG4gICAgfTtcbn07XG5leHBvcnRzLnRyYXZlcnNlUmVhZG9ubHlOb25FbXB0eUFycmF5V2l0aEluZGV4ID0gdHJhdmVyc2VSZWFkb25seU5vbkVtcHR5QXJyYXlXaXRoSW5kZXg7XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gYFJlYWRvbmx5QXJyYXkjdHJhdmVyc2VXaXRoSW5kZXgoQXBwbGljYXRpdmUpYC5cbiAqXG4gKiBAY2F0ZWdvcnkgdHJhdmVyc2luZ1xuICogQHNpbmNlIDIuMTEuMFxuICovXG52YXIgdHJhdmVyc2VSZWFkb25seUFycmF5V2l0aEluZGV4ID0gZnVuY3Rpb24gKGYpIHtcbiAgICB2YXIgZyA9ICgwLCBleHBvcnRzLnRyYXZlcnNlUmVhZG9ubHlOb25FbXB0eUFycmF5V2l0aEluZGV4KShmKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFzKSB7IHJldHVybiAoXy5pc05vbkVtcHR5KGFzKSA/IGcoYXMpIDogZXhwb3J0cy5BcFQpOyB9O1xufTtcbmV4cG9ydHMudHJhdmVyc2VSZWFkb25seUFycmF5V2l0aEluZGV4ID0gdHJhdmVyc2VSZWFkb25seUFycmF5V2l0aEluZGV4O1xuLyoqXG4gKiBFcXVpdmFsZW50IHRvIGBSZWFkb25seUFycmF5I3RyYXZlcnNlV2l0aEluZGV4KEFwcGxpY2F0aXZlKWAuXG4gKlxuICogQGNhdGVnb3J5IHRyYXZlcnNpbmdcbiAqIEBzaW5jZSAyLjkuMFxuICovXG5leHBvcnRzLnRyYXZlcnNlQXJyYXlXaXRoSW5kZXggPSBleHBvcnRzLnRyYXZlcnNlUmVhZG9ubHlBcnJheVdpdGhJbmRleDtcbi8qKlxuICogRXF1aXZhbGVudCB0byBgUmVhZG9ubHlBcnJheSN0cmF2ZXJzZShBcHBsaWNhdGl2ZSlgLlxuICpcbiAqIEBjYXRlZ29yeSB0cmF2ZXJzaW5nXG4gKiBAc2luY2UgMi45LjBcbiAqL1xudmFyIHRyYXZlcnNlQXJyYXkgPSBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy50cmF2ZXJzZVJlYWRvbmx5QXJyYXlXaXRoSW5kZXgpKGZ1bmN0aW9uIChfLCBhKSB7IHJldHVybiBmKGEpOyB9KTtcbn07XG5leHBvcnRzLnRyYXZlcnNlQXJyYXkgPSB0cmF2ZXJzZUFycmF5O1xuLyoqXG4gKiBFcXVpdmFsZW50IHRvIGBSZWFkb25seUFycmF5I3NlcXVlbmNlKEFwcGxpY2F0aXZlKWAuXG4gKlxuICogQGNhdGVnb3J5IHRyYXZlcnNpbmdcbiAqIEBzaW5jZSAyLjkuMFxuICovXG5leHBvcnRzLnNlcXVlbmNlQXJyYXkgPSBcbi8qI19fUFVSRV9fKi8gKDAsIGV4cG9ydHMudHJhdmVyc2VBcnJheSkoZnVuY3Rpb25fMS5pZGVudGl0eSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBsZWdhY3lcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogQWxpYXMgb2YgYGZsYXRNYXBgLlxuICpcbiAqIEBjYXRlZ29yeSBsZWdhY3lcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnRzLmNoYWluID0gZXhwb3J0cy5mbGF0TWFwO1xuLyoqXG4gKiBBbGlhcyBvZiBgdGFwYC5cbiAqXG4gKiBAY2F0ZWdvcnkgbGVnYWN5XG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0cy5jaGFpbkZpcnN0ID0gZXhwb3J0cy50YXA7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBkZXByZWNhdGVkXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqIFVzZSBgUmVmaW5lbWVudGAgbW9kdWxlIGluc3RlYWQuXG4gKlxuICogQGNhdGVnb3J5IHpvbmUgb2YgZGVhdGhcbiAqIEBzaW5jZSAyLjAuMFxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZnVuY3Rpb24gZ2V0UmVmaW5lbWVudChnZXRPcHRpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHsgcmV0dXJuICgwLCBleHBvcnRzLmlzU29tZSkoZ2V0T3B0aW9uKGEpKTsgfTtcbn1cbi8qKlxuICogVXNlIFtgY2hhaW5OdWxsYWJsZUtgXSgjY2hhaW5udWxsYWJsZWspIGluc3RlYWQuXG4gKlxuICogQGNhdGVnb3J5IHpvbmUgb2YgZGVhdGhcbiAqIEBzaW5jZSAyLjAuMFxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0cy5tYXBOdWxsYWJsZSA9IGV4cG9ydHMuY2hhaW5OdWxsYWJsZUs7XG4vKipcbiAqIFRoaXMgaW5zdGFuY2UgaXMgZGVwcmVjYXRlZCwgdXNlIHNtYWxsLCBzcGVjaWZpYyBpbnN0YW5jZXMgaW5zdGVhZC5cbiAqIEZvciBleGFtcGxlIGlmIGEgZnVuY3Rpb24gbmVlZHMgYSBgRnVuY3RvcmAgaW5zdGFuY2UsIHBhc3MgYE8uRnVuY3RvcmAgaW5zdGVhZCBvZiBgTy5vcHRpb25gXG4gKiAod2hlcmUgYE9gIGlzIGZyb20gYGltcG9ydCBPIGZyb20gJ2ZwLXRzL09wdGlvbidgKVxuICpcbiAqIEBjYXRlZ29yeSB6b25lIG9mIGRlYXRoXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydHMub3B0aW9uID0ge1xuICAgIFVSSTogZXhwb3J0cy5VUkksXG4gICAgbWFwOiBfbWFwLFxuICAgIG9mOiBleHBvcnRzLm9mLFxuICAgIGFwOiBfYXAsXG4gICAgY2hhaW46IGV4cG9ydHMuZmxhdE1hcCxcbiAgICByZWR1Y2U6IF9yZWR1Y2UsXG4gICAgZm9sZE1hcDogX2ZvbGRNYXAsXG4gICAgcmVkdWNlUmlnaHQ6IF9yZWR1Y2VSaWdodCxcbiAgICB0cmF2ZXJzZTogX3RyYXZlcnNlLFxuICAgIHNlcXVlbmNlOiBleHBvcnRzLnNlcXVlbmNlLFxuICAgIHplcm86IGV4cG9ydHMuemVybyxcbiAgICBhbHQ6IF9hbHQsXG4gICAgZXh0ZW5kOiBfZXh0ZW5kLFxuICAgIGNvbXBhY3Q6IGV4cG9ydHMuY29tcGFjdCxcbiAgICBzZXBhcmF0ZTogZXhwb3J0cy5zZXBhcmF0ZSxcbiAgICBmaWx0ZXI6IF9maWx0ZXIsXG4gICAgZmlsdGVyTWFwOiBfZmlsdGVyTWFwLFxuICAgIHBhcnRpdGlvbjogX3BhcnRpdGlvbixcbiAgICBwYXJ0aXRpb25NYXA6IF9wYXJ0aXRpb25NYXAsXG4gICAgd2l0aGVyOiBfd2l0aGVyLFxuICAgIHdpbHQ6IF93aWx0LFxuICAgIHRocm93RXJyb3I6IGV4cG9ydHMudGhyb3dFcnJvclxufTtcbi8qKlxuICogVXNlIFtgZ2V0QXBwbHlTZW1pZ3JvdXBgXSguL0FwcGx5LnRzLmh0bWwjZ2V0YXBwbHlzZW1pZ3JvdXApIGluc3RlYWQuXG4gKlxuICogQGNhdGVnb3J5IHpvbmUgb2YgZGVhdGhcbiAqIEBzaW5jZSAyLjAuMFxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0cy5nZXRBcHBseVNlbWlncm91cCA9ICgwLCBBcHBseV8xLmdldEFwcGx5U2VtaWdyb3VwKShleHBvcnRzLkFwcGx5KTtcbi8qKlxuICogVXNlIFtgZ2V0QXBwbGljYXRpdmVNb25vaWRgXSguL0FwcGxpY2F0aXZlLnRzLmh0bWwjZ2V0YXBwbGljYXRpdmVtb25vaWQpIGluc3RlYWQuXG4gKlxuICogQGNhdGVnb3J5IHpvbmUgb2YgZGVhdGhcbiAqIEBzaW5jZSAyLjAuMFxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0cy5nZXRBcHBseU1vbm9pZCA9ICgwLCBBcHBsaWNhdGl2ZV8xLmdldEFwcGxpY2F0aXZlTW9ub2lkKShleHBvcnRzLkFwcGxpY2F0aXZlKTtcbi8qKlxuICogVXNlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGZpcnN0IH0gZnJvbSAnZnAtdHMvU2VtaWdyb3VwJ1xuICogaW1wb3J0IHsgZ2V0TW9ub2lkIH0gZnJvbSAnZnAtdHMvT3B0aW9uJ1xuICpcbiAqIGdldE1vbm9pZChmaXJzdCgpKVxuICogYGBgXG4gKlxuICogaW5zdGVhZC5cbiAqXG4gKiBNb25vaWQgcmV0dXJuaW5nIHRoZSBsZWZ0LW1vc3Qgbm9uLWBOb25lYCB2YWx1ZVxuICpcbiAqIHwgeCAgICAgICB8IHkgICAgICAgfCBjb25jYXQoeCwgeSkgfFxuICogfCAtLS0tLS0tIHwgLS0tLS0tLSB8IC0tLS0tLS0tLS0tLSB8XG4gKiB8IG5vbmUgICAgfCBub25lICAgIHwgbm9uZSAgICAgICAgIHxcbiAqIHwgc29tZShhKSB8IG5vbmUgICAgfCBzb21lKGEpICAgICAgfFxuICogfCBub25lICAgIHwgc29tZShiKSB8IHNvbWUoYikgICAgICB8XG4gKiB8IHNvbWUoYSkgfCBzb21lKGIpIHwgc29tZShhKSAgICAgIHxcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgZ2V0Rmlyc3RNb25vaWQsIHNvbWUsIG5vbmUgfSBmcm9tICdmcC10cy9PcHRpb24nXG4gKlxuICogY29uc3QgTSA9IGdldEZpcnN0TW9ub2lkPG51bWJlcj4oKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChNLmNvbmNhdChub25lLCBub25lKSwgbm9uZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoTS5jb25jYXQoc29tZSgxKSwgbm9uZSksIHNvbWUoMSkpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE0uY29uY2F0KG5vbmUsIHNvbWUoMikpLCBzb21lKDIpKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChNLmNvbmNhdChzb21lKDEpLCBzb21lKDIpKSwgc29tZSgxKSlcbiAqXG4gKiBAY2F0ZWdvcnkgem9uZSBvZiBkZWF0aFxuICogQHNpbmNlIDIuMC4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG52YXIgZ2V0Rmlyc3RNb25vaWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoMCwgZXhwb3J0cy5nZXRNb25vaWQpKCgwLCBTZW1pZ3JvdXBfMS5maXJzdCkoKSk7IH07XG5leHBvcnRzLmdldEZpcnN0TW9ub2lkID0gZ2V0Rmlyc3RNb25vaWQ7XG4vKipcbiAqIFVzZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBsYXN0IH0gZnJvbSAnZnAtdHMvU2VtaWdyb3VwJ1xuICogaW1wb3J0IHsgZ2V0TW9ub2lkIH0gZnJvbSAnZnAtdHMvT3B0aW9uJ1xuICpcbiAqIGdldE1vbm9pZChsYXN0KCkpXG4gKiBgYGBcbiAqXG4gKiBpbnN0ZWFkLlxuICpcbiAqIE1vbm9pZCByZXR1cm5pbmcgdGhlIHJpZ2h0LW1vc3Qgbm9uLWBOb25lYCB2YWx1ZVxuICpcbiAqIHwgeCAgICAgICB8IHkgICAgICAgfCBjb25jYXQoeCwgeSkgfFxuICogfCAtLS0tLS0tIHwgLS0tLS0tLSB8IC0tLS0tLS0tLS0tLSB8XG4gKiB8IG5vbmUgICAgfCBub25lICAgIHwgbm9uZSAgICAgICAgIHxcbiAqIHwgc29tZShhKSB8IG5vbmUgICAgfCBzb21lKGEpICAgICAgfFxuICogfCBub25lICAgIHwgc29tZShiKSB8IHNvbWUoYikgICAgICB8XG4gKiB8IHNvbWUoYSkgfCBzb21lKGIpIHwgc29tZShiKSAgICAgIHxcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgZ2V0TGFzdE1vbm9pZCwgc29tZSwgbm9uZSB9IGZyb20gJ2ZwLXRzL09wdGlvbidcbiAqXG4gKiBjb25zdCBNID0gZ2V0TGFzdE1vbm9pZDxudW1iZXI+KClcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoTS5jb25jYXQobm9uZSwgbm9uZSksIG5vbmUpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE0uY29uY2F0KHNvbWUoMSksIG5vbmUpLCBzb21lKDEpKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChNLmNvbmNhdChub25lLCBzb21lKDIpKSwgc29tZSgyKSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoTS5jb25jYXQoc29tZSgxKSwgc29tZSgyKSksIHNvbWUoMikpXG4gKlxuICogQGNhdGVnb3J5IHpvbmUgb2YgZGVhdGhcbiAqIEBzaW5jZSAyLjAuMFxuICogQGRlcHJlY2F0ZWRcbiAqL1xudmFyIGdldExhc3RNb25vaWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoMCwgZXhwb3J0cy5nZXRNb25vaWQpKCgwLCBTZW1pZ3JvdXBfMS5sYXN0KSgpKTsgfTtcbmV4cG9ydHMuZ2V0TGFzdE1vbm9pZCA9IGdldExhc3RNb25vaWQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fp-ts/lib/Option.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fp-ts/lib/Ord.js":
/*!***************************************!*\
  !*** ./node_modules/fp-ts/lib/Ord.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ordDate = exports.ordNumber = exports.ordString = exports.ordBoolean = exports.ord = exports.getDualOrd = exports.getTupleOrd = exports.between = exports.clamp = exports.max = exports.min = exports.geq = exports.leq = exports.gt = exports.lt = exports.equals = exports.trivial = exports.Contravariant = exports.getMonoid = exports.getSemigroup = exports.URI = exports.contramap = exports.reverse = exports.tuple = exports.fromCompare = exports.equalsDefault = void 0;\nvar Eq_1 = __webpack_require__(/*! ./Eq */ \"(app-pages-browser)/./node_modules/fp-ts/lib/Eq.js\");\nvar function_1 = __webpack_require__(/*! ./function */ \"(app-pages-browser)/./node_modules/fp-ts/lib/function.js\");\n// -------------------------------------------------------------------------------------\n// defaults\n// -------------------------------------------------------------------------------------\n/**\n * @category defaults\n * @since 2.10.0\n */\nvar equalsDefault = function (compare) {\n    return function (first, second) {\n        return first === second || compare(first, second) === 0;\n    };\n};\nexports.equalsDefault = equalsDefault;\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.0.0\n */\nvar fromCompare = function (compare) { return ({\n    equals: (0, exports.equalsDefault)(compare),\n    compare: function (first, second) { return (first === second ? 0 : compare(first, second)); }\n}); };\nexports.fromCompare = fromCompare;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * Given a tuple of `Ord`s returns an `Ord` for the tuple.\n *\n * @example\n * import { tuple } from 'fp-ts/Ord'\n * import * as B from 'fp-ts/boolean'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n *\n * const O = tuple(S.Ord, N.Ord, B.Ord)\n * assert.strictEqual(O.compare(['a', 1, true], ['b', 2, true]), -1)\n * assert.strictEqual(O.compare(['a', 1, true], ['a', 2, true]), -1)\n * assert.strictEqual(O.compare(['a', 1, true], ['a', 1, false]), 1)\n *\n * @since 2.10.0\n */\nvar tuple = function () {\n    var ords = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        ords[_i] = arguments[_i];\n    }\n    return (0, exports.fromCompare)(function (first, second) {\n        var i = 0;\n        for (; i < ords.length - 1; i++) {\n            var r = ords[i].compare(first[i], second[i]);\n            if (r !== 0) {\n                return r;\n            }\n        }\n        return ords[i].compare(first[i], second[i]);\n    });\n};\nexports.tuple = tuple;\n/**\n * @since 2.10.0\n */\nvar reverse = function (O) { return (0, exports.fromCompare)(function (first, second) { return O.compare(second, first); }); };\nexports.reverse = reverse;\n/* istanbul ignore next */\nvar contramap_ = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.contramap)(f)); };\n/**\n * A typical use case for `contramap` would be like, given some `User` type, to construct an `Ord<User>`.\n *\n * We can do so with a function from `User -> X` where `X` is some value that we know how to compare\n * for ordering (meaning we have an `Ord<X>`)\n *\n * For example, given the following `User` type, there are lots of possible choices for `X`,\n * but let's say we want to sort a list of users by `lastName`.\n *\n * If we have a way of comparing `lastName`s for ordering (`ordLastName: Ord<string>`) and we know how to go from `User -> string`,\n * using `contramap` we can do this\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import { contramap, Ord } from 'fp-ts/Ord'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * interface User {\n *   readonly firstName: string\n *   readonly lastName: string\n * }\n *\n * const ordLastName: Ord<string> = S.Ord\n *\n * const ordByLastName: Ord<User> = pipe(\n *   ordLastName,\n *   contramap((user) => user.lastName)\n * )\n *\n * assert.deepStrictEqual(\n *   RA.sort(ordByLastName)([\n *     { firstName: 'a', lastName: 'd' },\n *     { firstName: 'c', lastName: 'b' }\n *   ]),\n *   [\n *     { firstName: 'c', lastName: 'b' },\n *     { firstName: 'a', lastName: 'd' }\n *   ]\n * )\n *\n * @since 2.0.0\n */\nvar contramap = function (f) { return function (fa) {\n    return (0, exports.fromCompare)(function (first, second) { return fa.compare(f(first), f(second)); });\n}; };\nexports.contramap = contramap;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexports.URI = 'Ord';\n/**\n * A typical use case for the `Semigroup` instance of `Ord` is merging two or more orderings.\n *\n * For example the following snippet builds an `Ord` for a type `User` which\n * sorts by `created` date descending, and **then** `lastName`\n *\n * @example\n * import * as D from 'fp-ts/Date'\n * import { pipe } from 'fp-ts/function'\n * import { contramap, getSemigroup, Ord, reverse } from 'fp-ts/Ord'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * interface User {\n *   readonly id: string\n *   readonly lastName: string\n *   readonly created: Date\n * }\n *\n * const ordByLastName: Ord<User> = pipe(\n *   S.Ord,\n *   contramap((user) => user.lastName)\n * )\n *\n * const ordByCreated: Ord<User> = pipe(\n *   D.Ord,\n *   contramap((user) => user.created)\n * )\n *\n * const ordUserByCreatedDescThenLastName = getSemigroup<User>().concat(\n *   reverse(ordByCreated),\n *   ordByLastName\n * )\n *\n * assert.deepStrictEqual(\n *   RA.sort(ordUserByCreatedDescThenLastName)([\n *     { id: 'c', lastName: 'd', created: new Date(1973, 10, 30) },\n *     { id: 'a', lastName: 'b', created: new Date(1973, 10, 30) },\n *     { id: 'e', lastName: 'f', created: new Date(1980, 10, 30) }\n *   ]),\n *   [\n *     { id: 'e', lastName: 'f', created: new Date(1980, 10, 30) },\n *     { id: 'a', lastName: 'b', created: new Date(1973, 10, 30) },\n *     { id: 'c', lastName: 'd', created: new Date(1973, 10, 30) }\n *   ]\n * )\n *\n * @category instances\n * @since 2.0.0\n */\nvar getSemigroup = function () { return ({\n    concat: function (first, second) {\n        return (0, exports.fromCompare)(function (a, b) {\n            var ox = first.compare(a, b);\n            return ox !== 0 ? ox : second.compare(a, b);\n        });\n    }\n}); };\nexports.getSemigroup = getSemigroup;\n/**\n * Returns a `Monoid` such that:\n *\n * - its `concat(ord1, ord2)` operation will order first by `ord1`, and then by `ord2`\n * - its `empty` value is an `Ord` that always considers compared elements equal\n *\n * @example\n * import { sort } from 'fp-ts/Array'\n * import { contramap, reverse, getMonoid } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as B from 'fp-ts/boolean'\n * import { pipe } from 'fp-ts/function'\n * import { concatAll } from 'fp-ts/Monoid'\n * import * as N from 'fp-ts/number'\n *\n * interface User {\n *   readonly id: number\n *   readonly name: string\n *   readonly age: number\n *   readonly rememberMe: boolean\n * }\n *\n * const byName = pipe(\n *   S.Ord,\n *   contramap((p: User) => p.name)\n * )\n *\n * const byAge = pipe(\n *   N.Ord,\n *   contramap((p: User) => p.age)\n * )\n *\n * const byRememberMe = pipe(\n *   B.Ord,\n *   contramap((p: User) => p.rememberMe)\n * )\n *\n * const M = getMonoid<User>()\n *\n * const users: Array<User> = [\n *   { id: 1, name: 'Guido', age: 47, rememberMe: false },\n *   { id: 2, name: 'Guido', age: 46, rememberMe: true },\n *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },\n *   { id: 4, name: 'Giulio', age: 44, rememberMe: true }\n * ]\n *\n * // sort by name, then by age, then by `rememberMe`\n * const O1 = concatAll(M)([byName, byAge, byRememberMe])\n * assert.deepStrictEqual(sort(O1)(users), [\n *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },\n *   { id: 4, name: 'Giulio', age: 44, rememberMe: true },\n *   { id: 2, name: 'Guido', age: 46, rememberMe: true },\n *   { id: 1, name: 'Guido', age: 47, rememberMe: false }\n * ])\n *\n * // now `rememberMe = true` first, then by name, then by age\n * const O2 = concatAll(M)([reverse(byRememberMe), byName, byAge])\n * assert.deepStrictEqual(sort(O2)(users), [\n *   { id: 4, name: 'Giulio', age: 44, rememberMe: true },\n *   { id: 2, name: 'Guido', age: 46, rememberMe: true },\n *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },\n *   { id: 1, name: 'Guido', age: 47, rememberMe: false }\n * ])\n *\n * @category instances\n * @since 2.4.0\n */\nvar getMonoid = function () { return ({\n    concat: (0, exports.getSemigroup)().concat,\n    empty: (0, exports.fromCompare)(function () { return 0; })\n}); };\nexports.getMonoid = getMonoid;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Contravariant = {\n    URI: exports.URI,\n    contramap: contramap_\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nexports.trivial = {\n    equals: function_1.constTrue,\n    compare: /*#__PURE__*/ (0, function_1.constant)(0)\n};\n/**\n * @since 2.11.0\n */\nvar equals = function (O) {\n    return function (second) {\n        return function (first) {\n            return first === second || O.compare(first, second) === 0;\n        };\n    };\n};\nexports.equals = equals;\n// TODO: curry in v3\n/**\n * Test whether one value is _strictly less than_ another\n *\n * @since 2.0.0\n */\nvar lt = function (O) {\n    return function (first, second) {\n        return O.compare(first, second) === -1;\n    };\n};\nexports.lt = lt;\n// TODO: curry in v3\n/**\n * Test whether one value is _strictly greater than_ another\n *\n * @since 2.0.0\n */\nvar gt = function (O) {\n    return function (first, second) {\n        return O.compare(first, second) === 1;\n    };\n};\nexports.gt = gt;\n// TODO: curry in v3\n/**\n * Test whether one value is _non-strictly less than_ another\n *\n * @since 2.0.0\n */\nvar leq = function (O) {\n    return function (first, second) {\n        return O.compare(first, second) !== 1;\n    };\n};\nexports.leq = leq;\n// TODO: curry in v3\n/**\n * Test whether one value is _non-strictly greater than_ another\n *\n * @since 2.0.0\n */\nvar geq = function (O) {\n    return function (first, second) {\n        return O.compare(first, second) !== -1;\n    };\n};\nexports.geq = geq;\n// TODO: curry in v3\n/**\n * Take the minimum of two values. If they are considered equal, the first argument is chosen\n *\n * @since 2.0.0\n */\nvar min = function (O) {\n    return function (first, second) {\n        return first === second || O.compare(first, second) < 1 ? first : second;\n    };\n};\nexports.min = min;\n// TODO: curry in v3\n/**\n * Take the maximum of two values. If they are considered equal, the first argument is chosen\n *\n * @since 2.0.0\n */\nvar max = function (O) {\n    return function (first, second) {\n        return first === second || O.compare(first, second) > -1 ? first : second;\n    };\n};\nexports.max = max;\n/**\n * Clamp a value between a minimum and a maximum\n *\n * @since 2.0.0\n */\nvar clamp = function (O) {\n    var minO = (0, exports.min)(O);\n    var maxO = (0, exports.max)(O);\n    return function (low, hi) { return function (a) { return maxO(minO(a, hi), low); }; };\n};\nexports.clamp = clamp;\n/**\n * Test whether a value is between a minimum and a maximum (inclusive)\n *\n * @since 2.0.0\n */\nvar between = function (O) {\n    var ltO = (0, exports.lt)(O);\n    var gtO = (0, exports.gt)(O);\n    return function (low, hi) { return function (a) { return ltO(a, low) || gtO(a, hi) ? false : true; }; };\n};\nexports.between = between;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use [`tuple`](#tuple) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getTupleOrd = exports.tuple;\n/**\n * Use [`reverse`](#reverse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getDualOrd = exports.reverse;\n/**\n * Use [`Contravariant`](#contravariant) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.ord = exports.Contravariant;\n// default compare for primitive types\nfunction compare(first, second) {\n    return first < second ? -1 : first > second ? 1 : 0;\n}\nvar strictOrd = {\n    equals: Eq_1.eqStrict.equals,\n    compare: compare\n};\n/**\n * Use [`Ord`](./boolean.ts.html#ord) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.ordBoolean = strictOrd;\n/**\n * Use [`Ord`](./string.ts.html#ord) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.ordString = strictOrd;\n/**\n * Use [`Ord`](./number.ts.html#ord) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.ordNumber = strictOrd;\n/**\n * Use [`Ord`](./Date.ts.html#ord) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.ordDate = (0, function_1.pipe)(exports.ordNumber, \n/*#__PURE__*/\n(0, exports.contramap)(function (date) { return date.valueOf(); }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcC10cy9saWIvT3JkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsR0FBRyxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyxrQkFBa0IsR0FBRyxXQUFXLEdBQUcsa0JBQWtCLEdBQUcsbUJBQW1CLEdBQUcsZUFBZSxHQUFHLGFBQWEsR0FBRyxXQUFXLEdBQUcsV0FBVyxHQUFHLFdBQVcsR0FBRyxXQUFXLEdBQUcsVUFBVSxHQUFHLFVBQVUsR0FBRyxjQUFjLEdBQUcsZUFBZSxHQUFHLHFCQUFxQixHQUFHLGlCQUFpQixHQUFHLG9CQUFvQixHQUFHLFdBQVcsR0FBRyxpQkFBaUIsR0FBRyxlQUFlLEdBQUcsYUFBYSxHQUFHLG1CQUFtQixHQUFHLHFCQUFxQjtBQUNqZCxXQUFXLG1CQUFPLENBQUMsZ0VBQU07QUFDekIsaUJBQWlCLG1CQUFPLENBQUMsNEVBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0Esd0NBQXdDO0FBQ3hDLENBQUM7QUFDRCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyREFBMkQsa0NBQWtDO0FBQzFILGVB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EseUNBQXlDLHdCQUF3QiIsInNvdXJjZXMiOlsiSTpcXFNjYWxhQ3Vyc292YXlhXFxCdW5rZXJXZWJcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXGZwLXRzXFxsaWJcXE9yZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMub3JkRGF0ZSA9IGV4cG9ydHMub3JkTnVtYmVyID0gZXhwb3J0cy5vcmRTdHJpbmcgPSBleHBvcnRzLm9yZEJvb2xlYW4gPSBleHBvcnRzLm9yZCA9IGV4cG9ydHMuZ2V0RHVhbE9yZCA9IGV4cG9ydHMuZ2V0VHVwbGVPcmQgPSBleHBvcnRzLmJldHdlZW4gPSBleHBvcnRzLmNsYW1wID0gZXhwb3J0cy5tYXggPSBleHBvcnRzLm1pbiA9IGV4cG9ydHMuZ2VxID0gZXhwb3J0cy5sZXEgPSBleHBvcnRzLmd0ID0gZXhwb3J0cy5sdCA9IGV4cG9ydHMuZXF1YWxzID0gZXhwb3J0cy50cml2aWFsID0gZXhwb3J0cy5Db250cmF2YXJpYW50ID0gZXhwb3J0cy5nZXRNb25vaWQgPSBleHBvcnRzLmdldFNlbWlncm91cCA9IGV4cG9ydHMuVVJJID0gZXhwb3J0cy5jb250cmFtYXAgPSBleHBvcnRzLnJldmVyc2UgPSBleHBvcnRzLnR1cGxlID0gZXhwb3J0cy5mcm9tQ29tcGFyZSA9IGV4cG9ydHMuZXF1YWxzRGVmYXVsdCA9IHZvaWQgMDtcbnZhciBFcV8xID0gcmVxdWlyZShcIi4vRXFcIik7XG52YXIgZnVuY3Rpb25fMSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9uXCIpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZGVmYXVsdHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogQGNhdGVnb3J5IGRlZmF1bHRzXG4gKiBAc2luY2UgMi4xMC4wXG4gKi9cbnZhciBlcXVhbHNEZWZhdWx0ID0gZnVuY3Rpb24gKGNvbXBhcmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0ID09PSBzZWNvbmQgfHwgY29tcGFyZShmaXJzdCwgc2Vjb25kKSA9PT0gMDtcbiAgICB9O1xufTtcbmV4cG9ydHMuZXF1YWxzRGVmYXVsdCA9IGVxdWFsc0RlZmF1bHQ7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBjb25zdHJ1Y3RvcnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICogQHNpbmNlIDIuMC4wXG4gKi9cbnZhciBmcm9tQ29tcGFyZSA9IGZ1bmN0aW9uIChjb21wYXJlKSB7IHJldHVybiAoe1xuICAgIGVxdWFsczogKDAsIGV4cG9ydHMuZXF1YWxzRGVmYXVsdCkoY29tcGFyZSksXG4gICAgY29tcGFyZTogZnVuY3Rpb24gKGZpcnN0LCBzZWNvbmQpIHsgcmV0dXJuIChmaXJzdCA9PT0gc2Vjb25kID8gMCA6IGNvbXBhcmUoZmlyc3QsIHNlY29uZCkpOyB9XG59KTsgfTtcbmV4cG9ydHMuZnJvbUNvbXBhcmUgPSBmcm9tQ29tcGFyZTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGNvbWJpbmF0b3JzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqIEdpdmVuIGEgdHVwbGUgb2YgYE9yZGBzIHJldHVybnMgYW4gYE9yZGAgZm9yIHRoZSB0dXBsZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgdHVwbGUgfSBmcm9tICdmcC10cy9PcmQnXG4gKiBpbXBvcnQgKiBhcyBCIGZyb20gJ2ZwLXRzL2Jvb2xlYW4nXG4gKiBpbXBvcnQgKiBhcyBTIGZyb20gJ2ZwLXRzL3N0cmluZydcbiAqIGltcG9ydCAqIGFzIE4gZnJvbSAnZnAtdHMvbnVtYmVyJ1xuICpcbiAqIGNvbnN0IE8gPSB0dXBsZShTLk9yZCwgTi5PcmQsIEIuT3JkKVxuICogYXNzZXJ0LnN0cmljdEVxdWFsKE8uY29tcGFyZShbJ2EnLCAxLCB0cnVlXSwgWydiJywgMiwgdHJ1ZV0pLCAtMSlcbiAqIGFzc2VydC5zdHJpY3RFcXVhbChPLmNvbXBhcmUoWydhJywgMSwgdHJ1ZV0sIFsnYScsIDIsIHRydWVdKSwgLTEpXG4gKiBhc3NlcnQuc3RyaWN0RXF1YWwoTy5jb21wYXJlKFsnYScsIDEsIHRydWVdLCBbJ2EnLCAxLCBmYWxzZV0pLCAxKVxuICpcbiAqIEBzaW5jZSAyLjEwLjBcbiAqL1xudmFyIHR1cGxlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcmRzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgb3Jkc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuZnJvbUNvbXBhcmUpKGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBvcmRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIHIgPSBvcmRzW2ldLmNvbXBhcmUoZmlyc3RbaV0sIHNlY29uZFtpXSk7XG4gICAgICAgICAgICBpZiAociAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmRzW2ldLmNvbXBhcmUoZmlyc3RbaV0sIHNlY29uZFtpXSk7XG4gICAgfSk7XG59O1xuZXhwb3J0cy50dXBsZSA9IHR1cGxlO1xuLyoqXG4gKiBAc2luY2UgMi4xMC4wXG4gKi9cbnZhciByZXZlcnNlID0gZnVuY3Rpb24gKE8pIHsgcmV0dXJuICgwLCBleHBvcnRzLmZyb21Db21wYXJlKShmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkgeyByZXR1cm4gTy5jb21wYXJlKHNlY29uZCwgZmlyc3QpOyB9KTsgfTtcbmV4cG9ydHMucmV2ZXJzZSA9IHJldmVyc2U7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xudmFyIGNvbnRyYW1hcF8gPSBmdW5jdGlvbiAoZmEsIGYpIHsgcmV0dXJuICgwLCBmdW5jdGlvbl8xLnBpcGUpKGZhLCAoMCwgZXhwb3J0cy5jb250cmFtYXApKGYpKTsgfTtcbi8qKlxuICogQSB0eXBpY2FsIHVzZSBjYXNlIGZvciBgY29udHJhbWFwYCB3b3VsZCBiZSBsaWtlLCBnaXZlbiBzb21lIGBVc2VyYCB0eXBlLCB0byBjb25zdHJ1Y3QgYW4gYE9yZDxVc2VyPmAuXG4gKlxuICogV2UgY2FuIGRvIHNvIHdpdGggYSBmdW5jdGlvbiBmcm9tIGBVc2VyIC0+IFhgIHdoZXJlIGBYYCBpcyBzb21lIHZhbHVlIHRoYXQgd2Uga25vdyBob3cgdG8gY29tcGFyZVxuICogZm9yIG9yZGVyaW5nIChtZWFuaW5nIHdlIGhhdmUgYW4gYE9yZDxYPmApXG4gKlxuICogRm9yIGV4YW1wbGUsIGdpdmVuIHRoZSBmb2xsb3dpbmcgYFVzZXJgIHR5cGUsIHRoZXJlIGFyZSBsb3RzIG9mIHBvc3NpYmxlIGNob2ljZXMgZm9yIGBYYCxcbiAqIGJ1dCBsZXQncyBzYXkgd2Ugd2FudCB0byBzb3J0IGEgbGlzdCBvZiB1c2VycyBieSBgbGFzdE5hbWVgLlxuICpcbiAqIElmIHdlIGhhdmUgYSB3YXkgb2YgY29tcGFyaW5nIGBsYXN0TmFtZWBzIGZvciBvcmRlcmluZyAoYG9yZExhc3ROYW1lOiBPcmQ8c3RyaW5nPmApIGFuZCB3ZSBrbm93IGhvdyB0byBnbyBmcm9tIGBVc2VyIC0+IHN0cmluZ2AsXG4gKiB1c2luZyBgY29udHJhbWFwYCB3ZSBjYW4gZG8gdGhpc1xuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBwaXBlIH0gZnJvbSAnZnAtdHMvZnVuY3Rpb24nXG4gKiBpbXBvcnQgeyBjb250cmFtYXAsIE9yZCB9IGZyb20gJ2ZwLXRzL09yZCdcbiAqIGltcG9ydCAqIGFzIFJBIGZyb20gJ2ZwLXRzL1JlYWRvbmx5QXJyYXknXG4gKiBpbXBvcnQgKiBhcyBTIGZyb20gJ2ZwLXRzL3N0cmluZydcbiAqXG4gKiBpbnRlcmZhY2UgVXNlciB7XG4gKiAgIHJlYWRvbmx5IGZpcnN0TmFtZTogc3RyaW5nXG4gKiAgIHJlYWRvbmx5IGxhc3ROYW1lOiBzdHJpbmdcbiAqIH1cbiAqXG4gKiBjb25zdCBvcmRMYXN0TmFtZTogT3JkPHN0cmluZz4gPSBTLk9yZFxuICpcbiAqIGNvbnN0IG9yZEJ5TGFzdE5hbWU6IE9yZDxVc2VyPiA9IHBpcGUoXG4gKiAgIG9yZExhc3ROYW1lLFxuICogICBjb250cmFtYXAoKHVzZXIpID0+IHVzZXIubGFzdE5hbWUpXG4gKiApXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChcbiAqICAgUkEuc29ydChvcmRCeUxhc3ROYW1lKShbXG4gKiAgICAgeyBmaXJzdE5hbWU6ICdhJywgbGFzdE5hbWU6ICdkJyB9LFxuICogICAgIHsgZmlyc3ROYW1lOiAnYycsIGxhc3ROYW1lOiAnYicgfVxuICogICBdKSxcbiAqICAgW1xuICogICAgIHsgZmlyc3ROYW1lOiAnYycsIGxhc3ROYW1lOiAnYicgfSxcbiAqICAgICB7IGZpcnN0TmFtZTogJ2EnLCBsYXN0TmFtZTogJ2QnIH1cbiAqICAgXVxuICogKVxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG52YXIgY29udHJhbWFwID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGZ1bmN0aW9uIChmYSkge1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy5mcm9tQ29tcGFyZSkoZnVuY3Rpb24gKGZpcnN0LCBzZWNvbmQpIHsgcmV0dXJuIGZhLmNvbXBhcmUoZihmaXJzdCksIGYoc2Vjb25kKSk7IH0pO1xufTsgfTtcbmV4cG9ydHMuY29udHJhbWFwID0gY29udHJhbWFwO1xuLyoqXG4gKiBAY2F0ZWdvcnkgdHlwZSBsYW1iZGFzXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0cy5VUkkgPSAnT3JkJztcbi8qKlxuICogQSB0eXBpY2FsIHVzZSBjYXNlIGZvciB0aGUgYFNlbWlncm91cGAgaW5zdGFuY2Ugb2YgYE9yZGAgaXMgbWVyZ2luZyB0d28gb3IgbW9yZSBvcmRlcmluZ3MuXG4gKlxuICogRm9yIGV4YW1wbGUgdGhlIGZvbGxvd2luZyBzbmlwcGV0IGJ1aWxkcyBhbiBgT3JkYCBmb3IgYSB0eXBlIGBVc2VyYCB3aGljaFxuICogc29ydHMgYnkgYGNyZWF0ZWRgIGRhdGUgZGVzY2VuZGluZywgYW5kICoqdGhlbioqIGBsYXN0TmFtZWBcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0ICogYXMgRCBmcm9tICdmcC10cy9EYXRlJ1xuICogaW1wb3J0IHsgcGlwZSB9IGZyb20gJ2ZwLXRzL2Z1bmN0aW9uJ1xuICogaW1wb3J0IHsgY29udHJhbWFwLCBnZXRTZW1pZ3JvdXAsIE9yZCwgcmV2ZXJzZSB9IGZyb20gJ2ZwLXRzL09yZCdcbiAqIGltcG9ydCAqIGFzIFJBIGZyb20gJ2ZwLXRzL1JlYWRvbmx5QXJyYXknXG4gKiBpbXBvcnQgKiBhcyBTIGZyb20gJ2ZwLXRzL3N0cmluZydcbiAqXG4gKiBpbnRlcmZhY2UgVXNlciB7XG4gKiAgIHJlYWRvbmx5IGlkOiBzdHJpbmdcbiAqICAgcmVhZG9ubHkgbGFzdE5hbWU6IHN0cmluZ1xuICogICByZWFkb25seSBjcmVhdGVkOiBEYXRlXG4gKiB9XG4gKlxuICogY29uc3Qgb3JkQnlMYXN0TmFtZTogT3JkPFVzZXI+ID0gcGlwZShcbiAqICAgUy5PcmQsXG4gKiAgIGNvbnRyYW1hcCgodXNlcikgPT4gdXNlci5sYXN0TmFtZSlcbiAqIClcbiAqXG4gKiBjb25zdCBvcmRCeUNyZWF0ZWQ6IE9yZDxVc2VyPiA9IHBpcGUoXG4gKiAgIEQuT3JkLFxuICogICBjb250cmFtYXAoKHVzZXIpID0+IHVzZXIuY3JlYXRlZClcbiAqIClcbiAqXG4gKiBjb25zdCBvcmRVc2VyQnlDcmVhdGVkRGVzY1RoZW5MYXN0TmFtZSA9IGdldFNlbWlncm91cDxVc2VyPigpLmNvbmNhdChcbiAqICAgcmV2ZXJzZShvcmRCeUNyZWF0ZWQpLFxuICogICBvcmRCeUxhc3ROYW1lXG4gKiApXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChcbiAqICAgUkEuc29ydChvcmRVc2VyQnlDcmVhdGVkRGVzY1RoZW5MYXN0TmFtZSkoW1xuICogICAgIHsgaWQ6ICdjJywgbGFzdE5hbWU6ICdkJywgY3JlYXRlZDogbmV3IERhdGUoMTk3MywgMTAsIDMwKSB9LFxuICogICAgIHsgaWQ6ICdhJywgbGFzdE5hbWU6ICdiJywgY3JlYXRlZDogbmV3IERhdGUoMTk3MywgMTAsIDMwKSB9LFxuICogICAgIHsgaWQ6ICdlJywgbGFzdE5hbWU6ICdmJywgY3JlYXRlZDogbmV3IERhdGUoMTk4MCwgMTAsIDMwKSB9XG4gKiAgIF0pLFxuICogICBbXG4gKiAgICAgeyBpZDogJ2UnLCBsYXN0TmFtZTogJ2YnLCBjcmVhdGVkOiBuZXcgRGF0ZSgxOTgwLCAxMCwgMzApIH0sXG4gKiAgICAgeyBpZDogJ2EnLCBsYXN0TmFtZTogJ2InLCBjcmVhdGVkOiBuZXcgRGF0ZSgxOTczLCAxMCwgMzApIH0sXG4gKiAgICAgeyBpZDogJ2MnLCBsYXN0TmFtZTogJ2QnLCBjcmVhdGVkOiBuZXcgRGF0ZSgxOTczLCAxMCwgMzApIH1cbiAqICAgXVxuICogKVxuICpcbiAqIEBjYXRlZ29yeSBpbnN0YW5jZXNcbiAqIEBzaW5jZSAyLjAuMFxuICovXG52YXIgZ2V0U2VtaWdyb3VwID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICBjb25jYXQ6IGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5mcm9tQ29tcGFyZSkoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBveCA9IGZpcnN0LmNvbXBhcmUoYSwgYik7XG4gICAgICAgICAgICByZXR1cm4gb3ggIT09IDAgPyBveCA6IHNlY29uZC5jb21wYXJlKGEsIGIpO1xuICAgICAgICB9KTtcbiAgICB9XG59KTsgfTtcbmV4cG9ydHMuZ2V0U2VtaWdyb3VwID0gZ2V0U2VtaWdyb3VwO1xuLyoqXG4gKiBSZXR1cm5zIGEgYE1vbm9pZGAgc3VjaCB0aGF0OlxuICpcbiAqIC0gaXRzIGBjb25jYXQob3JkMSwgb3JkMilgIG9wZXJhdGlvbiB3aWxsIG9yZGVyIGZpcnN0IGJ5IGBvcmQxYCwgYW5kIHRoZW4gYnkgYG9yZDJgXG4gKiAtIGl0cyBgZW1wdHlgIHZhbHVlIGlzIGFuIGBPcmRgIHRoYXQgYWx3YXlzIGNvbnNpZGVycyBjb21wYXJlZCBlbGVtZW50cyBlcXVhbFxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBzb3J0IH0gZnJvbSAnZnAtdHMvQXJyYXknXG4gKiBpbXBvcnQgeyBjb250cmFtYXAsIHJldmVyc2UsIGdldE1vbm9pZCB9IGZyb20gJ2ZwLXRzL09yZCdcbiAqIGltcG9ydCAqIGFzIFMgZnJvbSAnZnAtdHMvc3RyaW5nJ1xuICogaW1wb3J0ICogYXMgQiBmcm9tICdmcC10cy9ib29sZWFuJ1xuICogaW1wb3J0IHsgcGlwZSB9IGZyb20gJ2ZwLXRzL2Z1bmN0aW9uJ1xuICogaW1wb3J0IHsgY29uY2F0QWxsIH0gZnJvbSAnZnAtdHMvTW9ub2lkJ1xuICogaW1wb3J0ICogYXMgTiBmcm9tICdmcC10cy9udW1iZXInXG4gKlxuICogaW50ZXJmYWNlIFVzZXIge1xuICogICByZWFkb25seSBpZDogbnVtYmVyXG4gKiAgIHJlYWRvbmx5IG5hbWU6IHN0cmluZ1xuICogICByZWFkb25seSBhZ2U6IG51bWJlclxuICogICByZWFkb25seSByZW1lbWJlck1lOiBib29sZWFuXG4gKiB9XG4gKlxuICogY29uc3QgYnlOYW1lID0gcGlwZShcbiAqICAgUy5PcmQsXG4gKiAgIGNvbnRyYW1hcCgocDogVXNlcikgPT4gcC5uYW1lKVxuICogKVxuICpcbiAqIGNvbnN0IGJ5QWdlID0gcGlwZShcbiAqICAgTi5PcmQsXG4gKiAgIGNvbnRyYW1hcCgocDogVXNlcikgPT4gcC5hZ2UpXG4gKiApXG4gKlxuICogY29uc3QgYnlSZW1lbWJlck1lID0gcGlwZShcbiAqICAgQi5PcmQsXG4gKiAgIGNvbnRyYW1hcCgocDogVXNlcikgPT4gcC5yZW1lbWJlck1lKVxuICogKVxuICpcbiAqIGNvbnN0IE0gPSBnZXRNb25vaWQ8VXNlcj4oKVxuICpcbiAqIGNvbnN0IHVzZXJzOiBBcnJheTxVc2VyPiA9IFtcbiAqICAgeyBpZDogMSwgbmFtZTogJ0d1aWRvJywgYWdlOiA0NywgcmVtZW1iZXJNZTogZmFsc2UgfSxcbiAqICAgeyBpZDogMiwgbmFtZTogJ0d1aWRvJywgYWdlOiA0NiwgcmVtZW1iZXJNZTogdHJ1ZSB9LFxuICogICB7IGlkOiAzLCBuYW1lOiAnR2l1bGlvJywgYWdlOiA0NCwgcmVtZW1iZXJNZTogZmFsc2UgfSxcbiAqICAgeyBpZDogNCwgbmFtZTogJ0dpdWxpbycsIGFnZTogNDQsIHJlbWVtYmVyTWU6IHRydWUgfVxuICogXVxuICpcbiAqIC8vIHNvcnQgYnkgbmFtZSwgdGhlbiBieSBhZ2UsIHRoZW4gYnkgYHJlbWVtYmVyTWVgXG4gKiBjb25zdCBPMSA9IGNvbmNhdEFsbChNKShbYnlOYW1lLCBieUFnZSwgYnlSZW1lbWJlck1lXSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoc29ydChPMSkodXNlcnMpLCBbXG4gKiAgIHsgaWQ6IDMsIG5hbWU6ICdHaXVsaW8nLCBhZ2U6IDQ0LCByZW1lbWJlck1lOiBmYWxzZSB9LFxuICogICB7IGlkOiA0LCBuYW1lOiAnR2l1bGlvJywgYWdlOiA0NCwgcmVtZW1iZXJNZTogdHJ1ZSB9LFxuICogICB7IGlkOiAyLCBuYW1lOiAnR3VpZG8nLCBhZ2U6IDQ2LCByZW1lbWJlck1lOiB0cnVlIH0sXG4gKiAgIHsgaWQ6IDEsIG5hbWU6ICdHdWlkbycsIGFnZTogNDcsIHJlbWVtYmVyTWU6IGZhbHNlIH1cbiAqIF0pXG4gKlxuICogLy8gbm93IGByZW1lbWJlck1lID0gdHJ1ZWAgZmlyc3QsIHRoZW4gYnkgbmFtZSwgdGhlbiBieSBhZ2VcbiAqIGNvbnN0IE8yID0gY29uY2F0QWxsKE0pKFtyZXZlcnNlKGJ5UmVtZW1iZXJNZSksIGJ5TmFtZSwgYnlBZ2VdKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChzb3J0KE8yKSh1c2VycyksIFtcbiAqICAgeyBpZDogNCwgbmFtZTogJ0dpdWxpbycsIGFnZTogNDQsIHJlbWVtYmVyTWU6IHRydWUgfSxcbiAqICAgeyBpZDogMiwgbmFtZTogJ0d1aWRvJywgYWdlOiA0NiwgcmVtZW1iZXJNZTogdHJ1ZSB9LFxuICogICB7IGlkOiAzLCBuYW1lOiAnR2l1bGlvJywgYWdlOiA0NCwgcmVtZW1iZXJNZTogZmFsc2UgfSxcbiAqICAgeyBpZDogMSwgbmFtZTogJ0d1aWRvJywgYWdlOiA0NywgcmVtZW1iZXJNZTogZmFsc2UgfVxuICogXSlcbiAqXG4gKiBAY2F0ZWdvcnkgaW5zdGFuY2VzXG4gKiBAc2luY2UgMi40LjBcbiAqL1xudmFyIGdldE1vbm9pZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgY29uY2F0OiAoMCwgZXhwb3J0cy5nZXRTZW1pZ3JvdXApKCkuY29uY2F0LFxuICAgIGVtcHR5OiAoMCwgZXhwb3J0cy5mcm9tQ29tcGFyZSkoZnVuY3Rpb24gKCkgeyByZXR1cm4gMDsgfSlcbn0pOyB9O1xuZXhwb3J0cy5nZXRNb25vaWQgPSBnZXRNb25vaWQ7XG4vKipcbiAqIEBjYXRlZ29yeSBpbnN0YW5jZXNcbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnRzLkNvbnRyYXZhcmlhbnQgPSB7XG4gICAgVVJJOiBleHBvcnRzLlVSSSxcbiAgICBjb250cmFtYXA6IGNvbnRyYW1hcF9cbn07XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB1dGlsc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBAc2luY2UgMi4xMS4wXG4gKi9cbmV4cG9ydHMudHJpdmlhbCA9IHtcbiAgICBlcXVhbHM6IGZ1bmN0aW9uXzEuY29uc3RUcnVlLFxuICAgIGNvbXBhcmU6IC8qI19fUFVSRV9fKi8gKDAsIGZ1bmN0aW9uXzEuY29uc3RhbnQpKDApXG59O1xuLyoqXG4gKiBAc2luY2UgMi4xMS4wXG4gKi9cbnZhciBlcXVhbHMgPSBmdW5jdGlvbiAoTykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc2Vjb25kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZmlyc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdCA9PT0gc2Vjb25kIHx8IE8uY29tcGFyZShmaXJzdCwgc2Vjb25kKSA9PT0gMDtcbiAgICAgICAgfTtcbiAgICB9O1xufTtcbmV4cG9ydHMuZXF1YWxzID0gZXF1YWxzO1xuLy8gVE9ETzogY3VycnkgaW4gdjNcbi8qKlxuICogVGVzdCB3aGV0aGVyIG9uZSB2YWx1ZSBpcyBfc3RyaWN0bHkgbGVzcyB0aGFuXyBhbm90aGVyXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbnZhciBsdCA9IGZ1bmN0aW9uIChPKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgIHJldHVybiBPLmNvbXBhcmUoZmlyc3QsIHNlY29uZCkgPT09IC0xO1xuICAgIH07XG59O1xuZXhwb3J0cy5sdCA9IGx0O1xuLy8gVE9ETzogY3VycnkgaW4gdjNcbi8qKlxuICogVGVzdCB3aGV0aGVyIG9uZSB2YWx1ZSBpcyBfc3RyaWN0bHkgZ3JlYXRlciB0aGFuXyBhbm90aGVyXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbnZhciBndCA9IGZ1bmN0aW9uIChPKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgIHJldHVybiBPLmNvbXBhcmUoZmlyc3QsIHNlY29uZCkgPT09IDE7XG4gICAgfTtcbn07XG5leHBvcnRzLmd0ID0gZ3Q7XG4vLyBUT0RPOiBjdXJyeSBpbiB2M1xuLyoqXG4gKiBUZXN0IHdoZXRoZXIgb25lIHZhbHVlIGlzIF9ub24tc3RyaWN0bHkgbGVzcyB0aGFuXyBhbm90aGVyXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbnZhciBsZXEgPSBmdW5jdGlvbiAoTykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICByZXR1cm4gTy5jb21wYXJlKGZpcnN0LCBzZWNvbmQpICE9PSAxO1xuICAgIH07XG59O1xuZXhwb3J0cy5sZXEgPSBsZXE7XG4vLyBUT0RPOiBjdXJyeSBpbiB2M1xuLyoqXG4gKiBUZXN0IHdoZXRoZXIgb25lIHZhbHVlIGlzIF9ub24tc3RyaWN0bHkgZ3JlYXRlciB0aGFuXyBhbm90aGVyXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbnZhciBnZXEgPSBmdW5jdGlvbiAoTykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICByZXR1cm4gTy5jb21wYXJlKGZpcnN0LCBzZWNvbmQpICE9PSAtMTtcbiAgICB9O1xufTtcbmV4cG9ydHMuZ2VxID0gZ2VxO1xuLy8gVE9ETzogY3VycnkgaW4gdjNcbi8qKlxuICogVGFrZSB0aGUgbWluaW11bSBvZiB0d28gdmFsdWVzLiBJZiB0aGV5IGFyZSBjb25zaWRlcmVkIGVxdWFsLCB0aGUgZmlyc3QgYXJndW1lbnQgaXMgY2hvc2VuXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbnZhciBtaW4gPSBmdW5jdGlvbiAoTykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICByZXR1cm4gZmlyc3QgPT09IHNlY29uZCB8fCBPLmNvbXBhcmUoZmlyc3QsIHNlY29uZCkgPCAxID8gZmlyc3QgOiBzZWNvbmQ7XG4gICAgfTtcbn07XG5leHBvcnRzLm1pbiA9IG1pbjtcbi8vIFRPRE86IGN1cnJ5IGluIHYzXG4vKipcbiAqIFRha2UgdGhlIG1heGltdW0gb2YgdHdvIHZhbHVlcy4gSWYgdGhleSBhcmUgY29uc2lkZXJlZCBlcXVhbCwgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGNob3NlblxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG52YXIgbWF4ID0gZnVuY3Rpb24gKE8pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0ID09PSBzZWNvbmQgfHwgTy5jb21wYXJlKGZpcnN0LCBzZWNvbmQpID4gLTEgPyBmaXJzdCA6IHNlY29uZDtcbiAgICB9O1xufTtcbmV4cG9ydHMubWF4ID0gbWF4O1xuLyoqXG4gKiBDbGFtcCBhIHZhbHVlIGJldHdlZW4gYSBtaW5pbXVtIGFuZCBhIG1heGltdW1cbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xudmFyIGNsYW1wID0gZnVuY3Rpb24gKE8pIHtcbiAgICB2YXIgbWluTyA9ICgwLCBleHBvcnRzLm1pbikoTyk7XG4gICAgdmFyIG1heE8gPSAoMCwgZXhwb3J0cy5tYXgpKE8pO1xuICAgIHJldHVybiBmdW5jdGlvbiAobG93LCBoaSkgeyByZXR1cm4gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIG1heE8obWluTyhhLCBoaSksIGxvdyk7IH07IH07XG59O1xuZXhwb3J0cy5jbGFtcCA9IGNsYW1wO1xuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYSB2YWx1ZSBpcyBiZXR3ZWVuIGEgbWluaW11bSBhbmQgYSBtYXhpbXVtIChpbmNsdXNpdmUpXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbnZhciBiZXR3ZWVuID0gZnVuY3Rpb24gKE8pIHtcbiAgICB2YXIgbHRPID0gKDAsIGV4cG9ydHMubHQpKE8pO1xuICAgIHZhciBndE8gPSAoMCwgZXhwb3J0cy5ndCkoTyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChsb3csIGhpKSB7IHJldHVybiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gbHRPKGEsIGxvdykgfHwgZ3RPKGEsIGhpKSA/IGZhbHNlIDogdHJ1ZTsgfTsgfTtcbn07XG5leHBvcnRzLmJldHdlZW4gPSBiZXR3ZWVuO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZGVwcmVjYXRlZFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBVc2UgW2B0dXBsZWBdKCN0dXBsZSkgaW5zdGVhZC5cbiAqXG4gKiBAY2F0ZWdvcnkgem9uZSBvZiBkZWF0aFxuICogQHNpbmNlIDIuMC4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnRzLmdldFR1cGxlT3JkID0gZXhwb3J0cy50dXBsZTtcbi8qKlxuICogVXNlIFtgcmV2ZXJzZWBdKCNyZXZlcnNlKSBpbnN0ZWFkLlxuICpcbiAqIEBjYXRlZ29yeSB6b25lIG9mIGRlYXRoXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydHMuZ2V0RHVhbE9yZCA9IGV4cG9ydHMucmV2ZXJzZTtcbi8qKlxuICogVXNlIFtgQ29udHJhdmFyaWFudGBdKCNjb250cmF2YXJpYW50KSBpbnN0ZWFkLlxuICpcbiAqIEBjYXRlZ29yeSB6b25lIG9mIGRlYXRoXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydHMub3JkID0gZXhwb3J0cy5Db250cmF2YXJpYW50O1xuLy8gZGVmYXVsdCBjb21wYXJlIGZvciBwcmltaXRpdmUgdHlwZXNcbmZ1bmN0aW9uIGNvbXBhcmUoZmlyc3QsIHNlY29uZCkge1xuICAgIHJldHVybiBmaXJzdCA8IHNlY29uZCA/IC0xIDogZmlyc3QgPiBzZWNvbmQgPyAxIDogMDtcbn1cbnZhciBzdHJpY3RPcmQgPSB7XG4gICAgZXF1YWxzOiBFcV8xLmVxU3RyaWN0LmVxdWFscyxcbiAgICBjb21wYXJlOiBjb21wYXJlXG59O1xuLyoqXG4gKiBVc2UgW2BPcmRgXSguL2Jvb2xlYW4udHMuaHRtbCNvcmQpIGluc3RlYWQuXG4gKlxuICogQGNhdGVnb3J5IHpvbmUgb2YgZGVhdGhcbiAqIEBzaW5jZSAyLjAuMFxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0cy5vcmRCb29sZWFuID0gc3RyaWN0T3JkO1xuLyoqXG4gKiBVc2UgW2BPcmRgXSguL3N0cmluZy50cy5odG1sI29yZCkgaW5zdGVhZC5cbiAqXG4gKiBAY2F0ZWdvcnkgem9uZSBvZiBkZWF0aFxuICogQHNpbmNlIDIuMC4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnRzLm9yZFN0cmluZyA9IHN0cmljdE9yZDtcbi8qKlxuICogVXNlIFtgT3JkYF0oLi9udW1iZXIudHMuaHRtbCNvcmQpIGluc3RlYWQuXG4gKlxuICogQGNhdGVnb3J5IHpvbmUgb2YgZGVhdGhcbiAqIEBzaW5jZSAyLjAuMFxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0cy5vcmROdW1iZXIgPSBzdHJpY3RPcmQ7XG4vKipcbiAqIFVzZSBbYE9yZGBdKC4vRGF0ZS50cy5odG1sI29yZCkgaW5zdGVhZC5cbiAqXG4gKiBAY2F0ZWdvcnkgem9uZSBvZiBkZWF0aFxuICogQHNpbmNlIDIuMC4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnRzLm9yZERhdGUgPSAoMCwgZnVuY3Rpb25fMS5waXBlKShleHBvcnRzLm9yZE51bWJlciwgXG4vKiNfX1BVUkVfXyovXG4oMCwgZXhwb3J0cy5jb250cmFtYXApKGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLnZhbHVlT2YoKTsgfSkpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fp-ts/lib/Ord.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fp-ts/lib/Predicate.js":
/*!*********************************************!*\
  !*** ./node_modules/fp-ts/lib/Predicate.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.and = exports.or = exports.not = exports.Contravariant = exports.getMonoidAll = exports.getSemigroupAll = exports.getMonoidAny = exports.getSemigroupAny = exports.URI = exports.contramap = void 0;\nvar function_1 = __webpack_require__(/*! ./function */ \"(app-pages-browser)/./node_modules/fp-ts/lib/function.js\");\nvar contramap_ = function (predicate, f) { return (0, function_1.pipe)(predicate, (0, exports.contramap)(f)); };\n/**\n * @since 2.11.0\n */\nvar contramap = function (f) {\n    return function (predicate) {\n        return (0, function_1.flow)(f, predicate);\n    };\n};\nexports.contramap = contramap;\n/**\n * @category type lambdas\n * @since 2.11.0\n */\nexports.URI = 'Predicate';\n/**\n * @category instances\n * @since 2.11.0\n */\nvar getSemigroupAny = function () { return ({\n    concat: function (first, second) { return (0, function_1.pipe)(first, (0, exports.or)(second)); }\n}); };\nexports.getSemigroupAny = getSemigroupAny;\n/**\n * @category instances\n * @since 2.11.0\n */\nvar getMonoidAny = function () { return ({\n    concat: (0, exports.getSemigroupAny)().concat,\n    empty: function_1.constFalse\n}); };\nexports.getMonoidAny = getMonoidAny;\n/**\n * @category instances\n * @since 2.11.0\n */\nvar getSemigroupAll = function () { return ({\n    concat: function (first, second) { return (0, function_1.pipe)(first, (0, exports.and)(second)); }\n}); };\nexports.getSemigroupAll = getSemigroupAll;\n/**\n * @category instances\n * @since 2.11.0\n */\nvar getMonoidAll = function () { return ({\n    concat: (0, exports.getSemigroupAll)().concat,\n    empty: function_1.constTrue\n}); };\nexports.getMonoidAll = getMonoidAll;\n/**\n * @category instances\n * @since 2.11.0\n */\nexports.Contravariant = {\n    URI: exports.URI,\n    contramap: contramap_\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nvar not = function (predicate) {\n    return function (a) {\n        return !predicate(a);\n    };\n};\nexports.not = not;\n/**\n * @since 2.11.0\n */\nvar or = function (second) {\n    return function (first) {\n        return function (a) {\n            return first(a) || second(a);\n        };\n    };\n};\nexports.or = or;\n/**\n * @since 2.11.0\n */\nvar and = function (second) {\n    return function (first) {\n        return function (a) {\n            return first(a) && second(a);\n        };\n    };\n};\nexports.and = and;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcC10cy9saWIvUHJlZGljYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFdBQVcsR0FBRyxVQUFVLEdBQUcsV0FBVyxHQUFHLHFCQUFxQixHQUFHLG9CQUFvQixHQUFHLHVCQUF1QixHQUFHLG9CQUFvQixHQUFHLHVCQUF1QixHQUFHLFdBQVcsR0FBRyxpQkFBaUI7QUFDbE0saUJBQWlCLG1CQUFPLENBQUMsNEVBQVk7QUFDckMsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsdUNBQXVDO0FBQ3ZDLENBQUM7QUFDRCx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLENBQUM7QUFDRCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsdUNBQXVDO0FBQ3ZDLENBQUM7QUFDRCx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLENBQUM7QUFDRCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVciLCJzb3VyY2VzIjpbIkk6XFxTY2FsYUN1cnNvdmF5YVxcQnVua2VyV2ViXFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxmcC10c1xcbGliXFxQcmVkaWNhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFuZCA9IGV4cG9ydHMub3IgPSBleHBvcnRzLm5vdCA9IGV4cG9ydHMuQ29udHJhdmFyaWFudCA9IGV4cG9ydHMuZ2V0TW9ub2lkQWxsID0gZXhwb3J0cy5nZXRTZW1pZ3JvdXBBbGwgPSBleHBvcnRzLmdldE1vbm9pZEFueSA9IGV4cG9ydHMuZ2V0U2VtaWdyb3VwQW55ID0gZXhwb3J0cy5VUkkgPSBleHBvcnRzLmNvbnRyYW1hcCA9IHZvaWQgMDtcbnZhciBmdW5jdGlvbl8xID0gcmVxdWlyZShcIi4vZnVuY3Rpb25cIik7XG52YXIgY29udHJhbWFwXyA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIGYpIHsgcmV0dXJuICgwLCBmdW5jdGlvbl8xLnBpcGUpKHByZWRpY2F0ZSwgKDAsIGV4cG9ydHMuY29udHJhbWFwKShmKSk7IH07XG4vKipcbiAqIEBzaW5jZSAyLjExLjBcbiAqL1xudmFyIGNvbnRyYW1hcCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcbiAgICAgICAgcmV0dXJuICgwLCBmdW5jdGlvbl8xLmZsb3cpKGYsIHByZWRpY2F0ZSk7XG4gICAgfTtcbn07XG5leHBvcnRzLmNvbnRyYW1hcCA9IGNvbnRyYW1hcDtcbi8qKlxuICogQGNhdGVnb3J5IHR5cGUgbGFtYmRhc1xuICogQHNpbmNlIDIuMTEuMFxuICovXG5leHBvcnRzLlVSSSA9ICdQcmVkaWNhdGUnO1xuLyoqXG4gKiBAY2F0ZWdvcnkgaW5zdGFuY2VzXG4gKiBAc2luY2UgMi4xMS4wXG4gKi9cbnZhciBnZXRTZW1pZ3JvdXBBbnkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgIGNvbmNhdDogZnVuY3Rpb24gKGZpcnN0LCBzZWNvbmQpIHsgcmV0dXJuICgwLCBmdW5jdGlvbl8xLnBpcGUpKGZpcnN0LCAoMCwgZXhwb3J0cy5vcikoc2Vjb25kKSk7IH1cbn0pOyB9O1xuZXhwb3J0cy5nZXRTZW1pZ3JvdXBBbnkgPSBnZXRTZW1pZ3JvdXBBbnk7XG4vKipcbiAqIEBjYXRlZ29yeSBpbnN0YW5jZXNcbiAqIEBzaW5jZSAyLjExLjBcbiAqL1xudmFyIGdldE1vbm9pZEFueSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgY29uY2F0OiAoMCwgZXhwb3J0cy5nZXRTZW1pZ3JvdXBBbnkpKCkuY29uY2F0LFxuICAgIGVtcHR5OiBmdW5jdGlvbl8xLmNvbnN0RmFsc2Vcbn0pOyB9O1xuZXhwb3J0cy5nZXRNb25vaWRBbnkgPSBnZXRNb25vaWRBbnk7XG4vKipcbiAqIEBjYXRlZ29yeSBpbnN0YW5jZXNcbiAqIEBzaW5jZSAyLjExLjBcbiAqL1xudmFyIGdldFNlbWlncm91cEFsbCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgY29uY2F0OiBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkgeyByZXR1cm4gKDAsIGZ1bmN0aW9uXzEucGlwZSkoZmlyc3QsICgwLCBleHBvcnRzLmFuZCkoc2Vjb25kKSk7IH1cbn0pOyB9O1xuZXhwb3J0cy5nZXRTZW1pZ3JvdXBBbGwgPSBnZXRTZW1pZ3JvdXBBbGw7XG4vKipcbiAqIEBjYXRlZ29yeSBpbnN0YW5jZXNcbiAqIEBzaW5jZSAyLjExLjBcbiAqL1xudmFyIGdldE1vbm9pZEFsbCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgY29uY2F0OiAoMCwgZXhwb3J0cy5nZXRTZW1pZ3JvdXBBbGwpKCkuY29uY2F0LFxuICAgIGVtcHR5OiBmdW5jdGlvbl8xLmNvbnN0VHJ1ZVxufSk7IH07XG5leHBvcnRzLmdldE1vbm9pZEFsbCA9IGdldE1vbm9pZEFsbDtcbi8qKlxuICogQGNhdGVnb3J5IGluc3RhbmNlc1xuICogQHNpbmNlIDIuMTEuMFxuICovXG5leHBvcnRzLkNvbnRyYXZhcmlhbnQgPSB7XG4gICAgVVJJOiBleHBvcnRzLlVSSSxcbiAgICBjb250cmFtYXA6IGNvbnRyYW1hcF9cbn07XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB1dGlsc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBAc2luY2UgMi4xMS4wXG4gKi9cbnZhciBub3QgPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiAhcHJlZGljYXRlKGEpO1xuICAgIH07XG59O1xuZXhwb3J0cy5ub3QgPSBub3Q7XG4vKipcbiAqIEBzaW5jZSAyLjExLjBcbiAqL1xudmFyIG9yID0gZnVuY3Rpb24gKHNlY29uZCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZmlyc3QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3QoYSkgfHwgc2Vjb25kKGEpO1xuICAgICAgICB9O1xuICAgIH07XG59O1xuZXhwb3J0cy5vciA9IG9yO1xuLyoqXG4gKiBAc2luY2UgMi4xMS4wXG4gKi9cbnZhciBhbmQgPSBmdW5jdGlvbiAoc2Vjb25kKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChmaXJzdCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdChhKSAmJiBzZWNvbmQoYSk7XG4gICAgICAgIH07XG4gICAgfTtcbn07XG5leHBvcnRzLmFuZCA9IGFuZDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fp-ts/lib/Predicate.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fp-ts/lib/Semigroup.js":
/*!*********************************************!*\
  !*** ./node_modules/fp-ts/lib/Semigroup.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.semigroupProduct = exports.semigroupSum = exports.semigroupString = exports.getFunctionSemigroup = exports.semigroupAny = exports.semigroupAll = exports.getIntercalateSemigroup = exports.getMeetSemigroup = exports.getJoinSemigroup = exports.getDualSemigroup = exports.getStructSemigroup = exports.getTupleSemigroup = exports.getFirstSemigroup = exports.getLastSemigroup = exports.getObjectSemigroup = exports.semigroupVoid = exports.concatAll = exports.last = exports.first = exports.intercalate = exports.tuple = exports.struct = exports.reverse = exports.constant = exports.max = exports.min = void 0;\nexports.fold = fold;\n/**\n * If a type `A` can form a `Semigroup` it has an **associative** binary operation.\n *\n * ```ts\n * interface Semigroup<A> {\n *   readonly concat: (x: A, y: A) => A\n * }\n * ```\n *\n * Associativity means the following equality must hold for any choice of `x`, `y`, and `z`.\n *\n * ```ts\n * concat(x, concat(y, z)) = concat(concat(x, y), z)\n * ```\n *\n * A common example of a semigroup is the type `string` with the operation `+`.\n *\n * ```ts\n * import { Semigroup } from 'fp-ts/Semigroup'\n *\n * const semigroupString: Semigroup<string> = {\n *   concat: (x, y) => x + y\n * }\n *\n * const x = 'x'\n * const y = 'y'\n * const z = 'z'\n *\n * semigroupString.concat(x, y) // 'xy'\n *\n * semigroupString.concat(x, semigroupString.concat(y, z)) // 'xyz'\n *\n * semigroupString.concat(semigroupString.concat(x, y), z) // 'xyz'\n * ```\n *\n * *Adapted from https://typelevel.org/cats*\n *\n * @since 2.0.0\n */\nvar function_1 = __webpack_require__(/*! ./function */ \"(app-pages-browser)/./node_modules/fp-ts/lib/function.js\");\nvar _ = __importStar(__webpack_require__(/*! ./internal */ \"(app-pages-browser)/./node_modules/fp-ts/lib/internal.js\"));\nvar M = __importStar(__webpack_require__(/*! ./Magma */ \"(app-pages-browser)/./node_modules/fp-ts/lib/Magma.js\"));\nvar Or = __importStar(__webpack_require__(/*! ./Ord */ \"(app-pages-browser)/./node_modules/fp-ts/lib/Ord.js\"));\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Get a semigroup where `concat` will return the minimum, based on the provided order.\n *\n * @example\n * import * as N from 'fp-ts/number'\n * import * as S from 'fp-ts/Semigroup'\n *\n * const S1 = S.min(N.Ord)\n *\n * assert.deepStrictEqual(S1.concat(1, 2), 1)\n *\n * @category constructors\n * @since 2.10.0\n */\nvar min = function (O) { return ({\n    concat: Or.min(O)\n}); };\nexports.min = min;\n/**\n * Get a semigroup where `concat` will return the maximum, based on the provided order.\n *\n * @example\n * import * as N from 'fp-ts/number'\n * import * as S from 'fp-ts/Semigroup'\n *\n * const S1 = S.max(N.Ord)\n *\n * assert.deepStrictEqual(S1.concat(1, 2), 2)\n *\n * @category constructors\n * @since 2.10.0\n */\nvar max = function (O) { return ({\n    concat: Or.max(O)\n}); };\nexports.max = max;\n/**\n * @category constructors\n * @since 2.10.0\n */\nvar constant = function (a) { return ({\n    concat: function () { return a; }\n}); };\nexports.constant = constant;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * The dual of a `Semigroup`, obtained by swapping the arguments of `concat`.\n *\n * @example\n * import { reverse } from 'fp-ts/Semigroup'\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(reverse(S.Semigroup).concat('a', 'b'), 'ba')\n *\n * @since 2.10.0\n */\nexports.reverse = M.reverse;\n/**\n * Given a struct of semigroups returns a semigroup for the struct.\n *\n * @example\n * import { struct } from 'fp-ts/Semigroup'\n * import * as N from 'fp-ts/number'\n *\n * interface Point {\n *   readonly x: number\n *   readonly y: number\n * }\n *\n * const S = struct<Point>({\n *   x: N.SemigroupSum,\n *   y: N.SemigroupSum\n * })\n *\n * assert.deepStrictEqual(S.concat({ x: 1, y: 2 }, { x: 3, y: 4 }), { x: 4, y: 6 })\n *\n * @since 2.10.0\n */\nvar struct = function (semigroups) { return ({\n    concat: function (first, second) {\n        var r = {};\n        for (var k in semigroups) {\n            if (_.has.call(semigroups, k)) {\n                r[k] = semigroups[k].concat(first[k], second[k]);\n            }\n        }\n        return r;\n    }\n}); };\nexports.struct = struct;\n/**\n * Given a tuple of semigroups returns a semigroup for the tuple.\n *\n * @example\n * import { tuple } from 'fp-ts/Semigroup'\n * import * as B from 'fp-ts/boolean'\n * import * as N from 'fp-ts/number'\n * import * as S from 'fp-ts/string'\n *\n * const S1 = tuple(S.Semigroup, N.SemigroupSum)\n * assert.deepStrictEqual(S1.concat(['a', 1], ['b', 2]), ['ab', 3])\n *\n * const S2 = tuple(S.Semigroup, N.SemigroupSum, B.SemigroupAll)\n * assert.deepStrictEqual(S2.concat(['a', 1, true], ['b', 2, false]), ['ab', 3, false])\n *\n * @since 2.10.0\n */\nvar tuple = function () {\n    var semigroups = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        semigroups[_i] = arguments[_i];\n    }\n    return ({\n        concat: function (first, second) { return semigroups.map(function (s, i) { return s.concat(first[i], second[i]); }); }\n    });\n};\nexports.tuple = tuple;\n/**\n * Between each pair of elements insert `middle`.\n *\n * @example\n * import { intercalate } from 'fp-ts/Semigroup'\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * const S1 = pipe(S.Semigroup, intercalate(' + '))\n *\n * assert.strictEqual(S1.concat('a', 'b'), 'a + b')\n *\n * @since 2.10.0\n */\nvar intercalate = function (middle) {\n    return function (S) { return ({\n        concat: function (x, y) { return S.concat(x, S.concat(middle, y)); }\n    }); };\n};\nexports.intercalate = intercalate;\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * Always return the first argument.\n *\n * @example\n * import * as S from 'fp-ts/Semigroup'\n *\n * assert.deepStrictEqual(S.first<number>().concat(1, 2), 1)\n *\n * @category instances\n * @since 2.10.0\n */\nvar first = function () { return ({ concat: function_1.identity }); };\nexports.first = first;\n/**\n * Always return the last argument.\n *\n * @example\n * import * as S from 'fp-ts/Semigroup'\n *\n * assert.deepStrictEqual(S.last<number>().concat(1, 2), 2)\n *\n * @category instances\n * @since 2.10.0\n */\nvar last = function () { return ({ concat: function (_, y) { return y; } }); };\nexports.last = last;\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Given a sequence of `as`, concat them and return the total.\n *\n * If `as` is empty, return the provided `startWith` value.\n *\n * @example\n * import { concatAll } from 'fp-ts/Semigroup'\n * import * as N from 'fp-ts/number'\n *\n * const sum = concatAll(N.SemigroupSum)(0)\n *\n * assert.deepStrictEqual(sum([1, 2, 3]), 6)\n * assert.deepStrictEqual(sum([]), 0)\n *\n * @since 2.10.0\n */\nexports.concatAll = M.concatAll;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `void` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.semigroupVoid = (0, exports.constant)(undefined);\n/**\n * Use [`getAssignSemigroup`](./struct.ts.html#getAssignSemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nvar getObjectSemigroup = function () { return ({\n    concat: function (first, second) { return Object.assign({}, first, second); }\n}); };\nexports.getObjectSemigroup = getObjectSemigroup;\n/**\n * Use [`last`](#last) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getLastSemigroup = exports.last;\n/**\n * Use [`first`](#first) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getFirstSemigroup = exports.first;\n/**\n * Use [`tuple`](#tuple) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getTupleSemigroup = exports.tuple;\n/**\n * Use [`struct`](#struct) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getStructSemigroup = exports.struct;\n/**\n * Use [`reverse`](#reverse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getDualSemigroup = exports.reverse;\n/**\n * Use [`max`](#max) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getJoinSemigroup = exports.max;\n/**\n * Use [`min`](#min) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getMeetSemigroup = exports.min;\n/**\n * Use [`intercalate`](#intercalate) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexports.getIntercalateSemigroup = exports.intercalate;\nfunction fold(S) {\n    var concatAllS = (0, exports.concatAll)(S);\n    return function (startWith, as) { return (as === undefined ? concatAllS(startWith) : concatAllS(startWith)(as)); };\n}\n/**\n * Use [`SemigroupAll`](./boolean.ts.html#SemigroupAll) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.semigroupAll = {\n    concat: function (x, y) { return x && y; }\n};\n/**\n * Use [`SemigroupAny`](./boolean.ts.html#SemigroupAny) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.semigroupAny = {\n    concat: function (x, y) { return x || y; }\n};\n/**\n * Use [`getSemigroup`](./function.ts.html#getSemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getFunctionSemigroup = function_1.getSemigroup;\n/**\n * Use [`Semigroup`](./string.ts.html#Semigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.semigroupString = {\n    concat: function (x, y) { return x + y; }\n};\n/**\n * Use [`SemigroupSum`](./number.ts.html#SemigroupSum) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.semigroupSum = {\n    concat: function (x, y) { return x + y; }\n};\n/**\n * Use [`SemigroupProduct`](./number.ts.html#SemigroupProduct) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.semigroupProduct = {\n    concat: function (x, y) { return x * y; }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcC10cy9saWIvU2VtaWdyb3VwLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRyxvQkFBb0IsR0FBRyx1QkFBdUIsR0FBRyw0QkFBNEIsR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0IsR0FBRywrQkFBK0IsR0FBRyx3QkFBd0IsR0FBRyx3QkFBd0IsR0FBRyx3QkFBd0IsR0FBRywwQkFBMEIsR0FBRyx5QkFBeUIsR0FBRyx5QkFBeUIsR0FBRyx3QkFBd0IsR0FBRywwQkFBMEIsR0FBRyxxQkFBcUIsR0FBRyxpQkFBaUIsR0FBRyxZQUFZLEdBQUcsYUFBYSxHQUFHLG1CQUFtQixHQUFHLGFBQWEsR0FBRyxjQUFjLEdBQUcsZUFBZSxHQUFHLGdCQUFnQixHQUFHLFdBQVcsR0FBRyxXQUFXO0FBQ3psQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUNyQyxxQkFBcUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN6QyxxQkFBcUIsbUJBQU8sQ0FBQyxzRUFBUztBQUN0Qyxz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QUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsOEJBQThCO0FBQzlCIiwic291cmNlcyI6WyJJOlxcU2NhbGFDdXJzb3ZheWFcXEJ1bmtlcldlYlxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcZnAtdHNcXGxpYlxcU2VtaWdyb3VwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNlbWlncm91cFByb2R1Y3QgPSBleHBvcnRzLnNlbWlncm91cFN1bSA9IGV4cG9ydHMuc2VtaWdyb3VwU3RyaW5nID0gZXhwb3J0cy5nZXRGdW5jdGlvblNlbWlncm91cCA9IGV4cG9ydHMuc2VtaWdyb3VwQW55ID0gZXhwb3J0cy5zZW1pZ3JvdXBBbGwgPSBleHBvcnRzLmdldEludGVyY2FsYXRlU2VtaWdyb3VwID0gZXhwb3J0cy5nZXRNZWV0U2VtaWdyb3VwID0gZXhwb3J0cy5nZXRKb2luU2VtaWdyb3VwID0gZXhwb3J0cy5nZXREdWFsU2VtaWdyb3VwID0gZXhwb3J0cy5nZXRTdHJ1Y3RTZW1pZ3JvdXAgPSBleHBvcnRzLmdldFR1cGxlU2VtaWdyb3VwID0gZXhwb3J0cy5nZXRGaXJzdFNlbWlncm91cCA9IGV4cG9ydHMuZ2V0TGFzdFNlbWlncm91cCA9IGV4cG9ydHMuZ2V0T2JqZWN0U2VtaWdyb3VwID0gZXhwb3J0cy5zZW1pZ3JvdXBWb2lkID0gZXhwb3J0cy5jb25jYXRBbGwgPSBleHBvcnRzLmxhc3QgPSBleHBvcnRzLmZpcnN0ID0gZXhwb3J0cy5pbnRlcmNhbGF0ZSA9IGV4cG9ydHMudHVwbGUgPSBleHBvcnRzLnN0cnVjdCA9IGV4cG9ydHMucmV2ZXJzZSA9IGV4cG9ydHMuY29uc3RhbnQgPSBleHBvcnRzLm1heCA9IGV4cG9ydHMubWluID0gdm9pZCAwO1xuZXhwb3J0cy5mb2xkID0gZm9sZDtcbi8qKlxuICogSWYgYSB0eXBlIGBBYCBjYW4gZm9ybSBhIGBTZW1pZ3JvdXBgIGl0IGhhcyBhbiAqKmFzc29jaWF0aXZlKiogYmluYXJ5IG9wZXJhdGlvbi5cbiAqXG4gKiBgYGB0c1xuICogaW50ZXJmYWNlIFNlbWlncm91cDxBPiB7XG4gKiAgIHJlYWRvbmx5IGNvbmNhdDogKHg6IEEsIHk6IEEpID0+IEFcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEFzc29jaWF0aXZpdHkgbWVhbnMgdGhlIGZvbGxvd2luZyBlcXVhbGl0eSBtdXN0IGhvbGQgZm9yIGFueSBjaG9pY2Ugb2YgYHhgLCBgeWAsIGFuZCBgemAuXG4gKlxuICogYGBgdHNcbiAqIGNvbmNhdCh4LCBjb25jYXQoeSwgeikpID0gY29uY2F0KGNvbmNhdCh4LCB5KSwgeilcbiAqIGBgYFxuICpcbiAqIEEgY29tbW9uIGV4YW1wbGUgb2YgYSBzZW1pZ3JvdXAgaXMgdGhlIHR5cGUgYHN0cmluZ2Agd2l0aCB0aGUgb3BlcmF0aW9uIGArYC5cbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgU2VtaWdyb3VwIH0gZnJvbSAnZnAtdHMvU2VtaWdyb3VwJ1xuICpcbiAqIGNvbnN0IHNlbWlncm91cFN0cmluZzogU2VtaWdyb3VwPHN0cmluZz4gPSB7XG4gKiAgIGNvbmNhdDogKHgsIHkpID0+IHggKyB5XG4gKiB9XG4gKlxuICogY29uc3QgeCA9ICd4J1xuICogY29uc3QgeSA9ICd5J1xuICogY29uc3QgeiA9ICd6J1xuICpcbiAqIHNlbWlncm91cFN0cmluZy5jb25jYXQoeCwgeSkgLy8gJ3h5J1xuICpcbiAqIHNlbWlncm91cFN0cmluZy5jb25jYXQoeCwgc2VtaWdyb3VwU3RyaW5nLmNvbmNhdCh5LCB6KSkgLy8gJ3h5eidcbiAqXG4gKiBzZW1pZ3JvdXBTdHJpbmcuY29uY2F0KHNlbWlncm91cFN0cmluZy5jb25jYXQoeCwgeSksIHopIC8vICd4eXonXG4gKiBgYGBcbiAqXG4gKiAqQWRhcHRlZCBmcm9tIGh0dHBzOi8vdHlwZWxldmVsLm9yZy9jYXRzKlxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG52YXIgZnVuY3Rpb25fMSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9uXCIpO1xudmFyIF8gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vaW50ZXJuYWxcIikpO1xudmFyIE0gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vTWFnbWFcIikpO1xudmFyIE9yID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL09yZFwiKSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBjb25zdHJ1Y3RvcnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogR2V0IGEgc2VtaWdyb3VwIHdoZXJlIGBjb25jYXRgIHdpbGwgcmV0dXJuIHRoZSBtaW5pbXVtLCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgb3JkZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIE4gZnJvbSAnZnAtdHMvbnVtYmVyJ1xuICogaW1wb3J0ICogYXMgUyBmcm9tICdmcC10cy9TZW1pZ3JvdXAnXG4gKlxuICogY29uc3QgUzEgPSBTLm1pbihOLk9yZClcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFMxLmNvbmNhdCgxLCAyKSwgMSlcbiAqXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKiBAc2luY2UgMi4xMC4wXG4gKi9cbnZhciBtaW4gPSBmdW5jdGlvbiAoTykgeyByZXR1cm4gKHtcbiAgICBjb25jYXQ6IE9yLm1pbihPKVxufSk7IH07XG5leHBvcnRzLm1pbiA9IG1pbjtcbi8qKlxuICogR2V0IGEgc2VtaWdyb3VwIHdoZXJlIGBjb25jYXRgIHdpbGwgcmV0dXJuIHRoZSBtYXhpbXVtLCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgb3JkZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIE4gZnJvbSAnZnAtdHMvbnVtYmVyJ1xuICogaW1wb3J0ICogYXMgUyBmcm9tICdmcC10cy9TZW1pZ3JvdXAnXG4gKlxuICogY29uc3QgUzEgPSBTLm1heChOLk9yZClcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFMxLmNvbmNhdCgxLCAyKSwgMilcbiAqXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKiBAc2luY2UgMi4xMC4wXG4gKi9cbnZhciBtYXggPSBmdW5jdGlvbiAoTykgeyByZXR1cm4gKHtcbiAgICBjb25jYXQ6IE9yLm1heChPKVxufSk7IH07XG5leHBvcnRzLm1heCA9IG1heDtcbi8qKlxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICogQHNpbmNlIDIuMTAuMFxuICovXG52YXIgY29uc3RhbnQgPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gKHtcbiAgICBjb25jYXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGE7IH1cbn0pOyB9O1xuZXhwb3J0cy5jb25zdGFudCA9IGNvbnN0YW50O1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gY29tYmluYXRvcnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogVGhlIGR1YWwgb2YgYSBgU2VtaWdyb3VwYCwgb2J0YWluZWQgYnkgc3dhcHBpbmcgdGhlIGFyZ3VtZW50cyBvZiBgY29uY2F0YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgcmV2ZXJzZSB9IGZyb20gJ2ZwLXRzL1NlbWlncm91cCdcbiAqIGltcG9ydCAqIGFzIFMgZnJvbSAnZnAtdHMvc3RyaW5nJ1xuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocmV2ZXJzZShTLlNlbWlncm91cCkuY29uY2F0KCdhJywgJ2InKSwgJ2JhJylcbiAqXG4gKiBAc2luY2UgMi4xMC4wXG4gKi9cbmV4cG9ydHMucmV2ZXJzZSA9IE0ucmV2ZXJzZTtcbi8qKlxuICogR2l2ZW4gYSBzdHJ1Y3Qgb2Ygc2VtaWdyb3VwcyByZXR1cm5zIGEgc2VtaWdyb3VwIGZvciB0aGUgc3RydWN0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBzdHJ1Y3QgfSBmcm9tICdmcC10cy9TZW1pZ3JvdXAnXG4gKiBpbXBvcnQgKiBhcyBOIGZyb20gJ2ZwLXRzL251bWJlcidcbiAqXG4gKiBpbnRlcmZhY2UgUG9pbnQge1xuICogICByZWFkb25seSB4OiBudW1iZXJcbiAqICAgcmVhZG9ubHkgeTogbnVtYmVyXG4gKiB9XG4gKlxuICogY29uc3QgUyA9IHN0cnVjdDxQb2ludD4oe1xuICogICB4OiBOLlNlbWlncm91cFN1bSxcbiAqICAgeTogTi5TZW1pZ3JvdXBTdW1cbiAqIH0pXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChTLmNvbmNhdCh7IHg6IDEsIHk6IDIgfSwgeyB4OiAzLCB5OiA0IH0pLCB7IHg6IDQsIHk6IDYgfSlcbiAqXG4gKiBAc2luY2UgMi4xMC4wXG4gKi9cbnZhciBzdHJ1Y3QgPSBmdW5jdGlvbiAoc2VtaWdyb3VwcykgeyByZXR1cm4gKHtcbiAgICBjb25jYXQ6IGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgIHZhciByID0ge307XG4gICAgICAgIGZvciAodmFyIGsgaW4gc2VtaWdyb3Vwcykge1xuICAgICAgICAgICAgaWYgKF8uaGFzLmNhbGwoc2VtaWdyb3VwcywgaykpIHtcbiAgICAgICAgICAgICAgICByW2tdID0gc2VtaWdyb3Vwc1trXS5jb25jYXQoZmlyc3Rba10sIHNlY29uZFtrXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxufSk7IH07XG5leHBvcnRzLnN0cnVjdCA9IHN0cnVjdDtcbi8qKlxuICogR2l2ZW4gYSB0dXBsZSBvZiBzZW1pZ3JvdXBzIHJldHVybnMgYSBzZW1pZ3JvdXAgZm9yIHRoZSB0dXBsZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgdHVwbGUgfSBmcm9tICdmcC10cy9TZW1pZ3JvdXAnXG4gKiBpbXBvcnQgKiBhcyBCIGZyb20gJ2ZwLXRzL2Jvb2xlYW4nXG4gKiBpbXBvcnQgKiBhcyBOIGZyb20gJ2ZwLXRzL251bWJlcidcbiAqIGltcG9ydCAqIGFzIFMgZnJvbSAnZnAtdHMvc3RyaW5nJ1xuICpcbiAqIGNvbnN0IFMxID0gdHVwbGUoUy5TZW1pZ3JvdXAsIE4uU2VtaWdyb3VwU3VtKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChTMS5jb25jYXQoWydhJywgMV0sIFsnYicsIDJdKSwgWydhYicsIDNdKVxuICpcbiAqIGNvbnN0IFMyID0gdHVwbGUoUy5TZW1pZ3JvdXAsIE4uU2VtaWdyb3VwU3VtLCBCLlNlbWlncm91cEFsbClcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoUzIuY29uY2F0KFsnYScsIDEsIHRydWVdLCBbJ2InLCAyLCBmYWxzZV0pLCBbJ2FiJywgMywgZmFsc2VdKVxuICpcbiAqIEBzaW5jZSAyLjEwLjBcbiAqL1xudmFyIHR1cGxlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZW1pZ3JvdXBzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgc2VtaWdyb3Vwc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gKHtcbiAgICAgICAgY29uY2F0OiBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkgeyByZXR1cm4gc2VtaWdyb3Vwcy5tYXAoZnVuY3Rpb24gKHMsIGkpIHsgcmV0dXJuIHMuY29uY2F0KGZpcnN0W2ldLCBzZWNvbmRbaV0pOyB9KTsgfVxuICAgIH0pO1xufTtcbmV4cG9ydHMudHVwbGUgPSB0dXBsZTtcbi8qKlxuICogQmV0d2VlbiBlYWNoIHBhaXIgb2YgZWxlbWVudHMgaW5zZXJ0IGBtaWRkbGVgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBpbnRlcmNhbGF0ZSB9IGZyb20gJ2ZwLXRzL1NlbWlncm91cCdcbiAqIGltcG9ydCAqIGFzIFMgZnJvbSAnZnAtdHMvc3RyaW5nJ1xuICogaW1wb3J0IHsgcGlwZSB9IGZyb20gJ2ZwLXRzL2Z1bmN0aW9uJ1xuICpcbiAqIGNvbnN0IFMxID0gcGlwZShTLlNlbWlncm91cCwgaW50ZXJjYWxhdGUoJyArICcpKVxuICpcbiAqIGFzc2VydC5zdHJpY3RFcXVhbChTMS5jb25jYXQoJ2EnLCAnYicpLCAnYSArIGInKVxuICpcbiAqIEBzaW5jZSAyLjEwLjBcbiAqL1xudmFyIGludGVyY2FsYXRlID0gZnVuY3Rpb24gKG1pZGRsZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoUykgeyByZXR1cm4gKHtcbiAgICAgICAgY29uY2F0OiBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4gUy5jb25jYXQoeCwgUy5jb25jYXQobWlkZGxlLCB5KSk7IH1cbiAgICB9KTsgfTtcbn07XG5leHBvcnRzLmludGVyY2FsYXRlID0gaW50ZXJjYWxhdGU7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBpbnN0YW5jZXNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogQWx3YXlzIHJldHVybiB0aGUgZmlyc3QgYXJndW1lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIFMgZnJvbSAnZnAtdHMvU2VtaWdyb3VwJ1xuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoUy5maXJzdDxudW1iZXI+KCkuY29uY2F0KDEsIDIpLCAxKVxuICpcbiAqIEBjYXRlZ29yeSBpbnN0YW5jZXNcbiAqIEBzaW5jZSAyLjEwLjBcbiAqL1xudmFyIGZpcnN0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHsgY29uY2F0OiBmdW5jdGlvbl8xLmlkZW50aXR5IH0pOyB9O1xuZXhwb3J0cy5maXJzdCA9IGZpcnN0O1xuLyoqXG4gKiBBbHdheXMgcmV0dXJuIHRoZSBsYXN0IGFyZ3VtZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBTIGZyb20gJ2ZwLXRzL1NlbWlncm91cCdcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFMubGFzdDxudW1iZXI+KCkuY29uY2F0KDEsIDIpLCAyKVxuICpcbiAqIEBjYXRlZ29yeSBpbnN0YW5jZXNcbiAqIEBzaW5jZSAyLjEwLjBcbiAqL1xudmFyIGxhc3QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoeyBjb25jYXQ6IGZ1bmN0aW9uIChfLCB5KSB7IHJldHVybiB5OyB9IH0pOyB9O1xuZXhwb3J0cy5sYXN0ID0gbGFzdDtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHV0aWxzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqIEdpdmVuIGEgc2VxdWVuY2Ugb2YgYGFzYCwgY29uY2F0IHRoZW0gYW5kIHJldHVybiB0aGUgdG90YWwuXG4gKlxuICogSWYgYGFzYCBpcyBlbXB0eSwgcmV0dXJuIHRoZSBwcm92aWRlZCBgc3RhcnRXaXRoYCB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgY29uY2F0QWxsIH0gZnJvbSAnZnAtdHMvU2VtaWdyb3VwJ1xuICogaW1wb3J0ICogYXMgTiBmcm9tICdmcC10cy9udW1iZXInXG4gKlxuICogY29uc3Qgc3VtID0gY29uY2F0QWxsKE4uU2VtaWdyb3VwU3VtKSgwKVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoc3VtKFsxLCAyLCAzXSksIDYpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHN1bShbXSksIDApXG4gKlxuICogQHNpbmNlIDIuMTAuMFxuICovXG5leHBvcnRzLmNvbmNhdEFsbCA9IE0uY29uY2F0QWxsO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZGVwcmVjYXRlZFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBVc2UgYHZvaWRgIG1vZHVsZSBpbnN0ZWFkLlxuICpcbiAqIEBjYXRlZ29yeSB6b25lIG9mIGRlYXRoXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydHMuc2VtaWdyb3VwVm9pZCA9ICgwLCBleHBvcnRzLmNvbnN0YW50KSh1bmRlZmluZWQpO1xuLyoqXG4gKiBVc2UgW2BnZXRBc3NpZ25TZW1pZ3JvdXBgXSguL3N0cnVjdC50cy5odG1sI2dldEFzc2lnblNlbWlncm91cCkgaW5zdGVhZC5cbiAqXG4gKiBAY2F0ZWdvcnkgem9uZSBvZiBkZWF0aFxuICogQHNpbmNlIDIuMC4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG52YXIgZ2V0T2JqZWN0U2VtaWdyb3VwID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICBjb25jYXQ6IGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKSB7IHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBmaXJzdCwgc2Vjb25kKTsgfVxufSk7IH07XG5leHBvcnRzLmdldE9iamVjdFNlbWlncm91cCA9IGdldE9iamVjdFNlbWlncm91cDtcbi8qKlxuICogVXNlIFtgbGFzdGBdKCNsYXN0KSBpbnN0ZWFkLlxuICpcbiAqIEBjYXRlZ29yeSB6b25lIG9mIGRlYXRoXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydHMuZ2V0TGFzdFNlbWlncm91cCA9IGV4cG9ydHMubGFzdDtcbi8qKlxuICogVXNlIFtgZmlyc3RgXSgjZmlyc3QpIGluc3RlYWQuXG4gKlxuICogQGNhdGVnb3J5IHpvbmUgb2YgZGVhdGhcbiAqIEBzaW5jZSAyLjAuMFxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0cy5nZXRGaXJzdFNlbWlncm91cCA9IGV4cG9ydHMuZmlyc3Q7XG4vKipcbiAqIFVzZSBbYHR1cGxlYF0oI3R1cGxlKSBpbnN0ZWFkLlxuICpcbiAqIEBjYXRlZ29yeSB6b25lIG9mIGRlYXRoXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydHMuZ2V0VHVwbGVTZW1pZ3JvdXAgPSBleHBvcnRzLnR1cGxlO1xuLyoqXG4gKiBVc2UgW2BzdHJ1Y3RgXSgjc3RydWN0KSBpbnN0ZWFkLlxuICpcbiAqIEBjYXRlZ29yeSB6b25lIG9mIGRlYXRoXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydHMuZ2V0U3RydWN0U2VtaWdyb3VwID0gZXhwb3J0cy5zdHJ1Y3Q7XG4vKipcbiAqIFVzZSBbYHJldmVyc2VgXSgjcmV2ZXJzZSkgaW5zdGVhZC5cbiAqXG4gKiBAY2F0ZWdvcnkgem9uZSBvZiBkZWF0aFxuICogQHNpbmNlIDIuMC4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnRzLmdldER1YWxTZW1pZ3JvdXAgPSBleHBvcnRzLnJldmVyc2U7XG4vKipcbiAqIFVzZSBbYG1heGBdKCNtYXgpIGluc3RlYWQuXG4gKlxuICogQGNhdGVnb3J5IHpvbmUgb2YgZGVhdGhcbiAqIEBzaW5jZSAyLjAuMFxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0cy5nZXRKb2luU2VtaWdyb3VwID0gZXhwb3J0cy5tYXg7XG4vKipcbiAqIFVzZSBbYG1pbmBdKCNtaW4pIGluc3RlYWQuXG4gKlxuICogQGNhdGVnb3J5IHpvbmUgb2YgZGVhdGhcbiAqIEBzaW5jZSAyLjAuMFxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0cy5nZXRNZWV0U2VtaWdyb3VwID0gZXhwb3J0cy5taW47XG4vKipcbiAqIFVzZSBbYGludGVyY2FsYXRlYF0oI2ludGVyY2FsYXRlKSBpbnN0ZWFkLlxuICpcbiAqIEBjYXRlZ29yeSB6b25lIG9mIGRlYXRoXG4gKiBAc2luY2UgMi41LjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydHMuZ2V0SW50ZXJjYWxhdGVTZW1pZ3JvdXAgPSBleHBvcnRzLmludGVyY2FsYXRlO1xuZnVuY3Rpb24gZm9sZChTKSB7XG4gICAgdmFyIGNvbmNhdEFsbFMgPSAoMCwgZXhwb3J0cy5jb25jYXRBbGwpKFMpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhcnRXaXRoLCBhcykgeyByZXR1cm4gKGFzID09PSB1bmRlZmluZWQgPyBjb25jYXRBbGxTKHN0YXJ0V2l0aCkgOiBjb25jYXRBbGxTKHN0YXJ0V2l0aCkoYXMpKTsgfTtcbn1cbi8qKlxuICogVXNlIFtgU2VtaWdyb3VwQWxsYF0oLi9ib29sZWFuLnRzLmh0bWwjU2VtaWdyb3VwQWxsKSBpbnN0ZWFkLlxuICpcbiAqIEBjYXRlZ29yeSB6b25lIG9mIGRlYXRoXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydHMuc2VtaWdyb3VwQWxsID0ge1xuICAgIGNvbmNhdDogZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIHggJiYgeTsgfVxufTtcbi8qKlxuICogVXNlIFtgU2VtaWdyb3VwQW55YF0oLi9ib29sZWFuLnRzLmh0bWwjU2VtaWdyb3VwQW55KSBpbnN0ZWFkLlxuICpcbiAqIEBjYXRlZ29yeSB6b25lIG9mIGRlYXRoXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydHMuc2VtaWdyb3VwQW55ID0ge1xuICAgIGNvbmNhdDogZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIHggfHwgeTsgfVxufTtcbi8qKlxuICogVXNlIFtgZ2V0U2VtaWdyb3VwYF0oLi9mdW5jdGlvbi50cy5odG1sI2dldFNlbWlncm91cCkgaW5zdGVhZC5cbiAqXG4gKiBAY2F0ZWdvcnkgem9uZSBvZiBkZWF0aFxuICogQHNpbmNlIDIuMC4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnRzLmdldEZ1bmN0aW9uU2VtaWdyb3VwID0gZnVuY3Rpb25fMS5nZXRTZW1pZ3JvdXA7XG4vKipcbiAqIFVzZSBbYFNlbWlncm91cGBdKC4vc3RyaW5nLnRzLmh0bWwjU2VtaWdyb3VwKSBpbnN0ZWFkLlxuICpcbiAqIEBjYXRlZ29yeSB6b25lIG9mIGRlYXRoXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydHMuc2VtaWdyb3VwU3RyaW5nID0ge1xuICAgIGNvbmNhdDogZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIHggKyB5OyB9XG59O1xuLyoqXG4gKiBVc2UgW2BTZW1pZ3JvdXBTdW1gXSguL251bWJlci50cy5odG1sI1NlbWlncm91cFN1bSkgaW5zdGVhZC5cbiAqXG4gKiBAY2F0ZWdvcnkgem9uZSBvZiBkZWF0aFxuICogQHNpbmNlIDIuMC4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnRzLnNlbWlncm91cFN1bSA9IHtcbiAgICBjb25jYXQ6IGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiB4ICsgeTsgfVxufTtcbi8qKlxuICogVXNlIFtgU2VtaWdyb3VwUHJvZHVjdGBdKC4vbnVtYmVyLnRzLmh0bWwjU2VtaWdyb3VwUHJvZHVjdCkgaW5zdGVhZC5cbiAqXG4gKiBAY2F0ZWdvcnkgem9uZSBvZiBkZWF0aFxuICogQHNpbmNlIDIuMC4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnRzLnNlbWlncm91cFByb2R1Y3QgPSB7XG4gICAgY29uY2F0OiBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geCAqIHk7IH1cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fp-ts/lib/Semigroup.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fp-ts/lib/Separated.js":
/*!*********************************************!*\
  !*** ./node_modules/fp-ts/lib/Separated.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\n/**\n * ```ts\n * interface Separated<E, A> {\n *    readonly left: E\n *    readonly right: A\n * }\n * ```\n *\n * Represents a result of separating a whole into two parts.\n *\n * @since 2.10.0\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.right = exports.left = exports.flap = exports.Functor = exports.Bifunctor = exports.URI = exports.bimap = exports.mapLeft = exports.map = exports.separated = void 0;\nvar function_1 = __webpack_require__(/*! ./function */ \"(app-pages-browser)/./node_modules/fp-ts/lib/function.js\");\nvar Functor_1 = __webpack_require__(/*! ./Functor */ \"(app-pages-browser)/./node_modules/fp-ts/lib/Functor.js\");\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.10.0\n */\nvar separated = function (left, right) { return ({ left: left, right: right }); };\nexports.separated = separated;\nvar _map = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.map)(f)); };\nvar _mapLeft = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.mapLeft)(f)); };\nvar _bimap = function (fa, g, f) { return (0, function_1.pipe)(fa, (0, exports.bimap)(g, f)); };\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.10.0\n */\nvar map = function (f) {\n    return function (fa) {\n        return (0, exports.separated)((0, exports.left)(fa), f((0, exports.right)(fa)));\n    };\n};\nexports.map = map;\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.10.0\n */\nvar mapLeft = function (f) {\n    return function (fa) {\n        return (0, exports.separated)(f((0, exports.left)(fa)), (0, exports.right)(fa));\n    };\n};\nexports.mapLeft = mapLeft;\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.10.0\n */\nvar bimap = function (f, g) {\n    return function (fa) {\n        return (0, exports.separated)(f((0, exports.left)(fa)), g((0, exports.right)(fa)));\n    };\n};\nexports.bimap = bimap;\n/**\n * @category type lambdas\n * @since 2.10.0\n */\nexports.URI = 'Separated';\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.Bifunctor = {\n    URI: exports.URI,\n    mapLeft: _mapLeft,\n    bimap: _bimap\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.Functor = {\n    URI: exports.URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexports.flap = (0, Functor_1.flap)(exports.Functor);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.10.0\n */\nvar left = function (s) { return s.left; };\nexports.left = left;\n/**\n * @since 2.10.0\n */\nvar right = function (s) { return s.right; };\nexports.right = right;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcC10cy9saWIvU2VwYXJhdGVkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsR0FBRyxZQUFZLEdBQUcsWUFBWSxHQUFHLGVBQWUsR0FBRyxpQkFBaUIsR0FBRyxXQUFXLEdBQUcsYUFBYSxHQUFHLGVBQWUsR0FBRyxXQUFXLEdBQUcsaUJBQWlCO0FBQ25LLGlCQUFpQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLDBFQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFVBQVUsMEJBQTBCO0FBQzdFLGlCQUFpQjtBQUNqQiw4QkFBOEI7QUFDOUIsa0NBQWtDO0FBQ2xDLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsYUFBYSIsInNvdXJjZXMiOlsiSTpcXFNjYWxhQ3Vyc292YXlhXFxCdW5rZXJXZWJcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXGZwLXRzXFxsaWJcXFNlcGFyYXRlZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogYGBgdHNcbiAqIGludGVyZmFjZSBTZXBhcmF0ZWQ8RSwgQT4ge1xuICogICAgcmVhZG9ubHkgbGVmdDogRVxuICogICAgcmVhZG9ubHkgcmlnaHQ6IEFcbiAqIH1cbiAqIGBgYFxuICpcbiAqIFJlcHJlc2VudHMgYSByZXN1bHQgb2Ygc2VwYXJhdGluZyBhIHdob2xlIGludG8gdHdvIHBhcnRzLlxuICpcbiAqIEBzaW5jZSAyLjEwLjBcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yaWdodCA9IGV4cG9ydHMubGVmdCA9IGV4cG9ydHMuZmxhcCA9IGV4cG9ydHMuRnVuY3RvciA9IGV4cG9ydHMuQmlmdW5jdG9yID0gZXhwb3J0cy5VUkkgPSBleHBvcnRzLmJpbWFwID0gZXhwb3J0cy5tYXBMZWZ0ID0gZXhwb3J0cy5tYXAgPSBleHBvcnRzLnNlcGFyYXRlZCA9IHZvaWQgMDtcbnZhciBmdW5jdGlvbl8xID0gcmVxdWlyZShcIi4vZnVuY3Rpb25cIik7XG52YXIgRnVuY3Rvcl8xID0gcmVxdWlyZShcIi4vRnVuY3RvclwiKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGNvbnN0cnVjdG9yc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKiBAc2luY2UgMi4xMC4wXG4gKi9cbnZhciBzZXBhcmF0ZWQgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHsgcmV0dXJuICh7IGxlZnQ6IGxlZnQsIHJpZ2h0OiByaWdodCB9KTsgfTtcbmV4cG9ydHMuc2VwYXJhdGVkID0gc2VwYXJhdGVkO1xudmFyIF9tYXAgPSBmdW5jdGlvbiAoZmEsIGYpIHsgcmV0dXJuICgwLCBmdW5jdGlvbl8xLnBpcGUpKGZhLCAoMCwgZXhwb3J0cy5tYXApKGYpKTsgfTtcbnZhciBfbWFwTGVmdCA9IGZ1bmN0aW9uIChmYSwgZikgeyByZXR1cm4gKDAsIGZ1bmN0aW9uXzEucGlwZSkoZmEsICgwLCBleHBvcnRzLm1hcExlZnQpKGYpKTsgfTtcbnZhciBfYmltYXAgPSBmdW5jdGlvbiAoZmEsIGcsIGYpIHsgcmV0dXJuICgwLCBmdW5jdGlvbl8xLnBpcGUpKGZhLCAoMCwgZXhwb3J0cy5iaW1hcCkoZywgZikpOyB9O1xuLyoqXG4gKiBgbWFwYCBjYW4gYmUgdXNlZCB0byB0dXJuIGZ1bmN0aW9ucyBgKGE6IEEpID0+IEJgIGludG8gZnVuY3Rpb25zIGAoZmE6IEY8QT4pID0+IEY8Qj5gIHdob3NlIGFyZ3VtZW50IGFuZCByZXR1cm4gdHlwZXNcbiAqIHVzZSB0aGUgdHlwZSBjb25zdHJ1Y3RvciBgRmAgdG8gcmVwcmVzZW50IHNvbWUgY29tcHV0YXRpb25hbCBjb250ZXh0LlxuICpcbiAqIEBjYXRlZ29yeSBtYXBwaW5nXG4gKiBAc2luY2UgMi4xMC4wXG4gKi9cbnZhciBtYXAgPSBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZmEpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLnNlcGFyYXRlZCkoKDAsIGV4cG9ydHMubGVmdCkoZmEpLCBmKCgwLCBleHBvcnRzLnJpZ2h0KShmYSkpKTtcbiAgICB9O1xufTtcbmV4cG9ydHMubWFwID0gbWFwO1xuLyoqXG4gKiBNYXAgYSBmdW5jdGlvbiBvdmVyIHRoZSBmaXJzdCB0eXBlIGFyZ3VtZW50IG9mIGEgYmlmdW5jdG9yLlxuICpcbiAqIEBjYXRlZ29yeSBlcnJvciBoYW5kbGluZ1xuICogQHNpbmNlIDIuMTAuMFxuICovXG52YXIgbWFwTGVmdCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChmYSkge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuc2VwYXJhdGVkKShmKCgwLCBleHBvcnRzLmxlZnQpKGZhKSksICgwLCBleHBvcnRzLnJpZ2h0KShmYSkpO1xuICAgIH07XG59O1xuZXhwb3J0cy5tYXBMZWZ0ID0gbWFwTGVmdDtcbi8qKlxuICogTWFwIGEgcGFpciBvZiBmdW5jdGlvbnMgb3ZlciB0aGUgdHdvIHR5cGUgYXJndW1lbnRzIG9mIHRoZSBiaWZ1bmN0b3IuXG4gKlxuICogQGNhdGVnb3J5IG1hcHBpbmdcbiAqIEBzaW5jZSAyLjEwLjBcbiAqL1xudmFyIGJpbWFwID0gZnVuY3Rpb24gKGYsIGcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGZhKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5zZXBhcmF0ZWQpKGYoKDAsIGV4cG9ydHMubGVmdCkoZmEpKSwgZygoMCwgZXhwb3J0cy5yaWdodCkoZmEpKSk7XG4gICAgfTtcbn07XG5leHBvcnRzLmJpbWFwID0gYmltYXA7XG4vKipcbiAqIEBjYXRlZ29yeSB0eXBlIGxhbWJkYXNcbiAqIEBzaW5jZSAyLjEwLjBcbiAqL1xuZXhwb3J0cy5VUkkgPSAnU2VwYXJhdGVkJztcbi8qKlxuICogQGNhdGVnb3J5IGluc3RhbmNlc1xuICogQHNpbmNlIDIuMTAuMFxuICovXG5leHBvcnRzLkJpZnVuY3RvciA9IHtcbiAgICBVUkk6IGV4cG9ydHMuVVJJLFxuICAgIG1hcExlZnQ6IF9tYXBMZWZ0LFxuICAgIGJpbWFwOiBfYmltYXBcbn07XG4vKipcbiAqIEBjYXRlZ29yeSBpbnN0YW5jZXNcbiAqIEBzaW5jZSAyLjEwLjBcbiAqL1xuZXhwb3J0cy5GdW5jdG9yID0ge1xuICAgIFVSSTogZXhwb3J0cy5VUkksXG4gICAgbWFwOiBfbWFwXG59O1xuLyoqXG4gKiBAY2F0ZWdvcnkgbWFwcGluZ1xuICogQHNpbmNlIDIuMTAuMFxuICovXG5leHBvcnRzLmZsYXAgPSAoMCwgRnVuY3Rvcl8xLmZsYXApKGV4cG9ydHMuRnVuY3Rvcik7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB1dGlsc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBAc2luY2UgMi4xMC4wXG4gKi9cbnZhciBsZWZ0ID0gZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMubGVmdDsgfTtcbmV4cG9ydHMubGVmdCA9IGxlZnQ7XG4vKipcbiAqIEBzaW5jZSAyLjEwLjBcbiAqL1xudmFyIHJpZ2h0ID0gZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMucmlnaHQ7IH07XG5leHBvcnRzLnJpZ2h0ID0gcmlnaHQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fp-ts/lib/Separated.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fp-ts/lib/Witherable.js":
/*!**********************************************!*\
  !*** ./node_modules/fp-ts/lib/Witherable.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.wiltDefault = wiltDefault;\nexports.witherDefault = witherDefault;\nexports.filterE = filterE;\nvar _ = __importStar(__webpack_require__(/*! ./internal */ \"(app-pages-browser)/./node_modules/fp-ts/lib/internal.js\"));\nfunction wiltDefault(T, C) {\n    return function (F) {\n        var traverseF = T.traverse(F);\n        return function (wa, f) { return F.map(traverseF(wa, f), C.separate); };\n    };\n}\nfunction witherDefault(T, C) {\n    return function (F) {\n        var traverseF = T.traverse(F);\n        return function (wa, f) { return F.map(traverseF(wa, f), C.compact); };\n    };\n}\nfunction filterE(W) {\n    return function (F) {\n        var witherF = W.wither(F);\n        return function (predicate) { return function (ga) { return witherF(ga, function (a) { return F.map(predicate(a), function (b) { return (b ? _.some(a) : _.none); }); }); }; };\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcC10cy9saWIvV2l0aGVyYWJsZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CLHFCQUFxQjtBQUNyQixlQUFlO0FBQ2YscUJBQXFCLG1CQUFPLENBQUMsNEVBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx1QkFBdUIsa0NBQWtDLDBDQUEwQyxrQ0FBa0MsSUFBSTtBQUMvSztBQUNBIiwic291cmNlcyI6WyJJOlxcU2NhbGFDdXJzb3ZheWFcXEJ1bmtlcldlYlxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcZnAtdHNcXGxpYlxcV2l0aGVyYWJsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy53aWx0RGVmYXVsdCA9IHdpbHREZWZhdWx0O1xuZXhwb3J0cy53aXRoZXJEZWZhdWx0ID0gd2l0aGVyRGVmYXVsdDtcbmV4cG9ydHMuZmlsdGVyRSA9IGZpbHRlckU7XG52YXIgXyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9pbnRlcm5hbFwiKSk7XG5mdW5jdGlvbiB3aWx0RGVmYXVsdChULCBDKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChGKSB7XG4gICAgICAgIHZhciB0cmF2ZXJzZUYgPSBULnRyYXZlcnNlKEYpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHdhLCBmKSB7IHJldHVybiBGLm1hcCh0cmF2ZXJzZUYod2EsIGYpLCBDLnNlcGFyYXRlKTsgfTtcbiAgICB9O1xufVxuZnVuY3Rpb24gd2l0aGVyRGVmYXVsdChULCBDKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChGKSB7XG4gICAgICAgIHZhciB0cmF2ZXJzZUYgPSBULnRyYXZlcnNlKEYpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHdhLCBmKSB7IHJldHVybiBGLm1hcCh0cmF2ZXJzZUYod2EsIGYpLCBDLmNvbXBhY3QpOyB9O1xuICAgIH07XG59XG5mdW5jdGlvbiBmaWx0ZXJFKFcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKEYpIHtcbiAgICAgICAgdmFyIHdpdGhlckYgPSBXLndpdGhlcihGKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwcmVkaWNhdGUpIHsgcmV0dXJuIGZ1bmN0aW9uIChnYSkgeyByZXR1cm4gd2l0aGVyRihnYSwgZnVuY3Rpb24gKGEpIHsgcmV0dXJuIEYubWFwKHByZWRpY2F0ZShhKSwgZnVuY3Rpb24gKGIpIHsgcmV0dXJuIChiID8gXy5zb21lKGEpIDogXy5ub25lKTsgfSk7IH0pOyB9OyB9O1xuICAgIH07XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fp-ts/lib/Witherable.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fp-ts/lib/Zero.js":
/*!****************************************!*\
  !*** ./node_modules/fp-ts/lib/Zero.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.guard = guard;\nfunction guard(F, P) {\n    return function (b) { return (b ? P.of(undefined) : F.zero()); };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcC10cy9saWIvWmVyby5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhO0FBQ2I7QUFDQSwwQkFBMEI7QUFDMUIiLCJzb3VyY2VzIjpbIkk6XFxTY2FsYUN1cnNvdmF5YVxcQnVua2VyV2ViXFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxmcC10c1xcbGliXFxaZXJvLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ndWFyZCA9IGd1YXJkO1xuZnVuY3Rpb24gZ3VhcmQoRiwgUCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYikgeyByZXR1cm4gKGIgPyBQLm9mKHVuZGVmaW5lZCkgOiBGLnplcm8oKSk7IH07XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fp-ts/lib/Zero.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fp-ts/lib/function.js":
/*!********************************************!*\
  !*** ./node_modules/fp-ts/lib/function.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.dual = exports.getEndomorphismMonoid = exports.SK = exports.hole = exports.constVoid = exports.constUndefined = exports.constNull = exports.constFalse = exports.constTrue = exports.unsafeCoerce = exports.apply = exports.getRing = exports.getSemiring = exports.getMonoid = exports.getSemigroup = exports.getBooleanAlgebra = void 0;\nexports.identity = identity;\nexports.constant = constant;\nexports.flip = flip;\nexports.flow = flow;\nexports.tuple = tuple;\nexports.increment = increment;\nexports.decrement = decrement;\nexports.absurd = absurd;\nexports.tupled = tupled;\nexports.untupled = untupled;\nexports.pipe = pipe;\nexports.not = not;\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.10.0\n */\nvar getBooleanAlgebra = function (B) {\n    return function () { return ({\n        meet: function (x, y) { return function (a) { return B.meet(x(a), y(a)); }; },\n        join: function (x, y) { return function (a) { return B.join(x(a), y(a)); }; },\n        zero: function () { return B.zero; },\n        one: function () { return B.one; },\n        implies: function (x, y) { return function (a) { return B.implies(x(a), y(a)); }; },\n        not: function (x) { return function (a) { return B.not(x(a)); }; }\n    }); };\n};\nexports.getBooleanAlgebra = getBooleanAlgebra;\n/**\n * Unary functions form a semigroup as long as you can provide a semigroup for the codomain.\n *\n * @example\n * import { Predicate, getSemigroup } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const S1 = getSemigroup(B.SemigroupAll)<number>()\n *\n * assert.deepStrictEqual(S1.concat(f, g)(1), true)\n * assert.deepStrictEqual(S1.concat(f, g)(3), false)\n *\n * const S2 = getSemigroup(B.SemigroupAny)<number>()\n *\n * assert.deepStrictEqual(S2.concat(f, g)(1), true)\n * assert.deepStrictEqual(S2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nvar getSemigroup = function (S) {\n    return function () { return ({\n        concat: function (f, g) { return function (a) { return S.concat(f(a), g(a)); }; }\n    }); };\n};\nexports.getSemigroup = getSemigroup;\n/**\n * Unary functions form a monoid as long as you can provide a monoid for the codomain.\n *\n * @example\n * import { Predicate } from 'fp-ts/Predicate'\n * import { getMonoid } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const M1 = getMonoid(B.MonoidAll)<number>()\n *\n * assert.deepStrictEqual(M1.concat(f, g)(1), true)\n * assert.deepStrictEqual(M1.concat(f, g)(3), false)\n *\n * const M2 = getMonoid(B.MonoidAny)<number>()\n *\n * assert.deepStrictEqual(M2.concat(f, g)(1), true)\n * assert.deepStrictEqual(M2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nvar getMonoid = function (M) {\n    var getSemigroupM = (0, exports.getSemigroup)(M);\n    return function () { return ({\n        concat: getSemigroupM().concat,\n        empty: function () { return M.empty; }\n    }); };\n};\nexports.getMonoid = getMonoid;\n/**\n * @category instances\n * @since 2.10.0\n */\nvar getSemiring = function (S) { return ({\n    add: function (f, g) { return function (x) { return S.add(f(x), g(x)); }; },\n    zero: function () { return S.zero; },\n    mul: function (f, g) { return function (x) { return S.mul(f(x), g(x)); }; },\n    one: function () { return S.one; }\n}); };\nexports.getSemiring = getSemiring;\n/**\n * @category instances\n * @since 2.10.0\n */\nvar getRing = function (R) {\n    var S = (0, exports.getSemiring)(R);\n    return {\n        add: S.add,\n        mul: S.mul,\n        one: S.one,\n        zero: S.zero,\n        sub: function (f, g) { return function (x) { return R.sub(f(x), g(x)); }; }\n    };\n};\nexports.getRing = getRing;\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nvar apply = function (a) {\n    return function (f) {\n        return f(a);\n    };\n};\nexports.apply = apply;\n/**\n * @since 2.0.0\n */\nfunction identity(a) {\n    return a;\n}\n/**\n * @since 2.0.0\n */\nexports.unsafeCoerce = identity;\n/**\n * @since 2.0.0\n */\nfunction constant(a) {\n    return function () { return a; };\n}\n/**\n * A thunk that returns always `true`.\n *\n * @since 2.0.0\n */\nexports.constTrue = constant(true);\n/**\n * A thunk that returns always `false`.\n *\n * @since 2.0.0\n */\nexports.constFalse = constant(false);\n/**\n * A thunk that returns always `null`.\n *\n * @since 2.0.0\n */\nexports.constNull = constant(null);\n/**\n * A thunk that returns always `undefined`.\n *\n * @since 2.0.0\n */\nexports.constUndefined = constant(undefined);\n/**\n * A thunk that returns always `void`.\n *\n * @since 2.0.0\n */\nexports.constVoid = exports.constUndefined;\nfunction flip(f) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (args.length > 1) {\n            return f(args[1], args[0]);\n        }\n        return function (a) { return f(a)(args[0]); };\n    };\n}\nfunction flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n    switch (arguments.length) {\n        case 1:\n            return ab;\n        case 2:\n            return function () {\n                return bc(ab.apply(this, arguments));\n            };\n        case 3:\n            return function () {\n                return cd(bc(ab.apply(this, arguments)));\n            };\n        case 4:\n            return function () {\n                return de(cd(bc(ab.apply(this, arguments))));\n            };\n        case 5:\n            return function () {\n                return ef(de(cd(bc(ab.apply(this, arguments)))));\n            };\n        case 6:\n            return function () {\n                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n            };\n        case 7:\n            return function () {\n                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n            };\n        case 8:\n            return function () {\n                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n            };\n        case 9:\n            return function () {\n                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n            };\n    }\n    return;\n}\n/**\n * @since 2.0.0\n */\nfunction tuple() {\n    var t = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        t[_i] = arguments[_i];\n    }\n    return t;\n}\n/**\n * @since 2.0.0\n */\nfunction increment(n) {\n    return n + 1;\n}\n/**\n * @since 2.0.0\n */\nfunction decrement(n) {\n    return n - 1;\n}\n/**\n * @since 2.0.0\n */\nfunction absurd(_) {\n    throw new Error('Called `absurd` function which should be uncallable');\n}\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from 'fp-ts/function'\n *\n * const add = tupled((x: number, y: number): number => x + y)\n *\n * assert.strictEqual(add([1, 2]), 3)\n *\n * @since 2.4.0\n */\nfunction tupled(f) {\n    return function (a) { return f.apply(void 0, a); };\n}\n/**\n * Inverse function of `tupled`\n *\n * @since 2.4.0\n */\nfunction untupled(f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return f(a);\n    };\n}\nfunction pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {\n    switch (arguments.length) {\n        case 1:\n            return a;\n        case 2:\n            return ab(a);\n        case 3:\n            return bc(ab(a));\n        case 4:\n            return cd(bc(ab(a)));\n        case 5:\n            return de(cd(bc(ab(a))));\n        case 6:\n            return ef(de(cd(bc(ab(a)))));\n        case 7:\n            return fg(ef(de(cd(bc(ab(a))))));\n        case 8:\n            return gh(fg(ef(de(cd(bc(ab(a)))))));\n        case 9:\n            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n        default: {\n            var ret = arguments[0];\n            for (var i = 1; i < arguments.length; i++) {\n                ret = arguments[i](ret);\n            }\n            return ret;\n        }\n    }\n}\n/**\n * Type hole simulation\n *\n * @since 2.7.0\n */\nexports.hole = absurd;\n/**\n * @since 2.11.0\n */\nvar SK = function (_, b) { return b; };\nexports.SK = SK;\n/**\n * Use `Predicate` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nfunction not(predicate) {\n    return function (a) { return !predicate(a); };\n}\n/**\n * Use `Endomorphism` module instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nvar getEndomorphismMonoid = function () { return ({\n    concat: function (first, second) { return flow(first, second); },\n    empty: identity\n}); };\nexports.getEndomorphismMonoid = getEndomorphismMonoid;\n/** @internal */\nvar dual = function (arity, body) {\n    var isDataFirst = typeof arity === 'number' ? function (args) { return args.length >= arity; } : arity;\n    return function () {\n        var args = Array.from(arguments);\n        if (isDataFirst(arguments)) {\n            return body.apply(this, args);\n        }\n        return function (self) { return body.apply(void 0, __spreadArray([self], args, false)); };\n    };\n};\nexports.dual = dual;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcC10cy9saWIvZnVuY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZFQUE2RSxPQUFPO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFlBQVksR0FBRyw2QkFBNkIsR0FBRyxVQUFVLEdBQUcsWUFBWSxHQUFHLGlCQUFpQixHQUFHLHNCQUFzQixHQUFHLGlCQUFpQixHQUFHLGtCQUFrQixHQUFHLGlCQUFpQixHQUFHLG9CQUFvQixHQUFHLGFBQWEsR0FBRyxlQUFlLEdBQUcsbUJBQW1CLEdBQUcsaUJBQWlCLEdBQUcsb0JBQW9CLEdBQUcseUJBQXlCO0FBQ3hVLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsWUFBWTtBQUNaLFlBQVk7QUFDWixhQUFhO0FBQ2IsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2QsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixZQUFZO0FBQ1osV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsZ0NBQWdDLHNCQUFzQiwrQkFBK0I7QUFDckYsZ0NBQWdDLHNCQUFzQiwrQkFBK0I7QUFDckYsNEJBQTRCLGdCQUFnQjtBQUM1QywyQkFBMkIsZUFBZTtBQUMxQyxtQ0FBbUMsc0JBQXNCLGtDQUFrQztBQUMzRiw0QkFBNEIsc0JBQXNCO0FBQ2xELEtBQUs7QUFDTDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLGtDQUFrQyxzQkFBc0I7QUFDeEQsS0FBSztBQUNMO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsNkJBQTZCO0FBQzdCLEtBQUs7QUFDTDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQywyQkFBMkIsc0JBQXNCLDhCQUE4QjtBQUMvRSx3QkFBd0IsZ0JBQWdCO0FBQ3hDLDJCQUEyQixzQkFBc0IsOEJBQThCO0FBQy9FLHVCQUF1QjtBQUN2QixDQUFDO0FBQ0QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isc0JBQXNCO0FBQ3JEO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsdUNBQXVDLDZCQUE2QjtBQUNwRTtBQUNBLENBQUM7QUFDRCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLG9FQUFvRSwrQkFBK0I7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsWUFBWSIsInNvdXJjZXMiOlsiSTpcXFNjYWxhQ3Vyc292YXlhXFxCdW5rZXJXZWJcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXGZwLXRzXFxsaWJcXGZ1bmN0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kdWFsID0gZXhwb3J0cy5nZXRFbmRvbW9ycGhpc21Nb25vaWQgPSBleHBvcnRzLlNLID0gZXhwb3J0cy5ob2xlID0gZXhwb3J0cy5jb25zdFZvaWQgPSBleHBvcnRzLmNvbnN0VW5kZWZpbmVkID0gZXhwb3J0cy5jb25zdE51bGwgPSBleHBvcnRzLmNvbnN0RmFsc2UgPSBleHBvcnRzLmNvbnN0VHJ1ZSA9IGV4cG9ydHMudW5zYWZlQ29lcmNlID0gZXhwb3J0cy5hcHBseSA9IGV4cG9ydHMuZ2V0UmluZyA9IGV4cG9ydHMuZ2V0U2VtaXJpbmcgPSBleHBvcnRzLmdldE1vbm9pZCA9IGV4cG9ydHMuZ2V0U2VtaWdyb3VwID0gZXhwb3J0cy5nZXRCb29sZWFuQWxnZWJyYSA9IHZvaWQgMDtcbmV4cG9ydHMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbmV4cG9ydHMuY29uc3RhbnQgPSBjb25zdGFudDtcbmV4cG9ydHMuZmxpcCA9IGZsaXA7XG5leHBvcnRzLmZsb3cgPSBmbG93O1xuZXhwb3J0cy50dXBsZSA9IHR1cGxlO1xuZXhwb3J0cy5pbmNyZW1lbnQgPSBpbmNyZW1lbnQ7XG5leHBvcnRzLmRlY3JlbWVudCA9IGRlY3JlbWVudDtcbmV4cG9ydHMuYWJzdXJkID0gYWJzdXJkO1xuZXhwb3J0cy50dXBsZWQgPSB0dXBsZWQ7XG5leHBvcnRzLnVudHVwbGVkID0gdW50dXBsZWQ7XG5leHBvcnRzLnBpcGUgPSBwaXBlO1xuZXhwb3J0cy5ub3QgPSBub3Q7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBpbnN0YW5jZXNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogQGNhdGVnb3J5IGluc3RhbmNlc1xuICogQHNpbmNlIDIuMTAuMFxuICovXG52YXIgZ2V0Qm9vbGVhbkFsZ2VicmEgPSBmdW5jdGlvbiAoQikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICBtZWV0OiBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIEIubWVldCh4KGEpLCB5KGEpKTsgfTsgfSxcbiAgICAgICAgam9pbjogZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIGZ1bmN0aW9uIChhKSB7IHJldHVybiBCLmpvaW4oeChhKSwgeShhKSk7IH07IH0sXG4gICAgICAgIHplcm86IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEIuemVybzsgfSxcbiAgICAgICAgb25lOiBmdW5jdGlvbiAoKSB7IHJldHVybiBCLm9uZTsgfSxcbiAgICAgICAgaW1wbGllczogZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIGZ1bmN0aW9uIChhKSB7IHJldHVybiBCLmltcGxpZXMoeChhKSwgeShhKSk7IH07IH0sXG4gICAgICAgIG5vdDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIGZ1bmN0aW9uIChhKSB7IHJldHVybiBCLm5vdCh4KGEpKTsgfTsgfVxuICAgIH0pOyB9O1xufTtcbmV4cG9ydHMuZ2V0Qm9vbGVhbkFsZ2VicmEgPSBnZXRCb29sZWFuQWxnZWJyYTtcbi8qKlxuICogVW5hcnkgZnVuY3Rpb25zIGZvcm0gYSBzZW1pZ3JvdXAgYXMgbG9uZyBhcyB5b3UgY2FuIHByb3ZpZGUgYSBzZW1pZ3JvdXAgZm9yIHRoZSBjb2RvbWFpbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgUHJlZGljYXRlLCBnZXRTZW1pZ3JvdXAgfSBmcm9tICdmcC10cy9mdW5jdGlvbidcbiAqIGltcG9ydCAqIGFzIEIgZnJvbSAnZnAtdHMvYm9vbGVhbidcbiAqXG4gKiBjb25zdCBmOiBQcmVkaWNhdGU8bnVtYmVyPiA9IChuKSA9PiBuIDw9IDJcbiAqIGNvbnN0IGc6IFByZWRpY2F0ZTxudW1iZXI+ID0gKG4pID0+IG4gPj0gMFxuICpcbiAqIGNvbnN0IFMxID0gZ2V0U2VtaWdyb3VwKEIuU2VtaWdyb3VwQWxsKTxudW1iZXI+KClcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFMxLmNvbmNhdChmLCBnKSgxKSwgdHJ1ZSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoUzEuY29uY2F0KGYsIGcpKDMpLCBmYWxzZSlcbiAqXG4gKiBjb25zdCBTMiA9IGdldFNlbWlncm91cChCLlNlbWlncm91cEFueSk8bnVtYmVyPigpXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChTMi5jb25jYXQoZiwgZykoMSksIHRydWUpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFMyLmNvbmNhdChmLCBnKSgzKSwgdHJ1ZSlcbiAqXG4gKiBAY2F0ZWdvcnkgaW5zdGFuY2VzXG4gKiBAc2luY2UgMi4xMC4wXG4gKi9cbnZhciBnZXRTZW1pZ3JvdXAgPSBmdW5jdGlvbiAoUykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICBjb25jYXQ6IGZ1bmN0aW9uIChmLCBnKSB7IHJldHVybiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gUy5jb25jYXQoZihhKSwgZyhhKSk7IH07IH1cbiAgICB9KTsgfTtcbn07XG5leHBvcnRzLmdldFNlbWlncm91cCA9IGdldFNlbWlncm91cDtcbi8qKlxuICogVW5hcnkgZnVuY3Rpb25zIGZvcm0gYSBtb25vaWQgYXMgbG9uZyBhcyB5b3UgY2FuIHByb3ZpZGUgYSBtb25vaWQgZm9yIHRoZSBjb2RvbWFpbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgUHJlZGljYXRlIH0gZnJvbSAnZnAtdHMvUHJlZGljYXRlJ1xuICogaW1wb3J0IHsgZ2V0TW9ub2lkIH0gZnJvbSAnZnAtdHMvZnVuY3Rpb24nXG4gKiBpbXBvcnQgKiBhcyBCIGZyb20gJ2ZwLXRzL2Jvb2xlYW4nXG4gKlxuICogY29uc3QgZjogUHJlZGljYXRlPG51bWJlcj4gPSAobikgPT4gbiA8PSAyXG4gKiBjb25zdCBnOiBQcmVkaWNhdGU8bnVtYmVyPiA9IChuKSA9PiBuID49IDBcbiAqXG4gKiBjb25zdCBNMSA9IGdldE1vbm9pZChCLk1vbm9pZEFsbCk8bnVtYmVyPigpXG4gKlxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChNMS5jb25jYXQoZiwgZykoMSksIHRydWUpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKE0xLmNvbmNhdChmLCBnKSgzKSwgZmFsc2UpXG4gKlxuICogY29uc3QgTTIgPSBnZXRNb25vaWQoQi5Nb25vaWRBbnkpPG51bWJlcj4oKVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoTTIuY29uY2F0KGYsIGcpKDEpLCB0cnVlKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChNMi5jb25jYXQoZiwgZykoMyksIHRydWUpXG4gKlxuICogQGNhdGVnb3J5IGluc3RhbmNlc1xuICogQHNpbmNlIDIuMTAuMFxuICovXG52YXIgZ2V0TW9ub2lkID0gZnVuY3Rpb24gKE0pIHtcbiAgICB2YXIgZ2V0U2VtaWdyb3VwTSA9ICgwLCBleHBvcnRzLmdldFNlbWlncm91cCkoTSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgIGNvbmNhdDogZ2V0U2VtaWdyb3VwTSgpLmNvbmNhdCxcbiAgICAgICAgZW1wdHk6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE0uZW1wdHk7IH1cbiAgICB9KTsgfTtcbn07XG5leHBvcnRzLmdldE1vbm9pZCA9IGdldE1vbm9pZDtcbi8qKlxuICogQGNhdGVnb3J5IGluc3RhbmNlc1xuICogQHNpbmNlIDIuMTAuMFxuICovXG52YXIgZ2V0U2VtaXJpbmcgPSBmdW5jdGlvbiAoUykgeyByZXR1cm4gKHtcbiAgICBhZGQ6IGZ1bmN0aW9uIChmLCBnKSB7IHJldHVybiBmdW5jdGlvbiAoeCkgeyByZXR1cm4gUy5hZGQoZih4KSwgZyh4KSk7IH07IH0sXG4gICAgemVybzogZnVuY3Rpb24gKCkgeyByZXR1cm4gUy56ZXJvOyB9LFxuICAgIG11bDogZnVuY3Rpb24gKGYsIGcpIHsgcmV0dXJuIGZ1bmN0aW9uICh4KSB7IHJldHVybiBTLm11bChmKHgpLCBnKHgpKTsgfTsgfSxcbiAgICBvbmU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFMub25lOyB9XG59KTsgfTtcbmV4cG9ydHMuZ2V0U2VtaXJpbmcgPSBnZXRTZW1pcmluZztcbi8qKlxuICogQGNhdGVnb3J5IGluc3RhbmNlc1xuICogQHNpbmNlIDIuMTAuMFxuICovXG52YXIgZ2V0UmluZyA9IGZ1bmN0aW9uIChSKSB7XG4gICAgdmFyIFMgPSAoMCwgZXhwb3J0cy5nZXRTZW1pcmluZykoUik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkOiBTLmFkZCxcbiAgICAgICAgbXVsOiBTLm11bCxcbiAgICAgICAgb25lOiBTLm9uZSxcbiAgICAgICAgemVybzogUy56ZXJvLFxuICAgICAgICBzdWI6IGZ1bmN0aW9uIChmLCBnKSB7IHJldHVybiBmdW5jdGlvbiAoeCkgeyByZXR1cm4gUi5zdWIoZih4KSwgZyh4KSk7IH07IH1cbiAgICB9O1xufTtcbmV4cG9ydHMuZ2V0UmluZyA9IGdldFJpbmc7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB1dGlsc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBAc2luY2UgMi4xMS4wXG4gKi9cbnZhciBhcHBseSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBmKGEpO1xuICAgIH07XG59O1xuZXhwb3J0cy5hcHBseSA9IGFwcGx5O1xuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkoYSkge1xuICAgIHJldHVybiBhO1xufVxuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0cy51bnNhZmVDb2VyY2UgPSBpZGVudGl0eTtcbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KGEpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gYTsgfTtcbn1cbi8qKlxuICogQSB0aHVuayB0aGF0IHJldHVybnMgYWx3YXlzIGB0cnVlYC5cbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0cy5jb25zdFRydWUgPSBjb25zdGFudCh0cnVlKTtcbi8qKlxuICogQSB0aHVuayB0aGF0IHJldHVybnMgYWx3YXlzIGBmYWxzZWAuXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmV4cG9ydHMuY29uc3RGYWxzZSA9IGNvbnN0YW50KGZhbHNlKTtcbi8qKlxuICogQSB0aHVuayB0aGF0IHJldHVybnMgYWx3YXlzIGBudWxsYC5cbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0cy5jb25zdE51bGwgPSBjb25zdGFudChudWxsKTtcbi8qKlxuICogQSB0aHVuayB0aGF0IHJldHVybnMgYWx3YXlzIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5leHBvcnRzLmNvbnN0VW5kZWZpbmVkID0gY29uc3RhbnQodW5kZWZpbmVkKTtcbi8qKlxuICogQSB0aHVuayB0aGF0IHJldHVybnMgYWx3YXlzIGB2b2lkYC5cbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZXhwb3J0cy5jb25zdFZvaWQgPSBleHBvcnRzLmNvbnN0VW5kZWZpbmVkO1xuZnVuY3Rpb24gZmxpcChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZihhcmdzWzFdLCBhcmdzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGYoYSkoYXJnc1swXSk7IH07XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZsb3coYWIsIGJjLCBjZCwgZGUsIGVmLCBmZywgZ2gsIGhpLCBpaikge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gYWI7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJjKGFiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2QoYmMoYWIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGUoY2QoYmMoYWIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVmKGRlKGNkKGJjKGFiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpKSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmcoZWYoZGUoY2QoYmMoYWIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkpKSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2goZmcoZWYoZGUoY2QoYmMoYWIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkpKSkpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhpKGdoKGZnKGVmKGRlKGNkKGJjKGFiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpKSkpKSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWooaGkoZ2goZmcoZWYoZGUoY2QoYmMoYWIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkpKSkpKSkpO1xuICAgICAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuO1xufVxuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZnVuY3Rpb24gdHVwbGUoKSB7XG4gICAgdmFyIHQgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB0W19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiB0O1xufVxuLyoqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuZnVuY3Rpb24gaW5jcmVtZW50KG4pIHtcbiAgICByZXR1cm4gbiArIDE7XG59XG4vKipcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5mdW5jdGlvbiBkZWNyZW1lbnQobikge1xuICAgIHJldHVybiBuIC0gMTtcbn1cbi8qKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmZ1bmN0aW9uIGFic3VyZChfKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsZWQgYGFic3VyZGAgZnVuY3Rpb24gd2hpY2ggc2hvdWxkIGJlIHVuY2FsbGFibGUnKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHR1cGxlZCB2ZXJzaW9uIG9mIHRoaXMgZnVuY3Rpb246IGluc3RlYWQgb2YgYG5gIGFyZ3VtZW50cywgaXQgYWNjZXB0cyBhIHNpbmdsZSB0dXBsZSBhcmd1bWVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgdHVwbGVkIH0gZnJvbSAnZnAtdHMvZnVuY3Rpb24nXG4gKlxuICogY29uc3QgYWRkID0gdHVwbGVkKCh4OiBudW1iZXIsIHk6IG51bWJlcik6IG51bWJlciA9PiB4ICsgeSlcbiAqXG4gKiBhc3NlcnQuc3RyaWN0RXF1YWwoYWRkKFsxLCAyXSksIDMpXG4gKlxuICogQHNpbmNlIDIuNC4wXG4gKi9cbmZ1bmN0aW9uIHR1cGxlZChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7IHJldHVybiBmLmFwcGx5KHZvaWQgMCwgYSk7IH07XG59XG4vKipcbiAqIEludmVyc2UgZnVuY3Rpb24gb2YgYHR1cGxlZGBcbiAqXG4gKiBAc2luY2UgMi40LjBcbiAqL1xuZnVuY3Rpb24gdW50dXBsZWQoZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGYoYSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBpcGUoYSwgYWIsIGJjLCBjZCwgZGUsIGVmLCBmZywgZ2gsIGhpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gYWIoYSk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBiYyhhYihhKSk7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiBjZChiYyhhYihhKSkpO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gZGUoY2QoYmMoYWIoYSkpKSk7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJldHVybiBlZihkZShjZChiYyhhYihhKSkpKSk7XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJldHVybiBmZyhlZihkZShjZChiYyhhYihhKSkpKSkpO1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICByZXR1cm4gZ2goZmcoZWYoZGUoY2QoYmMoYWIoYSkpKSkpKSk7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHJldHVybiBoaShnaChmZyhlZihkZShjZChiYyhhYihhKSkpKSkpKSk7XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHZhciByZXQgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJldCA9IGFyZ3VtZW50c1tpXShyZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogVHlwZSBob2xlIHNpbXVsYXRpb25cbiAqXG4gKiBAc2luY2UgMi43LjBcbiAqL1xuZXhwb3J0cy5ob2xlID0gYWJzdXJkO1xuLyoqXG4gKiBAc2luY2UgMi4xMS4wXG4gKi9cbnZhciBTSyA9IGZ1bmN0aW9uIChfLCBiKSB7IHJldHVybiBiOyB9O1xuZXhwb3J0cy5TSyA9IFNLO1xuLyoqXG4gKiBVc2UgYFByZWRpY2F0ZWAgbW9kdWxlIGluc3RlYWQuXG4gKlxuICogQGNhdGVnb3J5IHpvbmUgb2YgZGVhdGhcbiAqIEBzaW5jZSAyLjAuMFxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZnVuY3Rpb24gbm90KHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gIXByZWRpY2F0ZShhKTsgfTtcbn1cbi8qKlxuICogVXNlIGBFbmRvbW9ycGhpc21gIG1vZHVsZSBpbnN0ZWFkLlxuICpcbiAqIEBjYXRlZ29yeSB6b25lIG9mIGRlYXRoXG4gKiBAc2luY2UgMi4xMC4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG52YXIgZ2V0RW5kb21vcnBoaXNtTW9ub2lkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICBjb25jYXQ6IGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKSB7IHJldHVybiBmbG93KGZpcnN0LCBzZWNvbmQpOyB9LFxuICAgIGVtcHR5OiBpZGVudGl0eVxufSk7IH07XG5leHBvcnRzLmdldEVuZG9tb3JwaGlzbU1vbm9pZCA9IGdldEVuZG9tb3JwaGlzbU1vbm9pZDtcbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBkdWFsID0gZnVuY3Rpb24gKGFyaXR5LCBib2R5KSB7XG4gICAgdmFyIGlzRGF0YUZpcnN0ID0gdHlwZW9mIGFyaXR5ID09PSAnbnVtYmVyJyA/IGZ1bmN0aW9uIChhcmdzKSB7IHJldHVybiBhcmdzLmxlbmd0aCA+PSBhcml0eTsgfSA6IGFyaXR5O1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkuZnJvbShhcmd1bWVudHMpO1xuICAgICAgICBpZiAoaXNEYXRhRmlyc3QoYXJndW1lbnRzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGJvZHkuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzZWxmKSB7IHJldHVybiBib2R5LmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbc2VsZl0sIGFyZ3MsIGZhbHNlKSk7IH07XG4gICAgfTtcbn07XG5leHBvcnRzLmR1YWwgPSBkdWFsO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fp-ts/lib/function.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fp-ts/lib/internal.js":
/*!********************************************!*\
  !*** ./node_modules/fp-ts/lib/internal.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.flatMapReader = exports.flatMapTask = exports.flatMapIO = exports.flatMapEither = exports.flatMapOption = exports.flatMapNullable = exports.liftOption = exports.liftNullable = exports.fromReadonlyNonEmptyArray = exports.has = exports.emptyRecord = exports.emptyReadonlyArray = exports.tail = exports.head = exports.isNonEmpty = exports.singleton = exports.right = exports.left = exports.isRight = exports.isLeft = exports.some = exports.none = exports.isSome = exports.isNone = void 0;\nvar function_1 = __webpack_require__(/*! ./function */ \"(app-pages-browser)/./node_modules/fp-ts/lib/function.js\");\n// -------------------------------------------------------------------------------------\n// Option\n// -------------------------------------------------------------------------------------\n/** @internal */\nvar isNone = function (fa) { return fa._tag === 'None'; };\nexports.isNone = isNone;\n/** @internal */\nvar isSome = function (fa) { return fa._tag === 'Some'; };\nexports.isSome = isSome;\n/** @internal */\nexports.none = { _tag: 'None' };\n/** @internal */\nvar some = function (a) { return ({ _tag: 'Some', value: a }); };\nexports.some = some;\n// -------------------------------------------------------------------------------------\n// Either\n// -------------------------------------------------------------------------------------\n/** @internal */\nvar isLeft = function (ma) { return ma._tag === 'Left'; };\nexports.isLeft = isLeft;\n/** @internal */\nvar isRight = function (ma) { return ma._tag === 'Right'; };\nexports.isRight = isRight;\n/** @internal */\nvar left = function (e) { return ({ _tag: 'Left', left: e }); };\nexports.left = left;\n/** @internal */\nvar right = function (a) { return ({ _tag: 'Right', right: a }); };\nexports.right = right;\n// -------------------------------------------------------------------------------------\n// ReadonlyNonEmptyArray\n// -------------------------------------------------------------------------------------\n/** @internal */\nvar singleton = function (a) { return [a]; };\nexports.singleton = singleton;\n/** @internal */\nvar isNonEmpty = function (as) { return as.length > 0; };\nexports.isNonEmpty = isNonEmpty;\n/** @internal */\nvar head = function (as) { return as[0]; };\nexports.head = head;\n/** @internal */\nvar tail = function (as) { return as.slice(1); };\nexports.tail = tail;\n// -------------------------------------------------------------------------------------\n// empty\n// -------------------------------------------------------------------------------------\n/** @internal */\nexports.emptyReadonlyArray = [];\n/** @internal */\nexports.emptyRecord = {};\n// -------------------------------------------------------------------------------------\n// Record\n// -------------------------------------------------------------------------------------\n/** @internal */\nexports.has = Object.prototype.hasOwnProperty;\n// -------------------------------------------------------------------------------------\n// NonEmptyArray\n// -------------------------------------------------------------------------------------\n/** @internal */\nvar fromReadonlyNonEmptyArray = function (as) { return __spreadArray([as[0]], as.slice(1), true); };\nexports.fromReadonlyNonEmptyArray = fromReadonlyNonEmptyArray;\n/** @internal */\nvar liftNullable = function (F) {\n    return function (f, onNullable) {\n        return function () {\n            var a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                a[_i] = arguments[_i];\n            }\n            var o = f.apply(void 0, a);\n            return F.fromEither(o == null ? (0, exports.left)(onNullable.apply(void 0, a)) : (0, exports.right)(o));\n        };\n    };\n};\nexports.liftNullable = liftNullable;\n/** @internal */\nvar liftOption = function (F) {\n    return function (f, onNone) {\n        return function () {\n            var a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                a[_i] = arguments[_i];\n            }\n            var o = f.apply(void 0, a);\n            return F.fromEither((0, exports.isNone)(o) ? (0, exports.left)(onNone.apply(void 0, a)) : (0, exports.right)(o.value));\n        };\n    };\n};\nexports.liftOption = liftOption;\n/** @internal */\nvar flatMapNullable = function (F, M) {\n    return /*#__PURE__*/ (0, function_1.dual)(3, function (self, f, onNullable) {\n        return M.flatMap(self, (0, exports.liftNullable)(F)(f, onNullable));\n    });\n};\nexports.flatMapNullable = flatMapNullable;\n/** @internal */\nvar flatMapOption = function (F, M) {\n    return /*#__PURE__*/ (0, function_1.dual)(3, function (self, f, onNone) { return M.flatMap(self, (0, exports.liftOption)(F)(f, onNone)); });\n};\nexports.flatMapOption = flatMapOption;\n/** @internal */\nvar flatMapEither = function (F, M) {\n    return /*#__PURE__*/ (0, function_1.dual)(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromEither(f(a)); });\n    });\n};\nexports.flatMapEither = flatMapEither;\n/** @internal */\nvar flatMapIO = function (F, M) {\n    return /*#__PURE__*/ (0, function_1.dual)(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromIO(f(a)); });\n    });\n};\nexports.flatMapIO = flatMapIO;\n/** @internal */\nvar flatMapTask = function (F, M) {\n    return /*#__PURE__*/ (0, function_1.dual)(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromTask(f(a)); });\n    });\n};\nexports.flatMapTask = flatMapTask;\n/** @internal */\nvar flatMapReader = function (F, M) {\n    return /*#__PURE__*/ (0, function_1.dual)(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromReader(f(a)); });\n    });\n};\nexports.flatMapReader = flatMapReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcC10cy9saWIvaW50ZXJuYWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZFQUE2RSxPQUFPO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixHQUFHLG1CQUFtQixHQUFHLGlCQUFpQixHQUFHLHFCQUFxQixHQUFHLHFCQUFxQixHQUFHLHVCQUF1QixHQUFHLGtCQUFrQixHQUFHLG9CQUFvQixHQUFHLGlDQUFpQyxHQUFHLFdBQVcsR0FBRyxtQkFBbUIsR0FBRywwQkFBMEIsR0FBRyxZQUFZLEdBQUcsWUFBWSxHQUFHLGtCQUFrQixHQUFHLGlCQUFpQixHQUFHLGFBQWEsR0FBRyxZQUFZLEdBQUcsZUFBZSxHQUFHLGNBQWMsR0FBRyxZQUFZLEdBQUcsWUFBWSxHQUFHLGNBQWMsR0FBRyxjQUFjO0FBQ25lLGlCQUFpQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLGNBQWM7QUFDZDtBQUNBLDZCQUE2QjtBQUM3QixjQUFjO0FBQ2Q7QUFDQSxZQUFZLEtBQUs7QUFDakI7QUFDQSwwQkFBMEIsVUFBVSx3QkFBd0I7QUFDNUQsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLGNBQWM7QUFDZDtBQUNBLDhCQUE4QjtBQUM5QixlQUFlO0FBQ2Y7QUFDQSwwQkFBMEIsVUFBVSx1QkFBdUI7QUFDM0QsWUFBWTtBQUNaO0FBQ0EsMkJBQTJCLFVBQVUseUJBQXlCO0FBQzlELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixpQkFBaUI7QUFDakI7QUFDQSxpQ0FBaUM7QUFDakMsa0JBQWtCO0FBQ2xCO0FBQ0EsMkJBQTJCO0FBQzNCLFlBQVk7QUFDWjtBQUNBLDJCQUEyQjtBQUMzQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSw4RUFBOEUsZ0VBQWdFO0FBQzlJO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyw0QkFBNEI7QUFDMUUsS0FBSztBQUNMO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3QkFBd0I7QUFDdEUsS0FBSztBQUNMO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywwQkFBMEI7QUFDeEUsS0FBSztBQUNMO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyw0QkFBNEI7QUFDMUUsS0FBSztBQUNMO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyJJOlxcU2NhbGFDdXJzb3ZheWFcXEJ1bmtlcldlYlxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcZnAtdHNcXGxpYlxcaW50ZXJuYWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZsYXRNYXBSZWFkZXIgPSBleHBvcnRzLmZsYXRNYXBUYXNrID0gZXhwb3J0cy5mbGF0TWFwSU8gPSBleHBvcnRzLmZsYXRNYXBFaXRoZXIgPSBleHBvcnRzLmZsYXRNYXBPcHRpb24gPSBleHBvcnRzLmZsYXRNYXBOdWxsYWJsZSA9IGV4cG9ydHMubGlmdE9wdGlvbiA9IGV4cG9ydHMubGlmdE51bGxhYmxlID0gZXhwb3J0cy5mcm9tUmVhZG9ubHlOb25FbXB0eUFycmF5ID0gZXhwb3J0cy5oYXMgPSBleHBvcnRzLmVtcHR5UmVjb3JkID0gZXhwb3J0cy5lbXB0eVJlYWRvbmx5QXJyYXkgPSBleHBvcnRzLnRhaWwgPSBleHBvcnRzLmhlYWQgPSBleHBvcnRzLmlzTm9uRW1wdHkgPSBleHBvcnRzLnNpbmdsZXRvbiA9IGV4cG9ydHMucmlnaHQgPSBleHBvcnRzLmxlZnQgPSBleHBvcnRzLmlzUmlnaHQgPSBleHBvcnRzLmlzTGVmdCA9IGV4cG9ydHMuc29tZSA9IGV4cG9ydHMubm9uZSA9IGV4cG9ydHMuaXNTb21lID0gZXhwb3J0cy5pc05vbmUgPSB2b2lkIDA7XG52YXIgZnVuY3Rpb25fMSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9uXCIpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT3B0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKiogQGludGVybmFsICovXG52YXIgaXNOb25lID0gZnVuY3Rpb24gKGZhKSB7IHJldHVybiBmYS5fdGFnID09PSAnTm9uZSc7IH07XG5leHBvcnRzLmlzTm9uZSA9IGlzTm9uZTtcbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBpc1NvbWUgPSBmdW5jdGlvbiAoZmEpIHsgcmV0dXJuIGZhLl90YWcgPT09ICdTb21lJzsgfTtcbmV4cG9ydHMuaXNTb21lID0gaXNTb21lO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0cy5ub25lID0geyBfdGFnOiAnTm9uZScgfTtcbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBzb21lID0gZnVuY3Rpb24gKGEpIHsgcmV0dXJuICh7IF90YWc6ICdTb21lJywgdmFsdWU6IGEgfSk7IH07XG5leHBvcnRzLnNvbWUgPSBzb21lO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRWl0aGVyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKiogQGludGVybmFsICovXG52YXIgaXNMZWZ0ID0gZnVuY3Rpb24gKG1hKSB7IHJldHVybiBtYS5fdGFnID09PSAnTGVmdCc7IH07XG5leHBvcnRzLmlzTGVmdCA9IGlzTGVmdDtcbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBpc1JpZ2h0ID0gZnVuY3Rpb24gKG1hKSB7IHJldHVybiBtYS5fdGFnID09PSAnUmlnaHQnOyB9O1xuZXhwb3J0cy5pc1JpZ2h0ID0gaXNSaWdodDtcbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBsZWZ0ID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuICh7IF90YWc6ICdMZWZ0JywgbGVmdDogZSB9KTsgfTtcbmV4cG9ydHMubGVmdCA9IGxlZnQ7XG4vKiogQGludGVybmFsICovXG52YXIgcmlnaHQgPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gKHsgX3RhZzogJ1JpZ2h0JywgcmlnaHQ6IGEgfSk7IH07XG5leHBvcnRzLnJpZ2h0ID0gcmlnaHQ7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZWFkb25seU5vbkVtcHR5QXJyYXlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBzaW5nbGV0b24gPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gW2FdOyB9O1xuZXhwb3J0cy5zaW5nbGV0b24gPSBzaW5nbGV0b247XG4vKiogQGludGVybmFsICovXG52YXIgaXNOb25FbXB0eSA9IGZ1bmN0aW9uIChhcykgeyByZXR1cm4gYXMubGVuZ3RoID4gMDsgfTtcbmV4cG9ydHMuaXNOb25FbXB0eSA9IGlzTm9uRW1wdHk7XG4vKiogQGludGVybmFsICovXG52YXIgaGVhZCA9IGZ1bmN0aW9uIChhcykgeyByZXR1cm4gYXNbMF07IH07XG5leHBvcnRzLmhlYWQgPSBoZWFkO1xuLyoqIEBpbnRlcm5hbCAqL1xudmFyIHRhaWwgPSBmdW5jdGlvbiAoYXMpIHsgcmV0dXJuIGFzLnNsaWNlKDEpOyB9O1xuZXhwb3J0cy50YWlsID0gdGFpbDtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGVtcHR5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKiogQGludGVybmFsICovXG5leHBvcnRzLmVtcHR5UmVhZG9ubHlBcnJheSA9IFtdO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0cy5lbXB0eVJlY29yZCA9IHt9O1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUmVjb3JkXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKiogQGludGVybmFsICovXG5leHBvcnRzLmhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBOb25FbXB0eUFycmF5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKiogQGludGVybmFsICovXG52YXIgZnJvbVJlYWRvbmx5Tm9uRW1wdHlBcnJheSA9IGZ1bmN0aW9uIChhcykgeyByZXR1cm4gX19zcHJlYWRBcnJheShbYXNbMF1dLCBhcy5zbGljZSgxKSwgdHJ1ZSk7IH07XG5leHBvcnRzLmZyb21SZWFkb25seU5vbkVtcHR5QXJyYXkgPSBmcm9tUmVhZG9ubHlOb25FbXB0eUFycmF5O1xuLyoqIEBpbnRlcm5hbCAqL1xudmFyIGxpZnROdWxsYWJsZSA9IGZ1bmN0aW9uIChGKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChmLCBvbk51bGxhYmxlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbyA9IGYuYXBwbHkodm9pZCAwLCBhKTtcbiAgICAgICAgICAgIHJldHVybiBGLmZyb21FaXRoZXIobyA9PSBudWxsID8gKDAsIGV4cG9ydHMubGVmdCkob25OdWxsYWJsZS5hcHBseSh2b2lkIDAsIGEpKSA6ICgwLCBleHBvcnRzLnJpZ2h0KShvKSk7XG4gICAgICAgIH07XG4gICAgfTtcbn07XG5leHBvcnRzLmxpZnROdWxsYWJsZSA9IGxpZnROdWxsYWJsZTtcbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBsaWZ0T3B0aW9uID0gZnVuY3Rpb24gKEYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGYsIG9uTm9uZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYVtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG8gPSBmLmFwcGx5KHZvaWQgMCwgYSk7XG4gICAgICAgICAgICByZXR1cm4gRi5mcm9tRWl0aGVyKCgwLCBleHBvcnRzLmlzTm9uZSkobykgPyAoMCwgZXhwb3J0cy5sZWZ0KShvbk5vbmUuYXBwbHkodm9pZCAwLCBhKSkgOiAoMCwgZXhwb3J0cy5yaWdodCkoby52YWx1ZSkpO1xuICAgICAgICB9O1xuICAgIH07XG59O1xuZXhwb3J0cy5saWZ0T3B0aW9uID0gbGlmdE9wdGlvbjtcbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBmbGF0TWFwTnVsbGFibGUgPSBmdW5jdGlvbiAoRiwgTSkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCBmdW5jdGlvbl8xLmR1YWwpKDMsIGZ1bmN0aW9uIChzZWxmLCBmLCBvbk51bGxhYmxlKSB7XG4gICAgICAgIHJldHVybiBNLmZsYXRNYXAoc2VsZiwgKDAsIGV4cG9ydHMubGlmdE51bGxhYmxlKShGKShmLCBvbk51bGxhYmxlKSk7XG4gICAgfSk7XG59O1xuZXhwb3J0cy5mbGF0TWFwTnVsbGFibGUgPSBmbGF0TWFwTnVsbGFibGU7XG4vKiogQGludGVybmFsICovXG52YXIgZmxhdE1hcE9wdGlvbiA9IGZ1bmN0aW9uIChGLCBNKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsIGZ1bmN0aW9uXzEuZHVhbCkoMywgZnVuY3Rpb24gKHNlbGYsIGYsIG9uTm9uZSkgeyByZXR1cm4gTS5mbGF0TWFwKHNlbGYsICgwLCBleHBvcnRzLmxpZnRPcHRpb24pKEYpKGYsIG9uTm9uZSkpOyB9KTtcbn07XG5leHBvcnRzLmZsYXRNYXBPcHRpb24gPSBmbGF0TWFwT3B0aW9uO1xuLyoqIEBpbnRlcm5hbCAqL1xudmFyIGZsYXRNYXBFaXRoZXIgPSBmdW5jdGlvbiAoRiwgTSkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCBmdW5jdGlvbl8xLmR1YWwpKDIsIGZ1bmN0aW9uIChzZWxmLCBmKSB7XG4gICAgICAgIHJldHVybiBNLmZsYXRNYXAoc2VsZiwgZnVuY3Rpb24gKGEpIHsgcmV0dXJuIEYuZnJvbUVpdGhlcihmKGEpKTsgfSk7XG4gICAgfSk7XG59O1xuZXhwb3J0cy5mbGF0TWFwRWl0aGVyID0gZmxhdE1hcEVpdGhlcjtcbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBmbGF0TWFwSU8gPSBmdW5jdGlvbiAoRiwgTSkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCBmdW5jdGlvbl8xLmR1YWwpKDIsIGZ1bmN0aW9uIChzZWxmLCBmKSB7XG4gICAgICAgIHJldHVybiBNLmZsYXRNYXAoc2VsZiwgZnVuY3Rpb24gKGEpIHsgcmV0dXJuIEYuZnJvbUlPKGYoYSkpOyB9KTtcbiAgICB9KTtcbn07XG5leHBvcnRzLmZsYXRNYXBJTyA9IGZsYXRNYXBJTztcbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBmbGF0TWFwVGFzayA9IGZ1bmN0aW9uIChGLCBNKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsIGZ1bmN0aW9uXzEuZHVhbCkoMiwgZnVuY3Rpb24gKHNlbGYsIGYpIHtcbiAgICAgICAgcmV0dXJuIE0uZmxhdE1hcChzZWxmLCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gRi5mcm9tVGFzayhmKGEpKTsgfSk7XG4gICAgfSk7XG59O1xuZXhwb3J0cy5mbGF0TWFwVGFzayA9IGZsYXRNYXBUYXNrO1xuLyoqIEBpbnRlcm5hbCAqL1xudmFyIGZsYXRNYXBSZWFkZXIgPSBmdW5jdGlvbiAoRiwgTSkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCBmdW5jdGlvbl8xLmR1YWwpKDIsIGZ1bmN0aW9uIChzZWxmLCBmKSB7XG4gICAgICAgIHJldHVybiBNLmZsYXRNYXAoc2VsZiwgZnVuY3Rpb24gKGEpIHsgcmV0dXJuIEYuZnJvbVJlYWRlcihmKGEpKTsgfSk7XG4gICAgfSk7XG59O1xuZXhwb3J0cy5mbGF0TWFwUmVhZGVyID0gZmxhdE1hcFJlYWRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fp-ts/lib/internal.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/gameWindow/page.tsx":
/*!*************************************!*\
  !*** ./src/app/gameWindow/page.tsx ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GameWindows)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var fp_ts_function__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! fp-ts/function */ \"(app-pages-browser)/./node_modules/fp-ts/es6/function.js\");\n/* harmony import */ var fp_ts_lib_Option__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! fp-ts/lib/Option */ \"(app-pages-browser)/./node_modules/fp-ts/lib/Option.js\");\n/* harmony import */ var fp_ts_lib_Option__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(fp_ts_lib_Option__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _GameStateReducer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GameStateReducer */ \"(app-pages-browser)/./src/app/gameWindow/GameStateReducer.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nconst URL = \"ws://localhost:9090/ws\";\nconst initState = {\n    type: \"WaitingForConnection\",\n    markup: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n        fileName: \"I:\\\\ScalaCursovaya\\\\BunkerWeb\\\\frontend\\\\src\\\\app\\\\gameWindow\\\\page.tsx\",\n        lineNumber: 24,\n        columnNumber: 12\n    }, undefined)\n};\nconst ParseParams = (params)=>{\n    return (0,fp_ts_function__WEBPACK_IMPORTED_MODULE_3__.pipe)(params, fp_ts_lib_Option__WEBPACK_IMPORTED_MODULE_4__.fromNullable, fp_ts_lib_Option__WEBPACK_IMPORTED_MODULE_4__.flatMap((searchParams)=>{\n        const data = searchParams.get('data');\n        const parsedData = data ? JSON.parse(data) : null;\n        if (parsedData) {\n            return fp_ts_lib_Option__WEBPACK_IMPORTED_MODULE_4__.some(parsedData);\n        } else {\n            return fp_ts_lib_Option__WEBPACK_IMPORTED_MODULE_4__.none;\n        }\n    }));\n};\n_c = ParseParams;\nfunction GameWindows() {\n    _s();\n    const [currentState, actionReducer] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useReducer)(_GameStateReducer__WEBPACK_IMPORTED_MODULE_2__.ReduceState, initState);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"GameWindows.useEffect\": ()=>{}\n    }[\"GameWindows.useEffect\"]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: currentState.markup\n    }, void 0, false);\n}\n_s(GameWindows, \"AIbzz7eJPWia1H7bQckSH7inpd0=\");\n_c1 = GameWindows;\nvar _c, _c1;\n$RefreshReg$(_c, \"ParseParams\");\n$RefreshReg$(_c1, \"GameWindows\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZ2FtZVdpbmRvdy9wYWdlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBRzZFO0FBQ3ZDO0FBT0Q7QUFNaUM7QUFHdEUsTUFBTUssTUFBTTtBQUNaLE1BQU1DLFlBQXdCO0lBQzFCQyxNQUFLO0lBQ0xDLHNCQUFPLDhEQUFDQzs7Ozs7QUFDVjtBQU9GLE1BQU1DLGNBQWMsQ0FBQ0M7SUFDakIsT0FBT1Qsb0RBQUlBLENBQ1RTLFFBQ0FSLDBEQUFjLEVBQ2RBLHFEQUFTLENBQUNXLENBQUFBO1FBQ04sTUFBTUMsT0FBT0QsYUFBYUUsR0FBRyxDQUFDO1FBQzlCLE1BQU1DLGFBQWFGLE9BQU9HLEtBQUtDLEtBQUssQ0FBQ0osUUFBUTtRQUM3QyxJQUFHRSxZQUFZO1lBQ2IsT0FBT2Qsa0RBQU0sQ0FBQ2M7UUFDaEIsT0FBTztZQUNMLE9BQU9kLGtEQUFNO1FBQ2Y7SUFDRjtBQUVOO0tBZElPO0FBaUJTLFNBQVNZOztJQUd0QixNQUFNLENBQUNDLGNBQWFDLGNBQWMsR0FBR3ZCLGlEQUFVQSxDQUFDRywwREFBV0EsRUFBQ0U7SUFDNUROLGdEQUFTQTtpQ0FBQyxLQUVWOztJQUdBLHFCQUFPO2tCQUNKdUIsYUFBYWYsTUFBTTs7QUFFeEI7R0Fad0JjO01BQUFBIiwic291cmNlcyI6WyJJOlxcU2NhbGFDdXJzb3ZheWFcXEJ1bmtlcldlYlxcZnJvbnRlbmRcXHNyY1xcYXBwXFxnYW1lV2luZG93XFxwYWdlLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcclxuXHJcbmltcG9ydCB7IGVpdGhlclQsIHJlYWRvbmx5QXJyYXksIHN0YXRlIH0gZnJvbSAnZnAtdHMnO1xyXG5pbXBvcnQgeyB1c2VSZWYsIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlU3RhdGUsIEpTWCwgdXNlUmVkdWNlciB9IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgeyBwaXBlIH0gZnJvbSAnZnAtdHMvZnVuY3Rpb24nO1xyXG5pbXBvcnQgKiBhcyBXUyBmcm9tICdAL2FwcC9XZWJzb2NrZXQnXHJcbmltcG9ydCAqIGFzIEUgZnJvbSAnZnAtdHMvbGliL0VpdGhlcic7XHJcbmltcG9ydCAqIGFzIFRFIGZyb20gJ2ZwLXRzL2xpYi9UYXNrRWl0aGVyJztcclxuaW1wb3J0IHsgUmVhZG9ubHlVUkxTZWFyY2hQYXJhbXMsIHVzZVBhcmFtcywgdXNlU2VhcmNoUGFyYW1zIH0gZnJvbSAnbmV4dC9uYXZpZ2F0aW9uJztcclxuaW1wb3J0IHsgc2VyaWFsaXplIH0gZnJvbSAndjgnO1xyXG5pbXBvcnQgKiBhcyBJTyBmcm9tICdmcC10cy9saWIvSU8nO1xyXG5pbXBvcnQgKiBhcyBPIGZyb20gXCJmcC10cy9saWIvT3B0aW9uXCJcclxuaW1wb3J0ICogYXMgVCBmcm9tICdmcC10cy9saWIvVGFzayc7XHJcbmltcG9ydCB7IG1hcCB9IGZyb20gJ2ZwLXRzL2xpYi9FaXRoZXJUJztcclxuaW1wb3J0ICogYXMgUyBmcm9tICdmcC10cy9saWIvU3RhdGUnO1xyXG5pbXBvcnQgeyB1c2VTdGF0ZU1vbmFkIH0gZnJvbSAnLi9TdGF0ZU1vbmFkSG9vayc7XHJcbmltcG9ydCB7IFdlYnNvY2tldENvbW1hbmRzIH0gZnJvbSBcIi4vV2Vic29ja2V0TWFuaXB1bGF0aW9uc1wiO1xyXG5pbXBvcnQgeyBSZWR1Y2VTdGF0ZSAsR2FtZUFjdGlvbixHYW1lU3RhdGV9IGZyb20gXCIuL0dhbWVTdGF0ZVJlZHVjZXJcIjtcclxuXHJcblxyXG5jb25zdCBVUkwgPSBcIndzOi8vbG9jYWxob3N0OjkwOTAvd3NcIlxyXG5jb25zdCBpbml0U3RhdGUgOiBHYW1lU3RhdGUgPSB7XHJcbiAgICB0eXBlOlwiV2FpdGluZ0ZvckNvbm5lY3Rpb25cIixcclxuICAgIG1hcmt1cDo8ZGl2PjwvZGl2PlxyXG4gIH1cclxuXHJcbnR5cGUgVXNlckNvbm5lY3Rpb25EYXRhID0ge1xyXG4gIHNlc3Npb25JZDpzdHJpbmcsXHJcbiAgdXNlcklkOnN0cmluZ1xyXG59XHJcblxyXG5jb25zdCBQYXJzZVBhcmFtcyA9IChwYXJhbXM6UmVhZG9ubHlVUkxTZWFyY2hQYXJhbXMgfCBudWxsKSA6IE8uT3B0aW9uPFVzZXJDb25uZWN0aW9uRGF0YT4gPT4ge1xyXG4gICAgcmV0dXJuIHBpcGUoXHJcbiAgICAgIHBhcmFtcyxcclxuICAgICAgTy5mcm9tTnVsbGFibGUsXHJcbiAgICAgIE8uZmxhdE1hcChzZWFyY2hQYXJhbXMgPT4ge1xyXG4gICAgICAgICAgY29uc3QgZGF0YSA9IHNlYXJjaFBhcmFtcy5nZXQoJ2RhdGEnKTtcclxuICAgICAgICAgIGNvbnN0IHBhcnNlZERhdGEgPSBkYXRhID8gSlNPTi5wYXJzZShkYXRhKSA6IG51bGw7XHJcbiAgICAgICAgICBpZihwYXJzZWREYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPLnNvbWUocGFyc2VkRGF0YSlcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPLm5vbmVcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICApXHJcbiAgfVxyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEdhbWVXaW5kb3dzKCl7XHJcbiAgXHJcblxyXG4gIGNvbnN0IFtjdXJyZW50U3RhdGUsYWN0aW9uUmVkdWNlcl0gPSB1c2VSZWR1Y2VyKFJlZHVjZVN0YXRlLGluaXRTdGF0ZSlcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgXHJcbiAgfSlcclxuXHJcblxyXG4gIHJldHVybig8PlxyXG4gICAge2N1cnJlbnRTdGF0ZS5tYXJrdXB9XHJcbiAgPC8+KVxyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWR1Y2VyIiwicGlwZSIsIk8iLCJSZWR1Y2VTdGF0ZSIsIlVSTCIsImluaXRTdGF0ZSIsInR5cGUiLCJtYXJrdXAiLCJkaXYiLCJQYXJzZVBhcmFtcyIsInBhcmFtcyIsImZyb21OdWxsYWJsZSIsImZsYXRNYXAiLCJzZWFyY2hQYXJhbXMiLCJkYXRhIiwiZ2V0IiwicGFyc2VkRGF0YSIsIkpTT04iLCJwYXJzZSIsInNvbWUiLCJub25lIiwiR2FtZVdpbmRvd3MiLCJjdXJyZW50U3RhdGUiLCJhY3Rpb25SZWR1Y2VyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/gameWindow/page.tsx\n"));

/***/ })

});